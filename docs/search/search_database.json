var tipuesearch = {"pages":[{"title":" ROTEX ","text":"ROTEX ROTational EXcitation of ions by electron impact (ROTEX) Calculates electron-impact rotational (de-)excitation cross sections for asymmetric top molecules, using the Coulomb-Born (CB) approximation and Multichannel Quantum Defect Theory (MQDT) . One or both can be used to determine electron-impact rotational excitation cross sections If both are used, then the so-called Born closure will be used for electron-impact transitions that appear in the MQDT and CB cross sections to account for partial waves that are not included in the MQDT treatment: : CB cross sections for : CB cross sections for : MQDT cross sections for The quantity is the largest value for the partial waves in the scattering calculations used to generate K-matrices used in the MQDT approach. In principle, this also works for symmetric tops and linear rotors, but those special cases have not been explicitly programmed in. Build dependencies Neither of these are necessary of course, but it will be much easier to build with one of them. ( optional) The Fortran Package Manager (fpm) ( optional ) GNU Make Currently, make gives more flexibility, as the user can choose which optional dependencies to exclude (because they are included by default), but fpm easily saves and automatically targets differently compiled versions of the code (e.g., “release” and “debug” profiles). Dependencies A LAPACK implementation Bspline-fortran for combining cross sections on the same energy grid ( optional ) CDMSreader for optionally reading in CDMS data to use in the Coulomb-Born approximation ( optional ) Forbear for progress bars ( optional ) OpenMP for easy thread parallelization Building with fpm In the package directory, just run fpm build --profile release to download dependencies and build the project. Fpm alway uses all dependencies because (as of writing this) it is not yet capable of using the C preprocessor to handle optional USE statements. Building without fpm In the package directory, just run make to install the executable to bin/rotex . The dependency repositories are automatically assumed to be included in build/dependencies (see the Makefile for more details). To omit the use of CDMSreader , Forbear , or OpenMP , just set the corresponding environmental variable to 0. For example, make clean build USE_CDMSREADER=0 USE_FORBEAR=0 USE_OPENMP=0 disables those three optional dependencies. Be sure to change the FC variable if gfortran is not your compiler of choice (and adjust FFLAGS accordingly). See the Makefile for more detail. Usage An executable will be built by fpm which can be run directly, but fpm can also be invoked to run the code, which expects a namelist file to be given via stdin, i.e. fpm run --profile release < example/example.mqdtr2k.H2O+.namelist or if you built with make ./bin/rotex < example/example.mqdtr2k.H2O+.namelist Compatibility with different operating systems This has only been tested on Linux-based systems for now. In principle, it should work on others but that is not a guarantee. Structure of the input (namelist) files Namelists are used to read in values to whole groups of variables that will control program execution. A namelist group name is defined with the ampersand (&) and the namelist group is terminated with with a foward slash (/). The program contains three namelists: &control_namelist &kmat_namelist &coulomb_namelist The namelist variables are declared in src/rotex__reading.f The order of the namelist groups in the input file is unimportant. Example namelists that should produce successful runes are given in the example directory. &control_namelist The first and main namelist group is always used: &control_namelist . It controls the main flow of the program and contains the following variables. &control_namelist output_directory !! Output directory for the code Nmin = !! Smallest N (rotational quantum number) for excitation Nmax = !! Largest N (rotational quantum number) for excitation use_kmat = !! Use K-matrices to get cross sections ? If .true., use KMAT_NAMELIST variables use_CB = !! Use the Culomb-Born approximation to get cross sections ? If .true., use COULOMB_NAMELIST variables rotor_kind = !! The rotor kind of the target !!   \"a\": asymmetric top !!   \"s\": symmetric top (not implemented yet) !!   \"l\": symmetric top (not implemented yet) target_charge = !! The target charge (integer) spin_isomer_kind = !! The spin isomer kind to enforce for the molecule. !!   0*: none (spin symmetry may be self-enforced by the underlying calculations and dipole vector) !!   2 : Ka+Kc parity (odd or even) zaxis = !! The inertial axis along which the molecular z-axis is fixed. Values !! must be either \"A\", \"B\", or \"C\" (case independent). It is up to the user to ensure that !! the x, y, z axes are properly aligned with the A, B, C axes in the K-matrix calculations !! (if used) and the for the dipole moment vector. The following are the three possible cases: !!   ZAXIS | X   Y   Z !!   ------|---------- !!   \"A\"   | B   C   A !!   \"B\"   | C   A   B !!   \"C\"   | A   B   C ABC = !! The A, B, and C rotationa constants (cm⁻¹) of the target molecule, such that !! A = ABC(1) !! B = ABC(2) !! C = ABC(3) xs_zero_threshold = !! Cross sections (cm²) that are below this threshold (for both excitation AND de-excitation) will !! be excluded from the list of transitions in each method (KMAT or CB). This is essentially a !! filter to reduce the number of files that are generated from K-matrix cross sections that have !! negligible magnitude. DEFAULT: 0.0, i.e. get the first matrix that we see ! -- 4th order centrifugal distortion add_cd4 = !! Whether to add 4th order centrifugal distortion. DEFAULT: .false. add_cd6 = !! Whether to add 6th order centrifugal distortion. DEFAULT: .false. ! -- 4th order centrifugal distortion constants (all DEFAULT 0.0) DN     = !! ΔN (ΔJ) DNK    = !! ΔNK (ΔJK) DK     = !! ΔK deltan = !! δN (δJ) deltak = !! δK ! -- 6th order centrifugal distortion constnats (all DEFAULT 0.0) HN    = !! HN (HJ) HNK   = !! HNK (HJK) HKN   = !! HKN (HKJ) HK    = !! HK etan  = !! ηN (ηJ) etank = !! ηNK (ηJK) etak  = !! ηK / &coulomb_namelist Next is &coulomb_namelist , which controls the execution of the code with respect to the CB approximation. This can be run with only the data that is included in the namelist group, but can also use data from the CDMS to get Einstein A coefficients, which are used to determine transition dipole moments between rotational state, but can also use data from the CDMS to get Einstein A coefficients, which are used to determine transition dipole moments between rotational states. ! ============================================================================================= &coulomb_namelist ! ============================================================================================= use_CDMS_einstA = !! Whether to use CDMS data to get Einstein A coefficients, which will be used !! in determining cross sections in the Coulomb-Born approximation (if that transition !! is available) CDMS_file = !! The file to use for reading the CDMS data if USE_CDMS_EINSTA is true. only_einsta = !! Whether to ONLY calculate Einstein A coefficients and ignore cross section calculations !! For the Coulomb-Born approximation. [DEFAULT .false.] do_dipole = !! Whether to use the Coulomb-Born approximation for the DIPOLE term of the !! interaction potential expansion over the multipoles [DEFAULT .true.] do_quadrupole = !! Whether to use the Coulomb-Born approximation for the QUADRUPOLE term of the !! interaction potential expansion over the multipoles [DEFAULT .false.] cartesian_dipole_moments = !! Array of dipole moments (Debye) in the order μx, μy, μz such that !!   μx = cartesian_dipole_moments(1) !!   μy = cartesian_dipole_moments(2) !!   μz = cartesian_dipole_moments(3) Ei = !! The smallest energy (eV) above the upper state threshold !! at which to start performing scattering calculations. This should not be 0 !! and should not be too close to 0 because the hypergeometric functions are not !! well-behaved there. Ef = !! The largest energy (eV) above the lower state threshold t oconsider for performing !! cross section calculations. This is the endpoint of the electron energy grid for CB calculations nE = !! The number of energies for which to calculate cross sections in the CB approx do_xtrap = !! Whether to extrapolate the CB (de-)excitation cross sections to the excitation threshold !! assuming a 1/E dependence (this way, we don't need to calculate ₂F₁(a,b;c;z) with huge !! a,b,c) Ei_xtrap = !! The smallest energy above the excitation (upper state) threshold to which we extrapolate !! CB cross sections. This should not be 0.0. (units: eV) nE_xtrap = !! The number of extrapolation energies down to the excitation threshold. The total number !! of CB cross sections per transition will be approximately nE + nE_xtrap. analytic_total_cb = !! Whether to use the analytic formula to determine the Total CB cross sections. !!   .true.:  use the analytic formula !!   .false.: take the sum from l=0 to lmax_total and consider that as the \"Total\" converged !!     result lmax_partial = !! The partial waves to consider for the Partial CB cross sections. lmax_total = !! The partial waves to consider for the Total CB cross section if analytic_total_cb is .false. !! For a particular multipole expansion (quadrupole is not used, so this only needs to be specified !! if analytic_total_cb(1) is .false.) / &kmat_namelist Next is the &kmat_namelist group. It controls behavior of the code with respect to the MQDT implementation (K-matrices from scattering calculations -> rotational frame transformation -> closed-channel elimination -> cross sections). This requires the output of electron-scattering calculations, which is detailed below. ! ============================================================================================= &kmat_namelist ! ============================================================================================= kmat_dir = !! The directory containing the K-matrices that the code will read channels_dir = !! The directory containing the channel files that the code will read (unused if !! KMAT_OUTPUT_TYPE is \"mqdtr2k\") lmax_kmat = !! The max value of the partial wave orbital angular momentum quantum number l in the K-matrix files point_group = !! The Abelian point group for the K-matrix files: !!   untested: C1, C2, Ci, C2h, D2, D2h !!   tested:   C2v, Cs spinmults = !! Array of spin multiplicities 2S+1 to consider. K-matrix cross sections will be averaged !! over spin multiplicities if there are more than one kmat_output_type = !! The K-matrix format/type that we will read, for use by this code. Two possible values: !!   ukrmol+: the default output of the UKRmol+ codes !!   mqdtr2k: explained in the writeup real_spherical_harmonics = !! Whether the spherical harmonics basis used to generate the K-matrices are real-valued !!   .true.: real-valued Ylm (will be transformed to complex-valued Ylλ for frame transformation) !!   .false.: complex-valued Ylλ (nothing to do) num_egrid_segs = !! The number of segments in the total energy grid. Must be ≥ 1 num_egrid = !! Array of number of energies per grid segment (length: NUM_EGRID_SEGS) egrid_segs = !! Array of the bounds (non-degenerate) of the TOTAL energy grid segments !! (length: NUM_EGRID_SEGS + 1, units: eV) egrid_spacing = !! How each energy grid segment is spaced. 'lin' for linear, 'log' for logarithmic kmat_energy_closest = !! The target energy (eV) at which to evaluate the K-matrix. In both cases of KMAT_OUTPUT_TYPE !! (which for this code should really be kmat_INPUT_type, but oh well), there may be !! several evaluation energies for the K-matrix, which means that one K-matrix exists per !! evaluation energy. The code tries to pick the first match that is closest to this energy kmat_energy_units_override = !! Force the code to interpret the K-matrix evaluation energy units as something other than !! the default for KMAT_OUTPUT_TYPE. Choices: !!   \"h\": hartree atomic units !!   \"e\": eV !!   \"r\": Rydberg channel_energy_units_override = !! Force the code to interpret the channel energy units as something other than !! the default for KMAT_OUTPUT_TYPE. Choices: !!   \"h\": hartree atomic units !!   \"e\": eV !!   \"r\": Rydberg / Structure of the K-matrix data If using K-matrices for the MQDT approach, there are two critical options to pick between: kmat_output_type: “ukrmol+” This format uses data taken directly from the output of the UKRmol+ scattering suite [1] , run with the UKRmol scripts [2] . It requires channel files and K-matrix files. The channel files are expected to live in the directory determined by channels_dir and have the naming format channels.geom1.<<SPINMULT>>.<<IRREP>> because the code currently only expects one geometry for the target molecule (no vibration). The K-matrices are expected to live in the directory specified by kmat_dir and have a similar naming format: K-matrix.geom1.<<SPINMULT>>.<<IRREP>> In both cases, <<SPINMULT>> is one of singlet , doublet .. and <<IRREP>> is one of the irreducible representations of the point group in which the calculations were performed. : Ap and App : A1 , A2 , B1 , and B2 ; … kmat_output_type: “mqdtr2k” This format is nonstandard and has very specific output with specific meaning. The K-matrix files contain the channel data, so only kmat_dir needs to be defined. It shall contain the K-matrix files with the naming pattern <<SPINMULT>><<IRREP>>.kmat where <<IRREP>> is the same as above but <<SPINMULT>> is the actual spin multiplicity and not the name, i.e. 1 ( not singlet ) 2 ( not doublet ) etc. The line-by line structure is given as follows (values separated by some whitespace, unformatted read ( * ) can be used): header (no information to read) nchan ichan ielec l m Echan iq [nchan of these lines] Ekmat K(1,1) K(2,1) K(2,2) ... K(nchan,nchan) [one line for each Ekmat ] where Variable Definition nchan number of electronic channels in this spin multiplicity and irrep ichan channel index ielec electronic state index for that channel l orbital angular momentum quantum number for that channel m projection of l on the molecular z-axis Echan channel energy (units given by default values or user choice; see kmat_namelist above) iq The normalization scheme of the Coulomb and functions: iq=4, the typical energy-normalized Coulomb functions iq=0, the , functions [3] References [1] Z. Mašín, J. Benda, J. D. Gorfinkiel, A. G. Harvey, and J. Tennyson, “UKRmol+: A suite for modelling electronic processes in molecules interacting with electrons, positrons and photons using the R-matrix method,” Computer Physics Communications , vol. 249, p. 107092, Apr. 2020, doi: 10.1016/j.cpc.2019.107092 . [2] K. Houfek et al. , “UKRmol-scripts: A Perl-based system for the automated operation of the photoionization and electron/positron scattering suite UKRmol+,” Computer Physics Communications , vol. 298, p. 109113, May 2024, doi: 10.1016/j.cpc.2024.109113 . [3] D. Hvizdoš, J. Forer, V. Kokoouline, and C. H. Greene, “Bound and autoionizing potential energy curves in the CH molecule,” \\jcp , vol. 159, no. 22, p. 224111, Dec. 2023, doi: 10.1063/5.0177822 .","tags":"home","url":"index.html"},{"title":"eigenH_type – ROTEX ","text":"type, public :: eigenH_type Contains the eigenvectors and eigenvalues of a hamiltonian Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: eigvals (:) real(kind=dp), public, allocatable :: eigvecs (:,:)","tags":"","url":"type/eigenh_type.html"},{"title":"N_states_type – ROTEX ","text":"type, public :: N_states_type The rotational state of the system described by its eigenvectors, eigenvalues,\nand state labels Components Type Visibility Attributes Name Initial integer, public :: N type( eigenH_type ), public :: eigenH The decomposed Hamiltonian for this rotational level integer, public, allocatable :: Ka (:) The projections Ka integer, public, allocatable :: Kc (:) The projections Kc real(kind=dp), public, allocatable :: EinstA (:) The Einstein coefficients for transitions to all lower states (0 if none)","tags":"","url":"type/n_states_type.html"},{"title":"channel_type – ROTEX ","text":"type, public, abstract :: channel_type |nelec> (E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy","tags":"","url":"type/channel_type.html"},{"title":"elec_channel_type – ROTEX ","text":"type, public, extends( channel_type ) :: elec_channel_type Describes the electronic channel basis of the (optional) K and S-matrices by adding l and its projection ml\n|nelec,l,ml> (iq, E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy integer, public :: l Partial wave degree integer, public :: ml Partial wave order (projection on body-frame ẑ-axis) integer, public :: iq = IQ_DEFAULT The kind of normalization for the Coulomb f/g functions:\n  4: usual normalization\n  0: f₀/g₀ normalization","tags":"","url":"type/elec_channel_type.html"},{"title":"asymtop_rot_channel_type – ROTEX ","text":"type, public, extends( channel_type ) :: asymtop_rot_channel_type Describes the rotational and electronic channel basis of the (optional) S-matrix\nafter the rotational frame transformation by adding the and rotational quantum numbers to the channel type\n|nelec,N,Ka,Kc> (E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy integer, public :: N The rotatinal quantum number of the target integer, public :: Ka The projection Ka of N integer, public :: Kc The projection Kc of N integer, public :: sym The nuclear spin symmetry","tags":"","url":"type/asymtop_rot_channel_type.html"},{"title":"asymtop_rot_channel_l_type – ROTEX ","text":"type, public, extends( asymtop_rot_channel_type ) :: asymtop_rot_channel_l_type Describes the rotational and electronic channel basis of the (optional) S-matrix\nafter the rotational frame transformation by adding the partial wave degree\nto the rotational quantum numbers\n|nelec,l,N,Ka,Kc> (iq, E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy integer, public :: N The rotatinal quantum number of the target integer, public :: Ka The projection Ka of N integer, public :: Kc The projection Kc of N integer, public :: sym The nuclear spin symmetry integer, public :: l Partial wave degree integer, public :: iq The kind of normalization for the Coulomb f/g functions:\n  4: usual normalization\n  0: f₀/g₀ normalization","tags":"","url":"type/asymtop_rot_channel_l_type.html"},{"title":"asymtop_rot_channel_l_vector_type – ROTEX ","text":"type, public :: asymtop_rot_channel_l_vector_type Contains a vector of channels. The idea is that this type is indexed at\neach value of the angular momentum quantum number J, for which a different\ncombination of channels exists than for other Js Components Type Visibility Attributes Name Initial type( asymtop_rot_channel_l_type ), public, allocatable :: channels (:)","tags":"","url":"type/asymtop_rot_channel_l_vector_type.html"},{"title":"asymtop_rot_transition_type – ROTEX ","text":"type, public :: asymtop_rot_transition_type The a type containing the indices for a pair of initial and final rotational states Components Type Visibility Attributes Name Initial type( asymtop_rot_channel_type ), public :: lo type( asymtop_rot_channel_type ), public :: up","tags":"","url":"type/asymtop_rot_transition_type.html"},{"title":"ivector_type – ROTEX ","text":"type, public :: ivector_type The type of an integer vector Components Type Visibility Attributes Name Initial integer, public, allocatable :: vec (:)","tags":"","url":"type/ivector_type.html"},{"title":"rvector_type – ROTEX ","text":"type, public :: rvector_type The type of a real vector Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: vec (:)","tags":"","url":"type/rvector_type.html"},{"title":"rmatrix_type – ROTEX ","text":"type, public :: rmatrix_type The type of a real matrix Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: mtrx (:,:)","tags":"","url":"type/rmatrix_type.html"},{"title":"cmatrix_type – ROTEX ","text":"type, public :: cmatrix_type The type of a complex matrix Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: mtrx (:,:)","tags":"","url":"type/cmatrix_type.html"},{"title":"cd4_type – ROTEX ","text":"type, public :: cd4_type Centrifugal Distortion parameters for quartric (4) order Components Type Visibility Attributes Name Initial real(kind=dp), public :: dn ΔN  (AKA ΔJ) real(kind=dp), public :: dnk ΔNK (AKA ΔJK) real(kind=dp), public :: dk ΔK real(kind=dp), public :: deltan δn  (AKA δJ) real(kind=dp), public :: deltak δK","tags":"","url":"type/cd4_type.html"},{"title":"cd6_type – ROTEX ","text":"type, public :: cd6_type Centrifugal Distortion parameters for sextic (6) order Components Type Visibility Attributes Name Initial real(kind=dp), public :: hn HN   (N²)³ real(kind=dp), public :: hnk HNK [(N²)² Nz²] real(kind=dp), public :: hkn HKN [ N²   Nz⁴] real(kind=dp), public :: hk HK         Nz⁶ real(kind=dp), public :: etan ηN  [N⁴,    (J₊)²+(J₋)²]₊ / 2 real(kind=dp), public :: etank ηNK [N²Nz², (J₊)²+(J₋)²]₊ / 2 real(kind=dp), public :: etak ηK  [Nz⁴,   (J₊)²+(J₋)²]₊ / 2","tags":"","url":"type/cd6_type.html"},{"title":"config_type – ROTEX ","text":"type, public :: config_type Derived type containing data from the namelist variables Components Type Visibility Attributes Name Initial logical, public :: add_cd4 = .true. Add centrifugal distortion for fourth order ? logical, public :: add_cd6 = .true. Add centrifugal distortion for sixth order ? logical, public :: only_einsta Whether to only calculate the Einstein A coefficients in the Coulomb-Born\ncross section routine logical, public :: use_CDMS_einstA Whether to use Einstein A coefficients obtained from the CDMS or calculate them ourselves\nPath for the file containing the CDMS data to be read (if use_CDMS_einstA is .true.) logical, public :: analytic_total_cb (2) Array of logicals that has the size 2. Choose whether to use the analytic equation\ndescribing the multipole expansions for the dipole (element 1) and the quadrupole (element 2, not yet available) logical, public :: do_xtrap Do the extrapolation of (de-)excitation cross sections as 1/E to the excitation threshold ? logical, public :: do_dipole Choose whether to use the dipole term of the potential expansion logical, public :: do_quadrupole Choose whether to use the quadrupole term of the potential expansion logical, public :: use_kmat Calculate (de-)excitation cross sections using precomputed K-matrices ? logical, public :: use_cb Calculate (de-)excitation cross sections using the Coulomb-Born approxiation ? logical, public :: real_spherical_harmonics Whether the input K-matrices are evaluated in a basis of real spherical harmonics\nfor the scattering electron. If .true., it will be transformed to a basis of\ncomplex-valued spherical harmonics integer, public :: spin_isomer_kind Whether and how to enforce ortho/para symmetry for molecules with identical nuclei.\n  0: don't\n  2: C2v rotor (H₂X-like): preserve Ka+Kc parity\nNote that this just disables certain transitions from bein calculated\nin the CB approx as well as from the S-matrix. This does not affect\nthe RFT because higher J-blocks of the S-matrix are more affected\nby K-mixing (Ka and Kc are not exact quantum numbers) integer, public :: nE The number of scattering energies to consider. This does not need to be very high; the CB\ncross sections are very smooth and can easily be interpolated. integer, public :: nE_xtrap Number of extrapolation energies. Excitation cross sections are extrapolated as 1/E to the excitation threshold,\nde-excitation cross sections are extrapolated as 1/E to Ei_xtrap. If this is 0, no exptrapolation will be performed. integer, public :: lmax_partial The maximum value of l to consider in the contribution of the partial CB cross section\nfrom the dipole and the quadrupole. If you're replacing the low-l CB cross sections\nwith other cross sections, set this to the max l that you have available. integer, public :: lmax_total The maximum value of l to consider in the contribution of the total CB cross section\nin the even that you're not using the analytic expression,\nfrom the dipole  and the quadrupole integer, public :: Nmin The minimum value of the rotational quantum number (N) to consider integer, public :: Nmax The maximum value of the rotational quantum number (N) to consider integer, public :: target_charge The electric charge of the target integer, public :: lmax_kmat The max partial wave to be included in the K-matrix basis. Cannot exceed the available\nbasis in the calculation, but can be smaller than the largest available partial wave integer, public :: num_egrid_segs Number of energy grid segments (evaluation energy for the cross sections) integer, public, allocatable :: num_egrid (:) Array of number of energies per grid segment (length num_egrid_segs) integer, public, allocatable :: spinmults (:) Array of spin multiplicities (2S+1) for which the system's (target + e⁻) K-matrices were calculated real(kind=dp), public :: xs_zero_threshold Any cross section with value only smaller than this (cm²) will\nbe ignore and will not be printed real(kind=dp), public :: Ei The first electron energy for excitation to consider relative to the initial state's energy real(kind=dp), public :: Ef The last  electron energy for excitation to consider relative to the initial state's energy real(kind=dp), public :: Ei_xtrap The lowest electron energy for de-excitation relative to the initial state's energy.\nThe results will be extrapolated from Ei down to this assuming a 1/E dependence for the\ncross section, i.e., constant excitation probablility. If this .le. 0, no extrapolation will not be performed.\nUnits: (eV) real(kind=dp), public :: kmat_energy_closest Input K-matrices are evaluated at a specific energy. If this code is run energy-independently\n(most likely the case unless I add energy dependence in the future) The K-matrix that is\nselected will be the FIRST ONE whose evaluation energy is CLOSEST to this energy in (eV).\nNOTE: UKRMOL+ outputs K-matrix energies in the .kmat files in Rydberg. real(kind=dp), public :: abc (3) Array of reals of length 3\nThe rotational constants A, B, and C of the target molecule (cm⁻¹). real(kind=dp), public :: cartesian_dipole_moments (3) Array of cartesian dipole moments (Debye)\nin the order dx, dy, dz real(kind=dp), public :: cartesian_quadrupole_moments (6) Array of cartesian quadrupole moments (Debye)\nin the order Qxx, Qxy, Qxz, Qyy, Qyz, Qzz real(kind=dp), public, allocatable :: egrid_segs (:) Array of the bounds (non-degenerate) of the energy grid segments (length num_egrid_segs + 1) character(len=1), public :: rotor_kind The kind of rotor that describes the targer. Character(1).\nChoice of :\n \"l\"inear\n \"a\"symmetric top\n \"s\"ymmetric  top character(len=1), public :: zaxis The molecular axis (a, b, or c) along which the z-axis is oriented This should also be the symmetry axis character(len=1), public :: channel_energy_units_override The units of the channel energies in the file that holds channels. Options are :\n - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV\nBy default, this is not set and will allow the code to determine\nchannel energies on its own based on KMAT_OUTPUT_TYPE, but can\nbe forcibly overridden with this character(len=1), public :: kmat_energy_units_override The units of the K-matrix evaluation energies in the kmat file. Options are :\n - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV\nBy default, this is not set and will allow the code to determine\nchannel energies on its own based on KMAT_OUTPUT_TYPE, but can\nbe forcibly overridden with this character(len=3), public :: egrid_spacing The kind of spacing for the energy grid segments. \"lin\" for linear and \"log\" for logarithmic character(len=:), public, allocatable :: point_group The point group in which the K-matrices were calculated character(len=:), public, allocatable :: kmat_dir Path for the file containing the K-matrix to be read. Absolute or relative character(len=:), public, allocatable :: channels_dir Path for the file containing the channels for the K-matrix to be read. Absolute or relative\nThis is only used if kmat_output_type is ukrmol+ because the channel and K-matrix files are separate character(len=:), public, allocatable :: output_directory The directory in which to write the output data\nThis directory must already exist character(len=:), public, allocatable :: CDMS_file The file containing CDMS transitions character(len=7), public :: kmat_output_type Determines what kind of K-matrices we're reading. Two possible values:\n  'UKRMOL+': default UKRmol+ .kmat file\n  'MQDTR2K': a specific format given in the writeup. K-matrices are generated\n    directly from the R-matrix, possibly with channel elimination and differently\n    normalized Coulomb wavefunctions type( cd4_type ), public :: cd4 Centrifugal distortion parameters (4th order) for the rigid rotor Hamiltonian correction type( cd6_type ), public :: cd6 Centrifugal distortion parameters (6th order) for the rigid rotor Hamiltonian correction","tags":"","url":"type/config_type.html"},{"title":"f21_dispatch – ROTEX","text":"public impure elemental function f21_dispatch(za, zb, zc, z, ts_tol) result(res) Uses rotex__constants rotex__system rotex__utils Checks if x is indeed in (0,1/2), and then makes a choice of evaluating the ODE (large a,b,c)\nor defaulting to the usual Taylor series Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: za complex(kind=dp), intent(in) :: zb complex(kind=dp), intent(in) :: zc complex(kind=dp), intent(in) :: z real(kind=dp), intent(in), optional :: ts_tol Return Value complex(kind=dp)","tags":"","url":"proc/f21_dispatch.html"},{"title":"f21_ts – ROTEX","text":"public pure elemental function f21_ts(a, b, c, z, tol) result(res) Uses rotex__system rotex__constants rotex__utils Returns the Gauss hypergeometric function ₂F₁(a,b,;c;z) via a Taylor series method, with quad precision Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b complex(kind=dp), intent(in) :: c complex(kind=dp), intent(in) :: z real(kind=dp), intent(in), optional :: tol The tolerance for which must be met for the series to be considered converged. If this is not supplied, this value will be taken\nto be machine epsilon macheps_dp from the hypergeometric__constants module. Return Value complex(kind=dp)","tags":"","url":"proc/f21_ts.html"},{"title":"f21 – ROTEX","text":"public impure elemental module function f21(a, b, c, x) result(res) Uses rotex__system rotex__functions rotex__utils rotex__polygamma Returns one of the following transforms\n  1. ₂F₁(a,b;c;x) = (1-x)&#94;{-b} ₂F₁(b,c-a;c;x/(x-1))\n  2. ₂F₁(a,b;c;x) = (1-x)&#94;{-a} ₂F₁(a,c-b;c;x/(x-1))\n  3. ₂F₁(a,b;c;x) = (1-x)&#94;{-a} Γ(c)Γ(b-a)/(Γ(b)Γ(c-a)) ₂F₁(a,c-b;a-b+1;1/(1-x))\n                  + (1-x)&#94;{-b} Γ(c)Γ(a-b)/(Γ(a)Γ(c-b)) ₂F₁(b,c-a;b-a+1;1/(1-x))\n  4. ₂F₁(a,b;c;x) =               Γ(c)Γ(c-a-b)/Γ(c-a)Γ(c-b) ₂F₁(c-a, c-b, c-a-b+1, 1-x)\n                  + (1-x)&#94;(c-a-b) Γ(c)Γ(a+b-c)/Γ(a)Γ(b)     ₂F₁(c-a,c-b;c-a-b+1;1-x)\nRegions of validity:\n  1. |a| < |b|, -1 ≤ x < 0\n  2. |a| > |b|, -1 ≤ x < 0\n  3. -∞ < x < -1\n  4. ½ < x < 1 Assumes that x is on the real axis Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b complex(kind=dp), intent(in) :: c real(kind=dp), intent(in) :: x Return Value complex(kind=dp)","tags":"","url":"proc/f21.html"},{"title":"do_coulomb_born_approx – ROTEX","text":"public module subroutine do_coulomb_born_approx(cfg, n_states, egrid_elec_cb, transitions_cb, xs_xcite_pcb, xs_xcite_tcb, pcb_output_directory, tcb_output_directory) Uses rotex__writing rotex__characters rotex__CBXS CDMSreader__types rotex__functions rotex__kinds rotex__symmetry rotex__types rotex__arrays rotex__system Use the Coulomb-Born approximation to get scattering cross sections for e⁻ + target.\nAlso determines Einstein A coefficients and excited state average lifetimes within\n!! the radiative dipole/multipole approximation. The target charge Z is supplied and\nused by the routine that are called here, so various target charges can be used, including Z = 0 (neutral targets).\nThis routine loops over the different pairs  Nτ —→ N'τ' Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg type( N_states_type ), intent(inout), allocatable :: n_states (:) type( rvector_type ), intent(out), allocatable :: egrid_elec_cb (:) Array of arrays of electron/collision energies for each transition type( asymtop_rot_transition_type ), intent(out), allocatable :: transitions_cb (:) Array containing transitions between rotational states for the long-range CB excitations type( rvector_type ), intent(out), allocatable :: xs_xcite_pcb (:) Array of arrays of the Partial and Total Coulomb-Born cross sections for each transition type( rvector_type ), intent(out), allocatable :: xs_xcite_tcb (:) Array of arrays of the Partial and Total Coulomb-Born cross sections for each transition character(len=*), intent(in) :: pcb_output_directory character(len=*), intent(in) :: tcb_output_directory","tags":"","url":"proc/do_coulomb_born_approx.html"},{"title":"do_kmat_xs – ROTEX","text":"public module subroutine do_kmat_xs(cfg, n_states, egrid_tot_smat, smat_output_directory, transitions, xs_xcite_spinavg, xs_dxcite_spinavg) Uses rotex__RFT rotex__characters rotex__constants rotex__writing rotex__MQDTXS rotex__reading rotex__types rotex__arrays rotex__system Read K-matrices from an electron-molecule scattering calculation, get S-matrices, add the rotation via\nthe rotational frame transformation for asymmetric tops, then use the MQDT channel elimination to\nget electron-impact excitation cross sections entirely from the K-matrix scattering data. Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg type( N_states_type ), intent(in) :: n_states (:) real(kind=dp), intent(in) :: egrid_tot_smat (:) Total energy grid for the S-matrix cross sections character(len=*), intent(in) :: smat_output_directory type( asymtop_rot_transition_type ), intent(out), allocatable :: transitions (:) type( rvector_type ), intent(out), allocatable :: xs_xcite_spinavg (:) Array of arrays of excitation cross sections for all spin multiplicities type( rvector_type ), intent(out), allocatable :: xs_dxcite_spinavg (:) Array of arrays of de-excitation cross sections for all spin multiplicities","tags":"","url":"proc/do_kmat_xs.html"},{"title":"convert_multipoles – ROTEX","text":"public module subroutine convert_multipoles(cartesian_moments_array, spherical_moments_array) Uses rotex__system rotex__constants rotex__types Convert the supplied array of multipole moments from cartesian, obtained as typical output from\nquantum chemistry codes, to spherical multipole moments Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: cartesian_moments_array (:) Array containing cartesian multipole moments. complex(kind=dp), intent(out) :: spherical_moments_array (:) Array containing spherical multipole moments.","tags":"","url":"proc/convert_multipoles.html"},{"title":"make_grid – ROTEX","text":"public module subroutine make_grid(grid, E0, num_segments, grid_segments, nelemnts_per_seg, spacing) Uses rotex__arrays rotex__system Make a segmented grid starting at E0\nExample with\n  num_segments = 3, grid_segments = [1e-3, 1e-2, 1e-1, 1], nelemnts_per_seg = [1000,1000, 100]\nE0+1e-3           E0+1e-2              E0+1e-1           E0+1.0\n  !------------------!-------------------!- - - - - - - - -!\n     1000 energies     1000 energies      100 energies Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: grid (:) The energy grid real(kind=dp), intent(in) :: E0 The lowest energy integer, intent(in) :: num_segments The number of segments in the energy grid real(kind=dp), intent(in) :: grid_segments (:) The boundaries of the grid segments integer, intent(in) :: nelemnts_per_seg (:) The number of elements in each grid segment character(len=3), intent(in) :: spacing The spacing type in each segment. \"LIN\" for linear or \"LOG\" for logarithmic","tags":"","url":"proc/make_grid.html"},{"title":"make_output_directories – ROTEX","text":"public module subroutine make_output_directories(output_directory, use_cb, spinmults, use_kmat, pcb_output_directory, tcb_output_directory, smat_output_directory) Uses rotex__constants rotex__system Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory logical, intent(in) :: use_cb integer, intent(in) :: spinmults (:) logical, intent(in) :: use_kmat character(len=:), intent(inout), allocatable :: pcb_output_directory character(len=:), intent(inout), allocatable :: tcb_output_directory character(len=:), intent(inout), allocatable :: smat_output_directory","tags":"","url":"proc/make_output_directories.html"},{"title":"get_CDMS_data – ROTEX","text":"public module subroutine get_CDMS_data(filename, output_directory, CDMS_states, CDMS_transitions) Uses CDMSreader__types CDMSreader__readwrite Read a file from the CDMS search to get Einstein A coefficients that will be used in determining\nCoulomb-Born cross sections. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: output_directory type(asymtop_state_type), intent(out), allocatable :: CDMS_states (:) type(asymtop_transition_type), intent(out), allocatable :: CDMS_transitions (:)","tags":"","url":"proc/get_cdms_data.html"},{"title":"get_cdms_state_energies – ROTEX","text":"public module subroutine get_cdms_state_energies(n_states, cdms_states) Uses rotex__constants cdmsreader__types rotex__types Update the energy of our rotational states with those from the CDMS Arguments Type Intent Optional Attributes Name type( N_states_type ), intent(inout) :: n_states (:) class(asymtop_state_type), intent(in) :: cdms_states (:)","tags":"","url":"proc/get_cdms_state_energies.html"},{"title":"get_CDMS_einstA – ROTEX","text":"public module subroutine get_CDMS_einstA(Nlo, Kalo, Kclo, Nup, Kaup, Kcup, CDMS_transitions, EinstA) Uses rotex__constants CDMSreader__types rotex__system Given the quantum numbers of a rotational transition, find the matching CDMS transition\nand get the corresponding Einstein A coefficient Arguments Type Intent Optional Attributes Name integer, intent(in) :: Nlo integer, intent(in) :: Kalo integer, intent(in) :: Kclo integer, intent(in) :: Nup integer, intent(in) :: Kaup integer, intent(in) :: Kcup class(asymtop_transition_type), intent(in) :: CDMS_transitions (:) real(kind=dp), intent(out) :: EinstA","tags":"","url":"proc/get_cdms_einsta.html"},{"title":"diagonalize_rotational_hamiltonian – ROTEX","text":"public module subroutine diagonalize_rotational_hamiltonian(cfg, num_n, n_values, n_states) Uses rotex__system rotex__arrays rotex__hamilton rotex__types Build the rigid-rotor hamiltonian for each N and diagonalize it. Keep eigenenergies and\neigenvectors, stored in the eigenH type of n_states Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg integer, intent(in) :: num_n integer, intent(in) :: n_values (:) type( N_states_type ), intent(out) :: n_states (:)","tags":"","url":"proc/diagonalize_rotational_hamiltonian.html"},{"title":"combine_cb_smat_xs – ROTEX","text":"public module subroutine combine_cb_smat_xs(cfg, egrid_cb, egrid_tot_smat, transitions_cb, xs_xcite_pcb, xs_xcite_tcb, transitions_smat, xs_xcite_smat, xs_dxcite_smat) Uses rotex__writing rotex__splines rotex__types rotex__arrays rotex__system Combine Coulomb-Born and S-matrix cross sections to be on the same electron energy grid.\nIn general, a different number of transitions will exist for the Coulomb-Born cross sections\nand for the S-matrix cross sections. This routine matches the transitions, interpolates the\nCB cross sections to the total energy grid used by the S-matrix routines, and adds them\ntogether:\n  σ(tot) = σ(S-mat) + σ(TCB) - σ(PCB) Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg Program config variables type( rvector_type ), intent(in) :: egrid_cb (:) Array of arrays of electron energy grids for the CB cross sections for each transition real(kind=dp), intent(in) :: egrid_tot_smat (:) The total energy grid on which the S-matrix cross sections were evaluated type( asymtop_rot_transition_type ), intent(in) :: transitions_cb (:) Array of arrays of transition between two rotational states lo and up in the CB approx type( rvector_type ), intent(inout) :: xs_xcite_pcb (:) Array of arrays of partial CB cross sections for each transition (excitation only, de-excitation handled by detailed balance) type( rvector_type ), intent(inout) :: xs_xcite_tcb (:) Array of arrays of total CB cross sections for each transition (excitation only, de-excitation handled by detailed balance) type( asymtop_rot_transition_type ), intent(in) :: transitions_smat (:) Array of arrays of transition between two rotational states lo and up using the S-matrix type( rvector_type ), intent(inout) :: xs_xcite_smat (:) Array of arrays of S-matrix cross sections for each transition; excitation type( rvector_type ), intent(inout) :: xs_dxcite_smat (:) Array of arrays of S-matrix cross sections for each transition; de-excitation","tags":"","url":"proc/combine_cb_smat_xs.html"},{"title":"M – ROTEX","text":"public impure elemental function M(l, ki, kf, Z) result(res) Uses rotex__hypergeometric rotex__functions rotex__polygamma rotex__types rotex__constants Calculates the integral via the expression given in\n  \"Electromagnetic Excitation: Theory of Coulomb Excitation with Heavy Ions \" by Kurt Alder and Aage Winther, Chapter IX,\n   section 2, page 244, equation 14.\nfor λ = 1, where . There is an expression for λ = 2 in\n  \"Study of Nuclear Structure by Electromagnetic Excitation with Accelerated Ions\" by K. Alder, A. Bohr, T. Huus,\n  B. Mottelson, and A. Winther, but only the dipole is used (at least for now). Arguments Type Intent Optional Attributes Name integer, intent(in) :: l real(kind=dp), intent(in) :: ki real(kind=dp), intent(in) :: kf integer, intent(in) :: Z Return Value complex(kind=dp)","tags":"","url":"proc/m.html"},{"title":"get_einsta_only – ROTEX","text":"public module subroutine get_einsta_only(einsta, nlo, nup, elo, eup, eigveclo, eigvecup, use_CDMS, do_dipole, do_quadrupole, dipole_moments, quadrupole_moments) Uses rotex__system rotex__constants rotex__functions rotex__types Calculate only the Einstein A coefficeints for a transition Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: einsta The Einstein coefficient for the transition integer, intent(in) :: nlo the angular momentum quantum number integer, intent(in) :: nup the angular momentum quantum number real(kind=dp), intent(in) :: elo The energy (hartrees) of the initial state real(kind=dp), intent(in) :: eup The energy (hartrees) of the final state real(kind=dp), intent(in) :: eigveclo (:) Eigenvector of the initial state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N,\\tau}_K) real(kind=dp), intent(in) :: eigvecup (:) Eigenvector of the final state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N',\\tau'}_{K}) logical, intent(in) :: use_CDMS Whether to calculate the Einstein A coefficients ourselves (.true.) or to use values obtained\nfrom the CDMS catalogue (.false.) logical, intent(in) :: do_dipole logical, intent(in) :: do_quadrupole complex(kind=dp), intent(in), target :: dipole_moments (3) The spherical dipole moments complex(kind=dp), intent(in), target :: quadrupole_moments (5) The spherical quadrupole moments","tags":"","url":"proc/get_einsta_only.html"},{"title":"get_CB_xs_asym – ROTEX","text":"public module subroutine get_CB_xs_asym(energies, sigma, Z, N, Np, E, Ep, eigvec, eigvecp, einsta, use_CDMS, do_dipole, do_quadrupole, dipole_moments, quadrupole_moments, analytic_total_cb, lmax) Uses rotex__functions ieee_arithmetic rotex__types rotex__constants rotex__system Calculate the excitation and de-excitation cross sections (xs) for an asymmetric top up.\nThe sum over partial waves is either truncated to or determined analytically.\nThe summation over the angular momentum components, multipole terms, and partial waves are separable\nfor each value of λ as summation = (sum over angular momentum and multipole moments) (sum overpartial waves). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energies (:) Array of scattering energies to consider real(kind=dp), intent(out), allocatable :: sigma (:) Cross sections calculated on a grid of scattering energies for Returned with the same size as energies integer, intent(in) :: Z Target charge integer, intent(in) :: N the angular momentum quantum number integer, intent(in) :: Np the angular momentum quantum number real(kind=dp), intent(in) :: E The energy (hartrees) of the initial state real(kind=dp), intent(in) :: Ep The energy (hartrees) of the final state real(kind=dp), intent(in) :: eigvec (:) Eigenvector of the initial state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N,\\tau}_K) real(kind=dp), intent(in) :: eigvecp (:) Eigenvector of the final state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N',\\tau'}_{K}) real(kind=dp), intent(inout) :: einsta The Einstein coefficient for the transition logical, intent(in) :: use_CDMS Whether to calculate the Einstein A coefficients ourselves (.true.) or to use values obtained\nfrom the CDMS catalogue (.false.) logical, intent(in) :: do_dipole logical, intent(in) :: do_quadrupole complex(kind=dp), intent(in), target :: dipole_moments (3) The spherical dipole moments complex(kind=dp), intent(in), target :: quadrupole_moments (5) The spherical quadrupole moments logical, intent(in) :: analytic_total_cb (:) Array of values telling us whether we want to use the analytic expression for lmax -> infintiy integer, intent(in) :: lmax The max value of the orbital angular momentum quantum number l to consider","tags":"","url":"proc/get_cb_xs_asym.html"},{"title":"xtrapolate_cb_xs – ROTEX","text":"public pure module subroutine xtrapolate_cb_xs(Ei_xtrap, Ethresh, nE_xtrap, Eel, xs_pcb, xs_tcb) Uses rotex__system rotex__functions rotex__kinds Extrapolate an excitation/de-excitation cross section to its excitation threshold.\nRe-allocates Eel and xs to contain the extrapolated values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: Ei_xtrap Extrapolate down Ethresh + Ei_xtrap real(kind=dp), intent(in) :: Ethresh The excitation threshold integer, intent(in) :: nE_xtrap Number of extrapolation energies real(kind=dp), intent(inout), allocatable :: Eel (:) On input, the electron energy grid.\nOn output, the electron energy grid with extrapolated energies prepended real(kind=dp), intent(inout), allocatable :: xs_pcb (:) On input, the partial Coulomb-Born cross sections.\nOn output, the partial Coulomb-Born cross sections with extrapolated cross sections prepended real(kind=dp), intent(inout), allocatable :: xs_tcb (:) On input, the total Coulomb-Born cross sections.\nOn output, the total Coulomb-Born cross sections with extrapolated cross sections prepended","tags":"","url":"proc/xtrapolate_cb_xs.html"},{"title":"clebsch – ROTEX","text":"public pure elemental module function clebsch(j1, m1, j2, m2, j, m) result(res) Uses rotex__functions rotex__types Returns the Clebsch-Gordan coefficient by using its relation to the Wigner 3j symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 integer, intent(in) :: m1 integer, intent(in) :: j2 integer, intent(in) :: m2 integer, intent(in) :: j integer, intent(in) :: m Return Value real(kind=dp)","tags":"","url":"proc/clebsch.html"},{"title":"wigner3j – ROTEX","text":"public pure elemental module function wigner3j(dj1, dj2, dj3, dm1, dm2, dm3) result(res) Uses rotex__system rotex__constants rotex__functions rotex__types returns the Wigner 3j symbol via explicit calculation. These should probably be\nprecomputed, but this works for now. The WignerSymbol-f repo seems like a good implementation. The wigner repo by ogorton takes up way too much memory for the high partial waves because\nit tries to allocate (2N+1)&#94;6 doubles. NOTE: for the high partial wave, we know that\nwe'll only need values with m1 = m2 = m3 = 0, so take advantage of this ? Arguments Type Intent Optional Attributes Name integer, intent(in) :: dj1 twice the angular momenta j integer, intent(in) :: dj2 twice the angular momenta j integer, intent(in) :: dj3 twice the angular momenta j integer, intent(in) :: dm1 twice the angular momenta m integer, intent(in) :: dm2 twice the angular momenta m integer, intent(in) :: dm3 twice the angular momenta m Return Value real(kind=dp) the result","tags":"","url":"proc/wigner3j.html"},{"title":"write_lifetimes_to_file – ROTEX","text":"public module subroutine write_lifetimes_to_file(output_directory, N_min, N_max, N_states, zaxis) Uses rotex__constants rotex__types Writes the states involved in the excitation and their lifetimes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory The directory in which output files are placed integer, intent(in) :: N_min Minimum and maximum value of N for which lifetimes were evaluated integer, intent(in) :: N_max Minimum and maximum value of N for which lifetimes were evaluated type( N_states_type ), intent(in) :: N_states (:) character(len=1), intent(in) :: zaxis The array of states","tags":"","url":"proc/write_lifetimes_to_file.html"},{"title":"write_CB_xs_to_file – ROTEX","text":"public module subroutine write_CB_xs_to_file(prefix, output_directory, zaxis, E_el, xs, init, fin, lmax, xs_type) Uses rotex__characters rotex__constants rotex__functions rotex__types Writes a Coulomb-Born cross section to a file whos name and file header\ncarry information about the state symmetry Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix filename prefix character(len=*), intent(in) :: output_directory The directory in which output files are placed character(len=1), intent(in) :: zaxis The A, B, or C axis that lies along z real(kind=dp), intent(in) :: E_el (:) the scattering eneries in au real(kind=dp), intent(in) :: xs (:) The excitation cross sections type( asymtop_rot_channel_type ), intent(in) :: init Initial and final states for this transition type( asymtop_rot_channel_type ), intent(in) :: fin Initial and final states for this transition character(len=*), intent(in) :: lmax The max value of l for the CB cross sections (\"inf\" if total) character(len=*), intent(in), optional :: xs_type The kind of cross section that this is","tags":"","url":"proc/write_cb_xs_to_file.html"},{"title":"write_smat_xs_to_file – ROTEX","text":"public module subroutine write_smat_xs_to_file(prefix, output_directory, zaxis, egrid_total, transition, exxs, dexxs, lmax) Uses rotex__characters rotex__constants rotex__functions rotex__types rotex__arrays rotex__system Writes an S-matrix (+CB) cross section to a file whos name and file header\ncarry information about the state symmetry Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix filename prefix character(len=*), intent(in) :: output_directory The directory in which output files are placed character(len=1), intent(in) :: zaxis The A, B, or C axis that lies along z real(kind=dp), intent(in) :: egrid_total (:) The grid of total energies in au type( asymtop_rot_transition_type ), intent(in) :: transition The transition (excitation pair) to be consdered real(kind=dp), intent(in) :: exxs (:) Array of excitation cross sections for this/all spin multiplicities real(kind=dp), intent(in) :: dexxs (:) Array of de-excitation cross sections for all spin multiplicities integer, intent(in) :: lmax The max value of l for the K-matrices","tags":"","url":"proc/write_smat_xs_to_file.html"},{"title":"write_total_xs_to_file – ROTEX","text":"public module subroutine write_total_xs_to_file(prefix, output_directory, zaxis, egrid_total, transition, xs_xcite, xs_dxcite, lmax) Uses rotex__characters rotex__constants rotex__kinds rotex__types rotex__arrays rotex__system Write the total cross-sections (S-matrix + CB correction) to disk for a single transition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix filename prefix character(len=*), intent(in) :: output_directory The directory in which output files are placed character(len=1), intent(in) :: zaxis The A, B, or C axis that lies along z real(kind=dp), intent(in) :: egrid_total (:) The grid of total energies in au type( asymtop_rot_transition_type ), intent(in) :: transition The transition to write to file real(kind=dp), intent(in) :: xs_xcite (:) Array of arrays of excitation cross sections for all spin multiplicities real(kind=dp), intent(in) :: xs_dxcite (:) Array of arrays of de-excitation cross sections for all spin multiplicities integer, intent(in) :: lmax The max value of l for the K/S-matrices","tags":"","url":"proc/write_total_xs_to_file.html"},{"title":"write_channels_to_file – ROTEX","text":"public module subroutine write_channels_to_file(filename, jmin, jmax, n_states, channels_l, channels_l_j, spin_isomer_kind, symaxis) Uses rotex__constants rotex__types rotex__symmetry Write rotational channel info to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File to which we write channels integer, intent(in) :: jmin Total angular momentum mim/max integer, intent(in) :: jmax Total angular momentum mim/max type( N_states_type ), intent(in) :: n_states (:) type( asymtop_rot_channel_l_type ), intent(in) :: channels_l (:) Rotational channels type( asymtop_rot_channel_l_vector_type ), intent(in) :: channels_l_j (jmin:jmax) Rotational channels for each J integer, intent(in) :: spin_isomer_kind Kind of nuclear spin to preserve character(len=1), intent(in) :: symaxis Symmetry axis for nuclear spin","tags":"","url":"proc/write_channels_to_file.html"},{"title":"get_smat_probs – ROTEX","text":"public module subroutine get_smat_probs(total_energy_grid, prob, transitions, nmin, nmax, smat_j, jmin, jmax, channels_j, channels_tot, spin_isomer_kind, symaxis) Uses rotex__characters rotex__progress rotex__constants omp_lib rotex__symmetry rotex__types rotex__arrays rotex__system Given a rotationally resolved S-matrix, calculate rotational (de-)excitation\ncross section probabilities for the supplied transitions. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_energy_grid (:) The total energy grid on which the S-matrix will be evaluated type( rvector_type ), intent(out), allocatable :: prob (:) Probability at each pair of channels (n,N,Ka,Kc) ←→ (n',N',Ka',Kc') type( asymtop_rot_transition_type ), intent(inout), allocatable :: transitions (:) Array of transitions that will be considered for (de-)excitation integer, intent(in) :: nmin Min/max values of N to consider for excitation calculations integer, intent(in) :: nmax Min/max values of N to consider for excitation calculations type( cmatrix_type ), intent(in) :: smat_j (jmin:jmax) Array of S-matrix sub-blocks for each J integer, intent(in) :: jmin Min/max values of J to consider for the S-matrix subblocks integer, intent(in) :: jmax Min/max values of J to consider for the S-matrix subblocks type( asymtop_rot_channel_l_vector_type ), intent(in) :: channels_j (jmin:jmax) Contains the array of channels for each J type( asymtop_rot_channel_l_type ), intent(in) :: channels_tot (:) Contains the array of channels ∀ J integer, intent(in) :: spin_isomer_kind What kinda spin symmetry we need to respect character(len=1), intent(in) :: symaxis The symmetry axis of the target","tags":"","url":"proc/get_smat_probs.html"},{"title":"right_divide – ROTEX","text":"public  function right_divide(A, B) result(X) Uses rotex__characters rotex__system Returns X = AB⁻¹ without evaluating B⁻¹ Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) Return Value complex(kind=dp), (size(A,1),size(A,2))","tags":"","url":"proc/right_divide.html"},{"title":"zgesv – ROTEX","text":"interface public  subroutine zgesv(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=dp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) complex(kind=dp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info","tags":"","url":"interface/zgesv.html"},{"title":"dsyev – ROTEX","text":"interface public  subroutine dsyev(jobz, uplo, n, a, lda, w, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=dp), intent(inout) :: a (lda,n) integer, intent(in) :: lda real(kind=dp), intent(out) :: w (*) real(kind=dp), intent(out) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info","tags":"","url":"interface/dsyev.html"},{"title":"RFT_nonlinear – ROTEX","text":"public module subroutine RFT_nonlinear(Kmat, Jmin, Jmax, Smat_J, elec_channels, N_states, asymtop_rot_channels_l, asymtop_rot_channels_l_J, spin_isomer_kind, symaxis, real_spherical_harmonics, point_group) Uses rotex__constants rotex__symmetry rotex__types rotex__arrays rotex__system Build the electronic S-matrix from the electronic K-matrix, then perform the rotational frame transformation on the S-matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: Kmat (:,:) The K-matrix, needed as input for the RFT integer, intent(in) :: Jmin The lowest value of J = N + l integer, intent(in) :: Jmax The largest value of J = N + l type( cmatrix_type ), intent(out) :: Smat_J (Jmin:Jmax) The rotational S-matrices , produced by the RFT type( elec_channel_type ), intent(in) :: elec_channels (:) The array of electronic channels (n, l, ml), needed as input for the RFT type( N_states_type ), intent(in) :: N_states (:) The array of rotational states of the target (N, Ka, Kc), needed as input for the RFT type( asymtop_rot_channel_l_type ), intent(out), allocatable :: asymtop_rot_channels_l (:) The array of rotational channels (N, Ka, Kc, l) that make up the basis of the S-matrix type( asymtop_rot_channel_l_vector_type ), intent(out) :: asymtop_rot_channels_l_J (Jmin:Jmax) The array of arrays of rotational channels (N, Ka, Kc, l) that make up the basis of the S-matrix subblocks at each J integer, intent(in) :: spin_isomer_kind Spin isomer kind character(len=1), intent(in) :: symaxis Symmetry axis for respecting nuclear spin symmetry logical, intent(in) :: real_spherical_harmonics Whether the input K-matrices are evaluated in a basis of real spherical harmonics\nfor the scattering electron. If .true., transform the S-matrix into a basis of\ncomplex-valued spherical harmonics character(len=*), intent(in) :: point_group The point group of the calculation","tags":"","url":"proc/rft_nonlinear.html"},{"title":"delta – ROTEX","text":"public pure elemental module function delta(m, n) result(res) Uses rotex__constants Return the Kronecker delta function Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value real(kind=dp)","tags":"","url":"proc/delta.html"},{"title":"iseven – ROTEX","text":"public pure elemental module function iseven(n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value logical","tags":"","url":"proc/iseven.html"},{"title":"isodd – ROTEX","text":"public pure elemental module function isodd(n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value logical","tags":"","url":"proc/isodd.html"},{"title":"istriangle – ROTEX","text":"public pure elemental module function istriangle(a, b, c) result(res) returns whether the arguments satisfy the triangle inequality,\nassuming that they're positive quantities Arguments Type Intent Optional Attributes Name integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value logical","tags":"","url":"proc/istriangle.html"},{"title":"neg – ROTEX","text":"public pure elemental module function neg(i) result(res) Returns the integer } Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer","tags":"","url":"proc/neg.html"},{"title":"are_approx_eq – ROTEX","text":"public interface are_approx_eq Compare two a and b and see if the magnitude of their difference is smaller than a tolerance,\ntaking machine epsilon*max(|a|,|b|) for their precision as the default value Module Procedures private pure elemental module function are_approx_eqz(a, b, tol) result(res) Comparre two a and b and see if magnitude of their difference is smaller than a tolerance,\ntaking machine epsilon for their precision as the default value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: tol Return Value logical private pure elemental module function are_approx_eqr(a, b, tol) result(res) Comparre two a and b and see if magnitude of their difference is smaller than a tolerance,\ntaking machine epsilon for their precision as the default value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: tol Return Value logical","tags":"","url":"interface/are_approx_eq.html"},{"title":"factorial – ROTEX","text":"public interface factorial !n Module Procedures private pure elemental module function factorial_int(n) result(res) !n Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=dp) private pure elemental module function factorial_real(n) result(res) !n Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n Return Value real(kind=dp)","tags":"","url":"interface/factorial.html"},{"title":"log_factorial – ROTEX","text":"public interface log_factorial ln(!n) Module Procedures private pure elemental module function log_factorial_i(n) result(res) returns ln(n!) for integer n Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=dp) private pure elemental module function log_factorial_r(n) result(res) returns ln(n!) for real n Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n Return Value real(kind=dp)","tags":"","url":"interface/log_factorial.html"},{"title":"expm1 – ROTEX","text":"public interface expm1 Module Procedures private module function expm1r(x) result(res) Returns . TODO, replace with a fast and accurate version\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), value :: x Return Value real(kind=dp) private module function expm1z(z) result(res) Returns . TODO, replace with a fast and accurate version\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp)","tags":"","url":"interface/expm1.html"},{"title":"logp1 – ROTEX","text":"public interface logp1 Module Procedures private module function logp1r(x) result(res) Returns for real z. TODO, replace with a fast and accurate version\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function logp1z(z) result(res) Returns for complex z. TODO, replace with a fast and accurate version ?\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp)","tags":"","url":"interface/logp1.html"},{"title":"logb – ROTEX","text":"public interface logb Module Procedures private pure elemental function logb_ii(b, x) result(res) Returns the logarithm of x in the base b Arguments Type Intent Optional Attributes Name integer, intent(in) :: b integer, intent(in) :: x Return Value real(kind=dp) private pure elemental function logb_rr(b, x) result(res) Returns the logarithm of x in the base b Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: b real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental function logb_cc(b, x) result(res) Returns the logarithm of x in the base b Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: b complex(kind=dp), intent(in) :: x Return Value complex(kind=dp)","tags":"","url":"interface/logb.html"},{"title":"logrange – ROTEX","text":"public interface logrange Module Procedures private pure function logrange_ib(a, b, n, base, inclast) result(res) Returns an array of n log-spaced values from a to b. By default, the base is 10\nif omitted but can be changed by the user Arguments Type Intent Optional Attributes Name integer(kind=dp), intent(in) :: a integer(kind=dp), intent(in) :: b integer, intent(in) :: n integer, intent(in), optional :: base Logarithm base logical, intent(in), optional :: inclast Whether to include the last value b Return Value real(kind=dp), (n) private pure function logrange_rb(a, b, n, base, inclast) result(res) Returns an array of n log-spaced values from a to b. By default, the base is 10\nif omitted but can be changed by the user Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b integer, intent(in) :: n real(kind=dp), intent(in), optional :: base Logarithm base logical, intent(in), optional :: inclast Whether to include the last value b Return Value real(kind=dp), (n)","tags":"","url":"interface/logrange.html"},{"title":"isinteger – ROTEX","text":"public interface isinteger Check if a real/complex number is an integer Module Procedures private pure elemental module function isintegerr(x) result(res) Check if x is an integer Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value logical private pure elemental module function isintegerz(z) result(res) Check if z is an integer Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value logical","tags":"","url":"interface/isinteger.html"},{"title":"isnatural – ROTEX","text":"public interface isnatural Check if a real/complex number is a natrual number Module Procedures private pure elemental module function isnaturalr(x) result(res) Check if x is a natural number (1, 2, 3, ...) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value logical private pure elemental module function isnaturalz(z) result(res) Check if z is a natural number (1, 2, 3, ...) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value logical","tags":"","url":"interface/isnatural.html"},{"title":"arg – ROTEX","text":"public interface arg Return the phase of a complex number in (-π,π] Module Procedures private pure elemental module function argi(z) result(res) Return the phase of an integer (as a complex number) in (-π,π] Arguments Type Intent Optional Attributes Name integer, intent(in) :: z Return Value real(kind=dp) private pure elemental module function argr(z) result(res) Return the phase of a real number (as a complex number) in (-π,π] Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: z Return Value real(kind=dp) private pure elemental module function argc(z) result(res) Return the phase of a complex number in (-π,π] Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value real(kind=dp)","tags":"","url":"interface/arg.html"},{"title":"inv – ROTEX","text":"public interface inv Compute 1/z Module Procedures private pure elemental module function invi(i) result(res) Return the real 1/i for integer i Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value real(kind=dp) private pure elemental module function invr(x) result(res) Return 1/x Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function invz(z) result(res) Return 1/z for complex z. If the imaginary part of z is 0, flip its sign Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp)","tags":"","url":"interface/inv.html"},{"title":"ndigits – ROTEX","text":"public pure elemental function ndigits(n) result(num) Uses rotex__constants Returns number of characters an integer will occupy Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer","tags":"","url":"proc/ndigits.html"},{"title":"dJ2char – ROTEX","text":"public pure module function dJ2char(dJ) result(res) Takes an integer dJ and results the character representing half of it.\ndJ2char(2) -> \"1\"\ndJ2char(3) -> \"3/2\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: dJ Twice the angular momentum Return Value character(len=:), allocatable The output character representation","tags":"","url":"proc/dj2char.html"},{"title":"sub – ROTEX","text":"public pure function sub(x) result(res) Returns the subscript version of the integer x Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=:), allocatable","tags":"","url":"proc/sub.html"},{"title":"sup – ROTEX","text":"public pure function sup(x) result(res) Returns the superscript version of the integer x Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=:), allocatable","tags":"","url":"proc/sup.html"},{"title":"add_trailing – ROTEX","text":"public pure module subroutine add_trailing(chr, trail) Add a trailing character trail to the character chr if it is not already the\nlast character Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: chr character(len=*), intent(in) :: trail","tags":"","url":"proc/add_trailing.html"},{"title":"to_lower – ROTEX","text":"public pure elemental subroutine to_lower(chr) converts a character to lower case Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: chr","tags":"","url":"proc/to_lower.html"},{"title":"to_upper – ROTEX","text":"public pure elemental subroutine to_upper(chr) converts a character to upper case Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: chr","tags":"","url":"proc/to_upper.html"},{"title":"s2hms – ROTEX","text":"public interface s2hms convert seconds to hours, minutes, seconds Module Procedures private pure module function int_s2hms(s) result(time) Given an integer 's' in seconds, convert to the format hh:mm:ss. Arguments Type Intent Optional Attributes Name integer, intent(in) :: s Return Value character(len=:), allocatable private pure module function real_s2hms(s_re) result(time) Given an integer in seconds, convert to the format hh:mm:ss. Input is a real, gets converted to int Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: s_re Return Value character(len=:), allocatable","tags":"","url":"interface/s2hms.html"},{"title":"int2char – ROTEX","text":"public interface int2char Module Procedures private pure function scalar_int2char(i) result(res) Writes the value i to a character as I0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable private pure function vector_int2char(i) result(res) Writes the value i to a character as I0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) Return Value character(len=:), allocatable","tags":"","url":"interface/int2char.html"},{"title":"H_asym – ROTEX","text":"public module subroutine H_asym(N, eigenH, Bx, By, Bz, cd4, cd6) Uses rotex__characters rotex__constants rotex__utils rotex__linalg rotex__types rotex__arrays rotex__system Construct the symmetric top rigid-rotor Hamiltonian Arguments Type Intent Optional Attributes Name integer, intent(in) :: N The rotational quantum number type( eigenH_type ), intent(out) :: eigenH The eigenvectors and eigenvalues of The angular momentum number real(kind=dp), intent(in) :: Bx Rotational constants real(kind=dp), intent(in) :: By Rotational constants real(kind=dp), intent(in) :: Bz Rotational constants type( cd4_type ), intent(in), optional :: cd4 The quartic centrifugal distortion parameters type( cd6_type ), intent(in), optional :: cd6 The sextic centrifugal distortion parameters","tags":"","url":"proc/h_asym.html"},{"title":"assign_projections – ROTEX","text":"public module subroutine assign_projections(N, eigenH, absKvals, sort_eigvecs) Uses rotex__arrays Using the eigenvectors and energies from a diagonalized rotational Hamiltonian,\ndetermine which projection is maximal. The eigenvectors can be in the Ka or Kc basis.\nThis routine will return the array Kvals which indicats the absolute value of the projection that\ncontributes the most to a particular eigenvector Arguments Type Intent Optional Attributes Name integer, intent(in) :: N The rotational quantum number type( eigenH_type ), intent(in) :: eigenH Contains the eigenvalues and eigenvectors of the rotational Hamiltonian for the given value of N, digaonalized in\nthe Ka or the Kc symmetric top basis integer, intent(out), allocatable :: absKvals (:) Array of the absolte value of |K| that contributes the most to a particular eigenvector logical, intent(in), optional :: sort_eigvecs Sort the eigenvectors ?","tags":"","url":"proc/assign_projections.html"},{"title":"unitary_defect – ROTEX","text":"public pure function unitary_defect(A) result(rF) Uses rotex__system Return the unitary defect with respect to the Frobenius norm Arguments Type Intent Optional Attributes Name class(*), intent(in) :: A (:,:) Return Value real(kind=dp)","tags":"","url":"proc/unitary_defect.html"},{"title":"is_unitary – ROTEX","text":"public pure function is_unitary(A, rtol) result(res) Uses rotex__constants Determine whether a matrix is unitary w.r.t the Frobenius norm Arguments Type Intent Optional Attributes Name class(*), intent(in) :: A (:,:) The matrix real(kind=dp), intent(in), optional :: rtol The optional relative tolerance, default 1e-10 Return Value logical","tags":"","url":"proc/is_unitary.html"},{"title":"is_symmetric – ROTEX","text":"public pure function is_symmetric(A, rtol) result(res) Uses rotex__constants Determine whether a matrix is symmetric Arguments Type Intent Optional Attributes Name class(*), intent(in) :: A (:,:) The matrix real(kind=dp), intent(in), optional :: rtol The optional relative tolerance, default 1e-10 Return Value logical","tags":"","url":"proc/is_symmetric.html"},{"title":"eye – ROTEX","text":"public pure module function eye(n) result(res) Uses rotex__system Return an n x n identity matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer, (n,n)","tags":"","url":"proc/eye.html"},{"title":"uniq – ROTEX","text":"public pure module function uniq(arr) result(res) Returns the unique elements of arr Arguments Type Intent Optional Attributes Name integer, intent(in) :: arr (:) Return Value integer, allocatable, (:)","tags":"","url":"proc/uniq.html"},{"title":"remove_value – ROTEX","text":"public pure module subroutine remove_value(arr, val) Remove all instances of the value val from the array arr Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: val","tags":"","url":"proc/remove_value.html"},{"title":"sort_index – ROTEX","text":"public pure module subroutine sort_index(vals, idx) Sort the array vals and return the permutation indices Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vals (:) integer, intent(out) :: idx (:)","tags":"","url":"proc/sort_index.html"},{"title":"append_uniq – ROTEX","text":"public interface append_uniq Module Procedures private  subroutine append_uniq_i(arr, new) Append unique element \"new\" to array \"arr\" Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: new private pure module subroutine append_uniq_transition(old, new) Append unique element \"new\" to array \"old\" Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(inout), allocatable :: old (:) type( asymtop_rot_transition_type ), intent(in) :: new (:)","tags":"","url":"interface/append_uniq.html"},{"title":"append – ROTEX","text":"public interface append Module Procedures private pure module subroutine append_i(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: val private pure module subroutine append_r(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: arr (:) real(kind=dp), intent(in) :: val private pure module subroutine append_rvector(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name type( rvector_type ), intent(inout), allocatable :: arr (:) real(kind=dp), intent(in) :: val (:) private pure module subroutine append_asymtop_transition(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(inout), allocatable :: arr (:) type( asymtop_rot_transition_type ), intent(in) :: val private pure module subroutine append_elec_channel(channels, channel) Append elec_channel to the array elec_channels Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout), allocatable :: channels (:) type( elec_channel_type ), intent(in) :: channel private pure module subroutine append_elec_channels(channels, channels2) Append channels2 to the array channels Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout), allocatable :: channels (:) type( elec_channel_type ), intent(in) :: channels2 (:) private pure module subroutine append_asymtop_rot_channel(channels, channel) Append asymtop_rot_channel to the array asymtop_rot_channels Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_type ), intent(inout), allocatable :: channels (:) type( asymtop_rot_channel_type ), intent(in) :: channel private pure module subroutine append_asymtop_rot_channel_l(channels, channel) Append asymtop_rot_channel to the array asymtop_rot_channels Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_l_type ), intent(inout), allocatable :: channels (:) type( asymtop_rot_channel_l_type ), intent(in) :: channel","tags":"","url":"interface/append.html"},{"title":"adjoint – ROTEX","text":"public interface adjoint Module Procedures private pure module function adjoint_i(A) result(res) Returns the adjoint of an integer-valued matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer, (size(A,2),size(A,1)) private pure module function adjoint_r(A) result(res) Returns the adjoint of a real-valued matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp), (size(A,2),size(A,1)) private pure module function adjoint_c(A) result(res) Returns the adjoint of a complex-valued matrix Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp), (size(A,2),size(A,1))","tags":"","url":"interface/adjoint.html"},{"title":"size_check – ROTEX","text":"public interface size_check Module Procedures private pure module subroutine size_check_1d(arr, larr, name) Check that the size of the array arr is of length larr Arguments Type Intent Optional Attributes Name class(*), intent(in) :: arr (:) integer, intent(in) :: larr character(len=*), intent(in) :: name private pure module subroutine size_check_2d(arr, larr, name) Check that the size of the array arr is of length larr Arguments Type Intent Optional Attributes Name class(*), intent(in) :: arr (:,:) integer, intent(in) :: larr (:) character(len=*), intent(in) :: name","tags":"","url":"interface/size_check.html"},{"title":"norm_frob – ROTEX","text":"public interface norm_frob Module Procedures private pure module function norm_frob_i(A) result(res) Returns the Frobenius norm for a matrix A Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value real(kind=dp) private pure module function norm_frob_r(A) result(res) Returns the Frobenius norm for a matrix A Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private pure module function norm_frob_c(A) result(res) Returns the Frobenius norm for a matrix A Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)","tags":"","url":"interface/norm_frob.html"},{"title":"realloc – ROTEX","text":"public interface realloc Module Procedures private pure module subroutine realloc_1d_int(arr, n) Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_1d_real(arr, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_1d_cmplx(arr, n) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_1d_elec_channel(arr, n) Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_2d_real(arr, n, m) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: arr (:,:) integer, intent(in) :: n integer, intent(in) :: m private pure module subroutine realloc_2d_cmplx(arr, n, m) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), allocatable :: arr (:,:) integer, intent(in) :: n integer, intent(in) :: m","tags":"","url":"interface/realloc.html"},{"title":"OS_NAME – ROTEX","text":"public pure function OS_NAME(os) Arguments Type Intent Optional Attributes Name integer, intent(in) :: os Return Value character(len=:), allocatable","tags":"","url":"proc/os_name.html"},{"title":"error – ROTEX","text":"public  subroutine error(message) Print error messages to the screen without the WARNING prompt. This will typically precede a call to DIE Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message","tags":"","url":"proc/error.html"},{"title":"determine_system_properties – ROTEX","text":"public  subroutine determine_system_properties() Detects the type of the operating system. As far as system calls and directory structure go,\nthis basically resolved to Windows or not Windows. Arguments None","tags":"","url":"proc/determine_system_properties.html"},{"title":"mkdir – ROTEX","text":"public  subroutine mkdir(directory) Makes the directory \"directory\" and checks that it exists and is writeable Arguments Type Intent Optional Attributes Name character(len=*) :: directory","tags":"","url":"proc/mkdir.html"},{"title":"die – ROTEX","text":"public interface die Module Procedures private pure subroutine die_1(message) Stop program execution with a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message","tags":"","url":"interface/die.html"},{"title":"warn – ROTEX","text":"public interface warn Module Procedures private  subroutine warn_1(message) Print a warning message, but don't stop the program's execution Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message","tags":"","url":"interface/warn.html"},{"title":"isin – ROTEX","text":"public pure elemental module function isin(x, xl, xr, lclosed, rclosed) result(res) Test whether x is in the interval spanned by x1,x2\nl/rclosed if true include xl and xr, respectively. They are true by default Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr logical, intent(in), optional :: lclosed logical, intent(in), optional :: rclosed Return Value logical","tags":"","url":"proc/isin.html"},{"title":"assert – ROTEX","text":"public pure elemental subroutine assert(test, message) Uses rotex__system Arguments Type Intent Optional Attributes Name logical, intent(in) :: test character(len=*), intent(in) :: message","tags":"","url":"proc/assert.html"},{"title":"read_blank – ROTEX","text":"public  subroutine read_blank(read_unit, num_read) Reads num_read lines from unit read_unit, not storing any information. If num_read is not supplied, read one line. Arguments Type Intent Optional Attributes Name integer, intent(in) :: read_unit integer, intent(in), optional :: num_read","tags":"","url":"proc/read_blank.html"},{"title":"isint – ROTEX","text":"public interface isint Module Procedures private pure elemental module function isint_r(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value logical private pure elemental module function isint_c(z) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value logical","tags":"","url":"interface/isint.html"},{"title":"kbn_sum – ROTEX","text":"public interface kbn_sum Module Procedures private pure elemental subroutine kbn_sum_rqp(summation, c, input) Improved Kahan-Babuška algorithm accumulation for summations Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: summation real(kind=qp), intent(inout) :: c real(kind=qp), intent(in) :: input private pure elemental subroutine kbn_sum_cdp(summation, c, input) Improved Kahan-Babuška algorithm accumulation for summations Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: summation complex(kind=dp), intent(inout) :: c complex(kind=dp), intent(in) :: input private pure elemental subroutine kbn_sum_cqp(summation, c, input) Improved Kahan-Babuška algorithm accumulation for summations Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(inout) :: summation complex(kind=qp), intent(inout) :: c complex(kind=qp), intent(in) :: input","tags":"","url":"interface/kbn_sum.html"},{"title":"downcast – ROTEX","text":"public interface downcast Module Procedures private pure elemental module subroutine downcast_r(hi, lo) Send the value of hi to lo, respecting the kind of the types Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: hi real(kind=dp), intent(out) :: lo private pure elemental module subroutine downcast_c(hi, lo) Send the value of hi to lo, respecting the kind of the types Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: hi complex(kind=dp), intent(out) :: lo","tags":"","url":"interface/downcast.html"},{"title":"upcast – ROTEX","text":"public interface upcast Module Procedures private pure elemental module subroutine upcast_r(lo, hi) Send the value of lo to hi, respecting the kind of the types Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lo real(kind=qp), intent(out) :: hi private pure elemental module subroutine upcast_c(lo, hi) Send the value of lo to hi, respecting the kind of the types Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lo complex(kind=qp), intent(out) :: hi","tags":"","url":"interface/upcast.html"},{"title":"printmat – ROTEX","text":"public interface printmat Module Procedures private module subroutine printmat_i(M, funit, header) Prints a matrix to the supplied funit, otherwise print to stdout Arguments Type Intent Optional Attributes Name integer, intent(in) :: M (:,:) integer, intent(in), optional :: funit character(len=*), intent(in), optional :: header private module subroutine printmat_r(M, funit, header) Prints a matrix to the supplied funit, otherwise print to stdout Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: M (:,:) integer, intent(in), optional :: funit character(len=*), intent(in), optional :: header private module subroutine printmat_c(M, funit, header) Prints a matrix to the supplied funit, otherwise print to stdout Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: M (:,:) integer, intent(in), optional :: funit character(len=*), intent(in), optional :: header","tags":"","url":"interface/printmat.html"},{"title":"interpolate_replace – ROTEX","text":"public impure module subroutine interpolate_replace(xold, xnew, fx, idxx) Uses rotex__arrays bspline_module rotex__kinds Interpolate f(xold) -> f(xnew). Only consider xnew values that are contained within xold for now.\nXnew returns untouched, but fx is overwritten with interpolated values on the\ngrid xnew(idxx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xold (:) The grid of values on which our function has been evaluated real(kind=dp), intent(in) :: xnew (:) The new grid of values that we want our function to be evaluated on. real(kind=dp), intent(inout), allocatable :: fx (:) On input:  evaluated function f(xold)\nOn output: the evaluated function f(xnew) integer, intent(out), optional, allocatable :: idxx (:) The indices of values of xnew that are used to evaluate fx","tags":"","url":"proc/interpolate_replace.html"},{"title":"print_header – ROTEX","text":"subroutine print_header() Uses iso_fortran_env rotex__system Arguments None","tags":"","url":"proc/print_header.html"},{"title":"print_footer – ROTEX","text":"subroutine print_footer(time_start, time_end) Uses rotex__system rotex__characters rotex__types Arguments Type Intent Optional Attributes Name real(kind=dp) :: time_start real(kind=dp) :: time_end","tags":"","url":"proc/print_footer.html"},{"title":"print_rot_targ_states – ROTEX","text":"subroutine print_rot_targ_states(n_states) Uses rotex__system rotex__constants rotex__types Arguments Type Intent Optional Attributes Name type( N_states_type ), intent(in) :: n_states (:)","tags":"","url":"proc/print_rot_targ_states.html"},{"title":"print_dipoles – ROTEX","text":"subroutine print_dipoles(dipole_xyz, x, y, z) Uses rotex__constants rotex__system Print the dipole components in the determined ABC frame Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dipole_xyz (3) character(len=1), intent(in) :: x character(len=1), intent(in) :: y character(len=1), intent(in) :: z","tags":"","url":"proc/print_dipoles.html"},{"title":"gamma – ROTEX","text":"public interface gamma Module Procedures private impure elemental function gamma_cdp(z) result(res) MIT License Copyright (c) 2019-2021 stdlib contributors Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp)","tags":"","url":"interface/gamma.html"},{"title":"log_gamma – ROTEX","text":"public interface log_gamma Module Procedures private impure elemental function l_gamma_cdp(z) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp)","tags":"","url":"interface/log_gamma.html"},{"title":"read_kmats – ROTEX","text":"public module subroutine read_kmats(kmat_dir, channels_dir, point_group, spinmult, kmat_lmax, Kmat, elec_channels, channel_E_units, kmat_eval_E_units, kmat_output_type, kmat_e_closest) Uses rotex__characters rotex__constants rotex__system rotex__symmetry rotex__types rotex__arrays rotex__utils Reads in a K-matrix from a file with a very particular file format given by kmat_output_type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kmat_dir Directory in which the files containing the K-matrices character(len=*), intent(in) :: channels_dir Directory in which the channel data are located character(len=*), intent(in) :: point_group The point group of the calculations integer, intent(in) :: spinmult The spin multiplicity (2S+1) of the system (target + e⁻) integer, intent(in) :: kmat_lmax The max value of l in the electronic partial wave basis real(kind=dp), intent(out), allocatable :: Kmat (:,:) K(i, j) type( elec_channel_type ), intent(out), allocatable :: elec_channels (:) The channel basis of the K-matrix: (the code calls λ ) character(len=1), intent(in) :: channel_E_units The units of the channel energies in the Kmat file. Options are :\n - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV character(len=1), intent(in) :: kmat_eval_E_units The units of the energy at which the K-matrix was evaluated in the Kmat file. Options are :\n - \"h\" for hartree\n - \"e\" for eV\n - \"r\" for Rydberg character(len=*), intent(in) :: kmat_output_type The kind of K-matrix output to read real(kind=dp), intent(in) :: kmat_e_closest Evaluate the K-matrix that is closest to this energy","tags":"","url":"proc/read_kmats.html"},{"title":"read_namelists – ROTEX","text":"public  subroutine read_namelists(cfg) Uses rotex__characters rotex__constants rotex__types rotex__arrays rotex__system Reads user parameters and puts them into the config derived type\n Contains parameters and values that are necessary to run the program Parameters regarding the K-matrces used for (de-excitation) Parameters regarding the Coulomb-Born approximation\n used for (de-)excitation !!!!!!!!!!!!!!!!!!!! CONTROL_NAMELIST !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!! KMAT_NAMELIST !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!! COULOMB_NAMELIST !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name type( config_type ), intent(out) :: cfg","tags":"","url":"proc/read_namelists.html"},{"title":"group_size – ROTEX","text":"public pure module function group_size(point_group) result(n) Uses rotex__characters rotex__system Return the number of elements in point_group Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: point_group Return Value integer","tags":"","url":"proc/group_size.html"},{"title":"irrep_name – ROTEX","text":"public pure module function irrep_name(irrep, point_group) result(output) Uses rotex__characters rotex__system Given an irrep index in point_group, return the name of the corresponding irrep Arguments Type Intent Optional Attributes Name integer, intent(in) :: irrep character(len=*), intent(in) :: point_group Return Value character(len=:), allocatable","tags":"","url":"proc/irrep_name.html"},{"title":"possible_spin_symmetries – ROTEX","text":"public pure module function possible_spin_symmetries(kind) result(res) Uses rotex__system Returns an array of possible spin symmetry values Arguments Type Intent Optional Attributes Name integer, intent(in) :: kind Return Value integer, allocatable, (:)","tags":"","url":"proc/possible_spin_symmetries.html"},{"title":"spin_symmetry – ROTEX","text":"public pure elemental module function spin_symmetry(n, ka, kc, kind, symaxis) result(res) Uses rotex__system Returns the spin symmetry of the current N, Ka, Kc state Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: ka integer, intent(in) :: kc integer, intent(in) :: kind character(len=1), intent(in) :: symaxis Return Value integer","tags":"","url":"proc/spin_symmetry.html"},{"title":"get_group_irreps – ROTEX","text":"public pure module subroutine get_group_irreps(point_group, irreps) Uses rotex__characters rotex__system Given the point group, output an array containing the names of the irreps in the supplied point_group.\nOnly Abelian point groups are considered. Irreps in the code will be referred to by their indicies Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: point_group character(len=:), intent(out), allocatable :: irreps (:)","tags":"","url":"proc/get_group_irreps.html"},{"title":"is_spin_allowed – ROTEX","text":"public interface is_spin_allowed Module Procedures private pure elemental module function is_spin_allowed_chan(channel1, channel2, spin_isomer_kind, symaxis) result(res) Test if two rotational channels respect ortho/para symmetry Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_type ), intent(in) :: channel1 type( asymtop_rot_channel_type ), intent(in) :: channel2 integer, intent(in) :: spin_isomer_kind character(len=1), intent(in) :: symaxis Return Value logical private pure elemental module function is_spin_allowed_qnums(nlo, kalo, kclo, nup, kaup, kcup, kind, symaxis) result(res) Determine if the transition Nlo,Kalo,Kclo -> Nup,Kaup,Kcup is allowed by nuclear spin symmetry\nselection rules Arguments Type Intent Optional Attributes Name integer, intent(in) :: nlo integer, intent(in) :: kalo integer, intent(in) :: kclo integer, intent(in) :: nup integer, intent(in) :: kaup integer, intent(in) :: kcup integer, intent(in) :: kind character(len=1), intent(in) :: symaxis Return Value logical","tags":"","url":"interface/is_spin_allowed.html"},{"title":"is_spin_forbidden – ROTEX","text":"public interface is_spin_forbidden Module Procedures private pure elemental module function is_spin_forbidden_chan(channel1, channel2, spin_isomer_kind, symaxis) result(res) Test if two rotational channels respect ortho/para symmetry Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_type ), intent(in) :: channel1 type( asymtop_rot_channel_type ), intent(in) :: channel2 integer, intent(in) :: spin_isomer_kind character(len=1), intent(in) :: symaxis Return Value logical private pure elemental module function is_spin_forbidden_qnums(nlo, kalo, kclo, nup, kaup, kcup, kind, symaxis) result(res) Determine if the transition Nlo,Kalo,Kclo -> Nup,Kaup,Kcup is forbidden by nuclear spin symmetry\nselection rules Arguments Type Intent Optional Attributes Name integer, intent(in) :: nlo integer, intent(in) :: kalo integer, intent(in) :: kclo integer, intent(in) :: nup integer, intent(in) :: kaup integer, intent(in) :: kcup integer, intent(in) :: kind character(len=1), intent(in) :: symaxis Return Value logical","tags":"","url":"interface/is_spin_forbidden.html"},{"title":"get_channel_index – ROTEX","text":"public pure module function get_channel_index(channels, channel, reverse) result(i) Uses rotex__system Return the first index i where channel .eq. channels(i) is .true., or\nthe last index is reverse is .true. Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channels (:) class( channel_type ), intent(in) :: channel logical, intent(in), optional :: reverse Return Value integer","tags":"","url":"proc/get_channel_index.html"},{"title":"trim_channel_l – ROTEX","text":"public impure elemental module function trim_channel_l(channel_with_l) result(channel_without_l) Given a rotational channel with the l quantum number, return the equvalent channel without the l quantum number Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_l_type ), intent(in) :: channel_with_l Return Value type( asymtop_rot_channel_type )","tags":"","url":"proc/trim_channel_l.html"},{"title":"findloc_transitions – ROTEX","text":"public pure module function findloc_transitions(targs, search) result(idxtarg) Find the indices for each element in targs that map to the elements in search.\nReturn 0 if there is no such mapping. Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(in) :: targs (:) type( asymtop_rot_transition_type ), intent(in) :: search (:) Return Value integer, allocatable, (:) TARGS -> SEARCH mapping","tags":"","url":"proc/findloc_transitions.html"},{"title":"sort_channels_by_energy – ROTEX","text":"public impure module subroutine sort_channels_by_energy(channels) Bubble sort the array of channels such that the channel energies are in ascending order Arguments Type Intent Optional Attributes Name class( channel_type ), intent(inout) :: channels (:)","tags":"","url":"proc/sort_channels_by_energy.html"},{"title":"sort_channels – ROTEX","text":"public interface sort_channels Module Procedures private impure module subroutine sort_elec_channels(elec_channels) Sorts the inout array based on the quantum numbers of the channels Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout) :: elec_channels (:)","tags":"","url":"interface/sort_channels.html"},{"title":"permsort_channels – ROTEX","text":"public interface permsort_channels Module Procedures private impure module subroutine permsort_elec_channels(elec_channels, idx) Sorts the inout array based on the quantum numbers of the channels, and returns\nthe permutation array that would produce the same output Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout) :: elec_channels (:) integer, allocatable :: idx (:)","tags":"","url":"interface/permsort_channels.html"},{"title":"operator(.eq.) – ROTEX","text":"public interface operator(.eq.) Module Procedures private pure elemental module function channel_iseq(channel1, channel2) result(res) Test for channel equality on the basis of their quantum numbers only Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channel1 class( channel_type ), intent(in) :: channel2 Return Value logical private pure elemental module function transition_iseq(transition1, transition2) result(res) Test if two transitions are equal Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(in) :: transition1 type( asymtop_rot_transition_type ), intent(in) :: transition2 Return Value logical","tags":"","url":"interface/operator(.eq.).html"},{"title":"operator(.ne.) – ROTEX","text":"public interface operator(.ne.) Module Procedures private pure elemental module function channel_isne(channel1, channel2) result(res) Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channel1 class( channel_type ), intent(in) :: channel2 Return Value logical","tags":"","url":"interface/operator(.ne.).html"},{"title":"operator(.isin.) – ROTEX","text":"public interface operator(.isin.) Module Procedures private pure module function channel_isin(channel, channels) result(res) Check if a channel is in the array channels Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channel class( channel_type ), intent(in) :: channels (:) Return Value logical private pure module function transition_isin(transition, transitions) result(res) Check if a transition is in the array transitions Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(in) :: transition type( asymtop_rot_transition_type ), intent(in) :: transitions (:) Return Value logical","tags":"","url":"interface/operator(.isin.).html"},{"title":"assignment(=) – ROTEX","text":"public interface assignment(=) Module Procedures private impure elemental module subroutine channel_set_eq(channel_out, channel_in) Sets the channel left equal to the channel right Arguments Type Intent Optional Attributes Name class( channel_type ), intent(out) :: channel_out class( channel_type ), intent(in) :: channel_in","tags":"","url":"interface/assignment(=).html"},{"title":"rotex__hypergeometric – ROTEX","text":"For calculating the Gauss hypergeometric function ₂F₁(a,b;c;z) Uses rotex__constants rotex__kinds Functions public impure elemental function f21_dispatch (za, zb, zc, z, ts_tol) result(res) Checks if x is indeed in (0,1/2), and then makes a choice of evaluating the ODE (large a,b,c)\nor defaulting to the usual Taylor series Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: za complex(kind=dp), intent(in) :: zb complex(kind=dp), intent(in) :: zc complex(kind=dp), intent(in) :: z real(kind=dp), intent(in), optional :: ts_tol Return Value complex(kind=dp) public pure elemental function f21_ts (a, b, c, z, tol) result(res) Returns the Gauss hypergeometric function ₂F₁(a,b,;c;z) via a Taylor series method, with quad precision Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b complex(kind=dp), intent(in) :: c complex(kind=dp), intent(in) :: z real(kind=dp), intent(in), optional :: tol The tolerance for which must be met for the series to be considered converged. If this is not supplied, this value will be taken\nto be machine epsilon macheps_dp from the hypergeometric__constants module. Return Value complex(kind=dp) public impure elemental module function f21 (a, b, c, x) result(res) Returns one of the following transforms\n  1. ₂F₁(a,b;c;x) = (1-x)&#94;{-b} ₂F₁(b,c-a;c;x/(x-1))\n  2. ₂F₁(a,b;c;x) = (1-x)&#94;{-a} ₂F₁(a,c-b;c;x/(x-1))\n  3. ₂F₁(a,b;c;x) = (1-x)&#94;{-a} Γ(c)Γ(b-a)/(Γ(b)Γ(c-a)) ₂F₁(a,c-b;a-b+1;1/(1-x))\n                  + (1-x)&#94;{-b} Γ(c)Γ(a-b)/(Γ(a)Γ(c-b)) ₂F₁(b,c-a;b-a+1;1/(1-x))\n  4. ₂F₁(a,b;c;x) =               Γ(c)Γ(c-a-b)/Γ(c-a)Γ(c-b) ₂F₁(c-a, c-b, c-a-b+1, 1-x)\n                  + (1-x)&#94;(c-a-b) Γ(c)Γ(a+b-c)/Γ(a)Γ(b)     ₂F₁(c-a,c-b;c-a-b+1;1-x)\nRegions of validity:\n  1. |a| < |b|, -1 ≤ x < 0\n  2. |a| > |b|, -1 ≤ x < 0\n  3. -∞ < x < -1\n  4. ½ < x < 1 Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b complex(kind=dp), intent(in) :: c real(kind=dp), intent(in) :: x Return Value complex(kind=dp)","tags":"","url":"module/rotex__hypergeometric.html"},{"title":"rotex__drivers – ROTEX","text":"Driver used by the PROGRAM (helps me keep variables local and be sure I'm not accidentally\nusing globals if I make typos or something) Uses rotex__constants rotex__types Subroutines public module subroutine do_coulomb_born_approx (cfg, n_states, egrid_elec_cb, transitions_cb, xs_xcite_pcb, xs_xcite_tcb, pcb_output_directory, tcb_output_directory) Use the Coulomb-Born approximation to get scattering cross sections for e⁻ + target.\nAlso determines Einstein A coefficients and excited state average lifetimes within\n!! the radiative dipole/multipole approximation. The target charge Z is supplied and\nused by the routine that are called here, so various target charges can be used, including Z = 0 (neutral targets).\nThis routine loops over the different pairs  Nτ —→ N'τ' Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg type( N_states_type ), intent(inout), allocatable :: n_states (:) type( rvector_type ), intent(out), allocatable :: egrid_elec_cb (:) Array of arrays of electron/collision energies for each transition type( asymtop_rot_transition_type ), intent(out), allocatable :: transitions_cb (:) Array containing transitions between rotational states for the long-range CB excitations type( rvector_type ), intent(out), allocatable :: xs_xcite_pcb (:) Array of arrays of the Partial and Total Coulomb-Born cross sections for each transition type( rvector_type ), intent(out), allocatable :: xs_xcite_tcb (:) Array of arrays of the Partial and Total Coulomb-Born cross sections for each transition character(len=*), intent(in) :: pcb_output_directory character(len=*), intent(in) :: tcb_output_directory public module subroutine do_kmat_xs (cfg, n_states, egrid_tot_smat, smat_output_directory, transitions, xs_xcite_spinavg, xs_dxcite_spinavg) Read K-matrices from an electron-molecule scattering calculation, get S-matrices, add the rotation via\nthe rotational frame transformation for asymmetric tops, then use the MQDT channel elimination to\nget electron-impact excitation cross sections entirely from the K-matrix scattering data. Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg type( N_states_type ), intent(in) :: n_states (:) real(kind=dp), intent(in) :: egrid_tot_smat (:) Total energy grid for the S-matrix cross sections character(len=*), intent(in) :: smat_output_directory type( asymtop_rot_transition_type ), intent(out), allocatable :: transitions (:) type( rvector_type ), intent(out), allocatable :: xs_xcite_spinavg (:) Array of arrays of excitation cross sections for all spin multiplicities type( rvector_type ), intent(out), allocatable :: xs_dxcite_spinavg (:) Array of arrays of de-excitation cross sections for all spin multiplicities public module subroutine convert_multipoles (cartesian_moments_array, spherical_moments_array) Convert the supplied array of multipole moments from cartesian, obtained as typical output from\nquantum chemistry codes, to spherical multipole moments Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: cartesian_moments_array (:) Array containing cartesian multipole moments. complex(kind=dp), intent(out) :: spherical_moments_array (:) Array containing spherical multipole moments. public module subroutine make_grid (grid, E0, num_segments, grid_segments, nelemnts_per_seg, spacing) Make a segmented grid starting at E0\nExample with\n  num_segments = 3, grid_segments = [1e-3, 1e-2, 1e-1, 1], nelemnts_per_seg = [1000,1000, 100]\nE0+1e-3           E0+1e-2              E0+1e-1           E0+1.0\n  !------------------!-------------------!- - - - - - - - -!\n     1000 energies     1000 energies      100 energies Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: grid (:) The energy grid real(kind=dp), intent(in) :: E0 The lowest energy integer, intent(in) :: num_segments The number of segments in the energy grid real(kind=dp), intent(in) :: grid_segments (:) The boundaries of the grid segments integer, intent(in) :: nelemnts_per_seg (:) The number of elements in each grid segment character(len=3), intent(in) :: spacing The spacing type in each segment. \"LIN\" for linear or \"LOG\" for logarithmic public module subroutine make_output_directories (output_directory, use_cb, spinmults, use_kmat, pcb_output_directory, tcb_output_directory, smat_output_directory) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory logical, intent(in) :: use_cb integer, intent(in) :: spinmults (:) logical, intent(in) :: use_kmat character(len=:), intent(inout), allocatable :: pcb_output_directory character(len=:), intent(inout), allocatable :: tcb_output_directory character(len=:), intent(inout), allocatable :: smat_output_directory public module subroutine get_CDMS_data (filename, output_directory, CDMS_states, CDMS_transitions) Read a file from the CDMS search to get Einstein A coefficients that will be used in determining\nCoulomb-Born cross sections. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: output_directory type(asymtop_state_type), intent(out), allocatable :: CDMS_states (:) type(asymtop_transition_type), intent(out), allocatable :: CDMS_transitions (:) public module subroutine get_cdms_state_energies (n_states, cdms_states) Update the energy of our rotational states with those from the CDMS Arguments Type Intent Optional Attributes Name type( N_states_type ), intent(inout) :: n_states (:) class(asymtop_state_type), intent(in) :: cdms_states (:) public module subroutine get_CDMS_einstA (Nlo, Kalo, Kclo, Nup, Kaup, Kcup, CDMS_transitions, EinstA) Given the quantum numbers of a rotational transition, find the matching CDMS transition\nand get the corresponding Einstein A coefficient Arguments Type Intent Optional Attributes Name integer, intent(in) :: Nlo integer, intent(in) :: Kalo integer, intent(in) :: Kclo integer, intent(in) :: Nup integer, intent(in) :: Kaup integer, intent(in) :: Kcup class(asymtop_transition_type), intent(in) :: CDMS_transitions (:) real(kind=dp), intent(out) :: EinstA public module subroutine diagonalize_rotational_hamiltonian (cfg, num_n, n_values, n_states) Build the rigid-rotor hamiltonian for each N and diagonalize it. Keep eigenenergies and\neigenvectors, stored in the eigenH type of n_states Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg integer, intent(in) :: num_n integer, intent(in) :: n_values (:) type( N_states_type ), intent(out) :: n_states (:) public module subroutine combine_cb_smat_xs (cfg, egrid_cb, egrid_tot_smat, transitions_cb, xs_xcite_pcb, xs_xcite_tcb, transitions_smat, xs_xcite_smat, xs_dxcite_smat) Combine Coulomb-Born and S-matrix cross sections to be on the same electron energy grid.\nIn general, a different number of transitions will exist for the Coulomb-Born cross sections\nand for the S-matrix cross sections. This routine matches the transitions, interpolates the\nCB cross sections to the total energy grid used by the S-matrix routines, and adds them\ntogether:\n  σ(tot) = σ(S-mat) + σ(TCB) - σ(PCB) Arguments Type Intent Optional Attributes Name type( config_type ), intent(in) :: cfg Program config variables type( rvector_type ), intent(in) :: egrid_cb (:) Array of arrays of electron energy grids for the CB cross sections for each transition real(kind=dp), intent(in) :: egrid_tot_smat (:) The total energy grid on which the S-matrix cross sections were evaluated type( asymtop_rot_transition_type ), intent(in) :: transitions_cb (:) Array of arrays of transition between two rotational states lo and up in the CB approx type( rvector_type ), intent(inout) :: xs_xcite_pcb (:) Array of arrays of partial CB cross sections for each transition (excitation only, de-excitation handled by detailed balance) type( rvector_type ), intent(inout) :: xs_xcite_tcb (:) Array of arrays of total CB cross sections for each transition (excitation only, de-excitation handled by detailed balance) type( asymtop_rot_transition_type ), intent(in) :: transitions_smat (:) Array of arrays of transition between two rotational states lo and up using the S-matrix type( rvector_type ), intent(inout) :: xs_xcite_smat (:) Array of arrays of S-matrix cross sections for each transition; excitation type( rvector_type ), intent(inout) :: xs_dxcite_smat (:) Array of arrays of S-matrix cross sections for each transition; de-excitation","tags":"","url":"module/rotex__drivers.html"},{"title":"rotex__CBXS – ROTEX","text":"Routines to calculate cross sections in the Coulomb-Born approximation Functions public impure elemental function M (l, ki, kf, Z) result(res) Calculates the integral via the expression given in\n  \"Electromagnetic Excitation: Theory of Coulomb Excitation with Heavy Ions \" by Kurt Alder and Aage Winther, Chapter IX,\n   section 2, page 244, equation 14.\nfor λ = 1, where . There is an expression for λ = 2 in\n  \"Study of Nuclear Structure by Electromagnetic Excitation with Accelerated Ions\" by K. Alder, A. Bohr, T. Huus,\n  B. Mottelson, and A. Winther, but only the dipole is used (at least for now). Arguments Type Intent Optional Attributes Name integer, intent(in) :: l real(kind=dp), intent(in) :: ki real(kind=dp), intent(in) :: kf integer, intent(in) :: Z Return Value complex(kind=dp) Subroutines public module subroutine get_einsta_only (einsta, nlo, nup, elo, eup, eigveclo, eigvecup, use_CDMS, do_dipole, do_quadrupole, dipole_moments, quadrupole_moments) Calculate only the Einstein A coefficeints for a transition Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: einsta The Einstein coefficient for the transition integer, intent(in) :: nlo the angular momentum quantum number integer, intent(in) :: nup the angular momentum quantum number real(kind=dp), intent(in) :: elo The energy (hartrees) of the initial state real(kind=dp), intent(in) :: eup The energy (hartrees) of the final state real(kind=dp), intent(in) :: eigveclo (:) Eigenvector of the initial state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N,\\tau}_K) real(kind=dp), intent(in) :: eigvecup (:) Eigenvector of the final state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N',\\tau'}_{K}) logical, intent(in) :: use_CDMS Whether to calculate the Einstein A coefficients ourselves (.true.) or to use values obtained\nfrom the CDMS catalogue (.false.) logical, intent(in) :: do_dipole logical, intent(in) :: do_quadrupole complex(kind=dp), intent(in), target :: dipole_moments (3) The spherical dipole moments complex(kind=dp), intent(in), target :: quadrupole_moments (5) The spherical quadrupole moments public module subroutine get_CB_xs_asym (energies, sigma, Z, N, Np, E, Ep, eigvec, eigvecp, einsta, use_CDMS, do_dipole, do_quadrupole, dipole_moments, quadrupole_moments, analytic_total_cb, lmax) Calculate the excitation and de-excitation cross sections (xs) for an asymmetric top up.\nThe sum over partial waves is either truncated to or determined analytically.\nThe summation over the angular momentum components, multipole terms, and partial waves are separable\nfor each value of λ as summation = (sum over angular momentum and multipole moments) (sum overpartial waves). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energies (:) Array of scattering energies to consider real(kind=dp), intent(out), allocatable :: sigma (:) Cross sections calculated on a grid of scattering energies for Returned with the same size as energies integer, intent(in) :: Z Target charge integer, intent(in) :: N the angular momentum quantum number integer, intent(in) :: Np the angular momentum quantum number real(kind=dp), intent(in) :: E The energy (hartrees) of the initial state real(kind=dp), intent(in) :: Ep The energy (hartrees) of the final state real(kind=dp), intent(in) :: eigvec (:) Eigenvector of the initial state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N,\\tau}_K) real(kind=dp), intent(in) :: eigvecp (:) Eigenvector of the final state in the basis of symmetric top wavefunctions; the coefficients\n(c&#94;{N',\\tau'}_{K}) real(kind=dp), intent(inout) :: einsta The Einstein coefficient for the transition logical, intent(in) :: use_CDMS Whether to calculate the Einstein A coefficients ourselves (.true.) or to use values obtained\nfrom the CDMS catalogue (.false.) logical, intent(in) :: do_dipole logical, intent(in) :: do_quadrupole complex(kind=dp), intent(in), target :: dipole_moments (3) The spherical dipole moments complex(kind=dp), intent(in), target :: quadrupole_moments (5) The spherical quadrupole moments logical, intent(in) :: analytic_total_cb (:) Array of values telling us whether we want to use the analytic expression for lmax -> infintiy integer, intent(in) :: lmax The max value of the orbital angular momentum quantum number l to consider public pure module subroutine xtrapolate_cb_xs (Ei_xtrap, Ethresh, nE_xtrap, Eel, xs_pcb, xs_tcb) Extrapolate an excitation/de-excitation cross section to its excitation threshold.\nRe-allocates Eel and xs to contain the extrapolated values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: Ei_xtrap Extrapolate down Ethresh + Ei_xtrap real(kind=dp), intent(in) :: Ethresh The excitation threshold integer, intent(in) :: nE_xtrap Number of extrapolation energies real(kind=dp), intent(inout), allocatable :: Eel (:) On input, the electron energy grid.\nOn output, the electron energy grid with extrapolated energies prepended real(kind=dp), intent(inout), allocatable :: xs_pcb (:) On input, the partial Coulomb-Born cross sections.\nOn output, the partial Coulomb-Born cross sections with extrapolated cross sections prepended real(kind=dp), intent(inout), allocatable :: xs_tcb (:) On input, the total Coulomb-Born cross sections.\nOn output, the total Coulomb-Born cross sections with extrapolated cross sections prepended","tags":"","url":"module/rotex__cbxs.html"},{"title":"rotex__kinds – ROTEX","text":"Contains kind definitions (double, xtended double, quad precision) Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15) integer, public, parameter :: xdp = selected_real_kind(18) integer, public, parameter :: qp = selected_real_kind(33)","tags":"","url":"module/rotex__kinds.html"},{"title":"rotex__wigner – ROTEX","text":"Calculate the Wigner 3j symbols Functions public pure elemental module function clebsch (j1, m1, j2, m2, j, m) result(res) Returns the Clebsch-Gordan coefficient by using its relation to the Wigner 3j symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 integer, intent(in) :: m1 integer, intent(in) :: j2 integer, intent(in) :: m2 integer, intent(in) :: j integer, intent(in) :: m Return Value real(kind=dp) public pure elemental module function wigner3j (dj1, dj2, dj3, dm1, dm2, dm3) result(res) returns the Wigner 3j symbol via explicit calculation. These should probably be\nprecomputed, but this works for now. The WignerSymbol-f repo seems like a good implementation. The wigner repo by ogorton takes up way too much memory for the high partial waves because\nit tries to allocate (2N+1)&#94;6 doubles. NOTE: for the high partial wave, we know that\nwe'll only need values with m1 = m2 = m3 = 0, so take advantage of this ? Arguments Type Intent Optional Attributes Name integer, intent(in) :: dj1 twice the angular momenta j integer, intent(in) :: dj2 twice the angular momenta j integer, intent(in) :: dj3 twice the angular momenta j integer, intent(in) :: dm1 twice the angular momenta m integer, intent(in) :: dm2 twice the angular momenta m integer, intent(in) :: dm3 twice the angular momenta m Return Value real(kind=dp) the result","tags":"","url":"module/rotex__wigner.html"},{"title":"rotex__writing – ROTEX","text":"Procedures for writing data to disk Subroutines public module subroutine write_lifetimes_to_file (output_directory, N_min, N_max, N_states, zaxis) Writes the states involved in the excitation and their lifetimes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory The directory in which output files are placed integer, intent(in) :: N_min Minimum and maximum value of N for which lifetimes were evaluated integer, intent(in) :: N_max Minimum and maximum value of N for which lifetimes were evaluated type( N_states_type ), intent(in) :: N_states (:) character(len=1), intent(in) :: zaxis The array of states public module subroutine write_CB_xs_to_file (prefix, output_directory, zaxis, E_el, xs, init, fin, lmax, xs_type) Writes a Coulomb-Born cross section to a file whos name and file header\ncarry information about the state symmetry Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix filename prefix character(len=*), intent(in) :: output_directory The directory in which output files are placed character(len=1), intent(in) :: zaxis The A, B, or C axis that lies along z real(kind=dp), intent(in) :: E_el (:) the scattering eneries in au real(kind=dp), intent(in) :: xs (:) The excitation cross sections type( asymtop_rot_channel_type ), intent(in) :: init Initial and final states for this transition type( asymtop_rot_channel_type ), intent(in) :: fin Initial and final states for this transition character(len=*), intent(in) :: lmax The max value of l for the CB cross sections (\"inf\" if total) character(len=*), intent(in), optional :: xs_type The kind of cross section that this is public module subroutine write_smat_xs_to_file (prefix, output_directory, zaxis, egrid_total, transition, exxs, dexxs, lmax) Writes an S-matrix (+CB) cross section to a file whos name and file header\ncarry information about the state symmetry Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix filename prefix character(len=*), intent(in) :: output_directory The directory in which output files are placed character(len=1), intent(in) :: zaxis The A, B, or C axis that lies along z real(kind=dp), intent(in) :: egrid_total (:) The grid of total energies in au type( asymtop_rot_transition_type ), intent(in) :: transition The transition (excitation pair) to be consdered real(kind=dp), intent(in) :: exxs (:) Array of excitation cross sections for this/all spin multiplicities real(kind=dp), intent(in) :: dexxs (:) Array of de-excitation cross sections for all spin multiplicities integer, intent(in) :: lmax The max value of l for the K-matrices public module subroutine write_total_xs_to_file (prefix, output_directory, zaxis, egrid_total, transition, xs_xcite, xs_dxcite, lmax) Write the total cross-sections (S-matrix + CB correction) to disk for a single transition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix filename prefix character(len=*), intent(in) :: output_directory The directory in which output files are placed character(len=1), intent(in) :: zaxis The A, B, or C axis that lies along z real(kind=dp), intent(in) :: egrid_total (:) The grid of total energies in au type( asymtop_rot_transition_type ), intent(in) :: transition The transition to write to file real(kind=dp), intent(in) :: xs_xcite (:) Array of arrays of excitation cross sections for all spin multiplicities real(kind=dp), intent(in) :: xs_dxcite (:) Array of arrays of de-excitation cross sections for all spin multiplicities integer, intent(in) :: lmax The max value of l for the K/S-matrices public module subroutine write_channels_to_file (filename, jmin, jmax, n_states, channels_l, channels_l_j, spin_isomer_kind, symaxis) Write rotational channel info to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File to which we write channels integer, intent(in) :: jmin Total angular momentum mim/max integer, intent(in) :: jmax Total angular momentum mim/max type( N_states_type ), intent(in) :: n_states (:) type( asymtop_rot_channel_l_type ), intent(in) :: channels_l (:) Rotational channels type( asymtop_rot_channel_l_vector_type ), intent(in) :: channels_l_j (jmin:jmax) Rotational channels for each J integer, intent(in) :: spin_isomer_kind Kind of nuclear spin to preserve character(len=1), intent(in) :: symaxis Symmetry axis for nuclear spin","tags":"","url":"module/rotex__writing.html"},{"title":"rotex__MQDTXS – ROTEX","text":"Routines to calculate cross sections with MQDT + S-matrix Subroutines public module subroutine get_smat_probs (total_energy_grid, prob, transitions, nmin, nmax, smat_j, jmin, jmax, channels_j, channels_tot, spin_isomer_kind, symaxis) Given a rotationally resolved S-matrix, calculate rotational (de-)excitation\ncross section probabilities for the supplied transitions. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_energy_grid (:) The total energy grid on which the S-matrix will be evaluated type( rvector_type ), intent(out), allocatable :: prob (:) Probability at each pair of channels (n,N,Ka,Kc) ←→ (n',N',Ka',Kc') type( asymtop_rot_transition_type ), intent(inout), allocatable :: transitions (:) Array of transitions that will be considered for (de-)excitation integer, intent(in) :: nmin Min/max values of N to consider for excitation calculations integer, intent(in) :: nmax Min/max values of N to consider for excitation calculations type( cmatrix_type ), intent(in) :: smat_j (jmin:jmax) Array of S-matrix sub-blocks for each J integer, intent(in) :: jmin Min/max values of J to consider for the S-matrix subblocks integer, intent(in) :: jmax Min/max values of J to consider for the S-matrix subblocks type( asymtop_rot_channel_l_vector_type ), intent(in) :: channels_j (jmin:jmax) Contains the array of channels for each J type( asymtop_rot_channel_l_type ), intent(in) :: channels_tot (:) Contains the array of channels ∀ J integer, intent(in) :: spin_isomer_kind What kinda spin symmetry we need to respect character(len=1), intent(in) :: symaxis The symmetry axis of the target","tags":"","url":"module/rotex__mqdtxs.html"},{"title":"rotex__constants – ROTEX","text":"Contains most (but not all) defined constants used throughout the code. Uses rotex__kinds iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: IOSTAT_OK = 0 integer, public, parameter :: IQ_DEFAULT = 4 integer, public, parameter :: DEFAULT_INT = -409 real(kind=dp), public, parameter :: CB_MINT_IMAG_THRESH = 1e-8_dp Warn user if CB cross section M integrals have imaginary components\nlarger than this value (they should be real). The code will try to skip such values. real(kind=dp), public, parameter :: HYPGEO_ABC_THRESHOLD = 160._dp Threshold for warning the user about large values of a,b,c in\n₂F₁(a,b;c;z) real(kind=dp), public, parameter :: ahalf = 0.5_dp real(kind=dp), public, parameter :: zero = 0._dp real(kind=dp), public, parameter :: one = 1._dp real(kind=dp), public, parameter :: two = 2._dp real(kind=dp), public, parameter :: three = 3._dp real(kind=dp), public, parameter :: four = 4._dp real(kind=dp), public, parameter :: pi = atan(1._dp)*4._dp π real(kind=dp), public, parameter :: invc = 1._dp/137.035999177_dp 1/c, where c is the speed of light in atomic units. This is equal to the fine structure constant α. real(kind=dp), public, parameter :: macheps_dp = epsilon(one) real(kind=dp), public, parameter :: rho = 0.8_dp real(kind=dp), public, parameter :: euler_mascheroni = 0.57721566490153286060651209008240243104215933593992_dp the Euler Mascheroni constant. The difference between the harmonic series and the natural logarithm real(kind=dp), public, parameter :: au2ryd = 2._dp Hartree -> Rydberg real(kind=dp), public, parameter :: au2ev = 27.2113834e0_dp Hartree -> eV real(kind=dp), public, parameter :: au2ang = 0.5291772083_dp Bohr -> Ångstrom real(kind=dp), public, parameter :: au2cm = au2ang*1e-8_dp Bohr -> cm real(kind=dp), public, parameter :: au2invcm = 219474.6313710e0_dp multiplication factor to convert atomic units of energy (hartree) to wavenumbers (inverse centimeters) real(kind=dp), public, parameter :: au2sec = 2.4188843e-17_dp multiplication factor to convert atomic units of time (hbar / hartree) to seconds real(kind=dp), public, parameter :: au2deb = 2.5417462762781615_dp atomic units (electric dipole) -> Debye complex(kind=dp), public, parameter :: im = (zero, one) the square root of -1 character(len=1), public, parameter :: CHAR_CR = achar(13) character(len=1), public, parameter :: DEFAULT_CHAR1 = \"x\" character(len=7), public, parameter :: UKRMOLX = 'ukrmol+' character(len=7), public, parameter :: MQDTR2K = 'mqdtr2k' character(len=7), public, parameter :: spinmult_names (5) = ['singlet', 'doublet', 'triplet', 'quartet', 'quintet']","tags":"","url":"module/rotex__constants.html"},{"title":"rotex__linalg – ROTEX","text":"Linear algebra interfaces to LAPACK routines and other linear algebra stuff Uses rotex__kinds Interfaces interface public  subroutine zgesv(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nrhs complex(kind=dp), intent(inout) :: a (lda,*) integer, intent(in) :: lda integer, intent(out) :: ipiv (*) complex(kind=dp), intent(inout) :: b (ldb,*) integer, intent(in) :: ldb integer, intent(out) :: info interface public  subroutine dsyev(jobz, uplo, n, a, lda, w, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=dp), intent(inout) :: a (lda,n) integer, intent(in) :: lda real(kind=dp), intent(out) :: w (*) real(kind=dp), intent(out) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: info Functions public  function right_divide (A, B) result(X) Returns X = AB⁻¹ without evaluating B⁻¹ Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) Return Value complex(kind=dp), (size(A,1),size(A,2))","tags":"","url":"module/rotex__linalg.html"},{"title":"rotex__RFT – ROTEX","text":"Procedures used to carry out the rotational frame transformation Subroutines public module subroutine RFT_nonlinear (Kmat, Jmin, Jmax, Smat_J, elec_channels, N_states, asymtop_rot_channels_l, asymtop_rot_channels_l_J, spin_isomer_kind, symaxis, real_spherical_harmonics, point_group) Build the electronic S-matrix from the electronic K-matrix, then perform the rotational frame transformation on the S-matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: Kmat (:,:) The K-matrix, needed as input for the RFT integer, intent(in) :: Jmin The lowest value of J = N + l integer, intent(in) :: Jmax The largest value of J = N + l type( cmatrix_type ), intent(out) :: Smat_J (Jmin:Jmax) The rotational S-matrices , produced by the RFT type( elec_channel_type ), intent(in) :: elec_channels (:) The array of electronic channels (n, l, ml), needed as input for the RFT type( N_states_type ), intent(in) :: N_states (:) The array of rotational states of the target (N, Ka, Kc), needed as input for the RFT type( asymtop_rot_channel_l_type ), intent(out), allocatable :: asymtop_rot_channels_l (:) The array of rotational channels (N, Ka, Kc, l) that make up the basis of the S-matrix type( asymtop_rot_channel_l_vector_type ), intent(out) :: asymtop_rot_channels_l_J (Jmin:Jmax) The array of arrays of rotational channels (N, Ka, Kc, l) that make up the basis of the S-matrix subblocks at each J integer, intent(in) :: spin_isomer_kind Spin isomer kind character(len=1), intent(in) :: symaxis Symmetry axis for respecting nuclear spin symmetry logical, intent(in) :: real_spherical_harmonics Whether the input K-matrices are evaluated in a basis of real spherical harmonics\nfor the scattering electron. If .true., transform the S-matrix into a basis of\ncomplex-valued spherical harmonics character(len=*), intent(in) :: point_group The point group of the calculation","tags":"","url":"module/rotex__rft.html"},{"title":"rotex__functions – ROTEX","text":"Contains various small functions used in the code Uses rotex__kinds Interfaces public        interface are_approx_eq Compare two a and b and see if the magnitude of their difference is smaller than a tolerance,\ntaking machine epsilon*max(|a|,|b|) for their precision as the default value private pure elemental module function are_approx_eqz(a, b, tol) result(res) Comparre two a and b and see if magnitude of their difference is smaller than a tolerance,\ntaking machine epsilon for their precision as the default value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: tol Return Value logical private pure elemental module function are_approx_eqr(a, b, tol) result(res) Comparre two a and b and see if magnitude of their difference is smaller than a tolerance,\ntaking machine epsilon for their precision as the default value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: tol Return Value logical public        interface factorial !n private pure elemental module function factorial_int(n) result(res) !n Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=dp) private pure elemental module function factorial_real(n) result(res) !n Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n Return Value real(kind=dp) public        interface log_factorial ln(!n) private pure elemental module function log_factorial_i(n) result(res) returns ln(n!) for integer n Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=dp) private pure elemental module function log_factorial_r(n) result(res) returns ln(n!) for real n Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n Return Value real(kind=dp) public        interface expm1 private module function expm1r(x) result(res) Returns . TODO, replace with a fast and accurate version\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), value :: x Return Value real(kind=dp) private module function expm1z(z) result(res) Returns . TODO, replace with a fast and accurate version\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp) public        interface logp1 private module function logp1r(x) result(res) Returns for real z. TODO, replace with a fast and accurate version\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function logp1z(z) result(res) Returns for complex z. TODO, replace with a fast and accurate version ?\ncoded natively in fortran ! Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp) public        interface logb private pure elemental function logb_ii(b, x) result(res) Returns the logarithm of x in the base b Arguments Type Intent Optional Attributes Name integer, intent(in) :: b integer, intent(in) :: x Return Value real(kind=dp) private pure elemental function logb_rr(b, x) result(res) Returns the logarithm of x in the base b Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: b real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental function logb_cc(b, x) result(res) Returns the logarithm of x in the base b Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: b complex(kind=dp), intent(in) :: x Return Value complex(kind=dp) public        interface logrange private pure function logrange_ib(a, b, n, base, inclast) result(res) Returns an array of n log-spaced values from a to b. By default, the base is 10\nif omitted but can be changed by the user Arguments Type Intent Optional Attributes Name integer(kind=dp), intent(in) :: a integer(kind=dp), intent(in) :: b integer, intent(in) :: n integer, intent(in), optional :: base Logarithm base logical, intent(in), optional :: inclast Whether to include the last value b Return Value real(kind=dp), (n) private pure function logrange_rb(a, b, n, base, inclast) result(res) Returns an array of n log-spaced values from a to b. By default, the base is 10\nif omitted but can be changed by the user Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b integer, intent(in) :: n real(kind=dp), intent(in), optional :: base Logarithm base logical, intent(in), optional :: inclast Whether to include the last value b Return Value real(kind=dp), (n) public        interface isinteger Check if a real/complex number is an integer private pure elemental module function isintegerr(x) result(res) Check if x is an integer Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value logical private pure elemental module function isintegerz(z) result(res) Check if z is an integer Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value logical public        interface isnatural Check if a real/complex number is a natrual number private pure elemental module function isnaturalr(x) result(res) Check if x is a natural number (1, 2, 3, ...) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value logical private pure elemental module function isnaturalz(z) result(res) Check if z is a natural number (1, 2, 3, ...) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value logical public        interface arg Return the phase of a complex number in (-π,π] private pure elemental module function argi(z) result(res) Return the phase of an integer (as a complex number) in (-π,π] Arguments Type Intent Optional Attributes Name integer, intent(in) :: z Return Value real(kind=dp) private pure elemental module function argr(z) result(res) Return the phase of a real number (as a complex number) in (-π,π] Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: z Return Value real(kind=dp) private pure elemental module function argc(z) result(res) Return the phase of a complex number in (-π,π] Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value real(kind=dp) public        interface inv Compute 1/z private pure elemental module function invi(i) result(res) Return the real 1/i for integer i Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value real(kind=dp) private pure elemental module function invr(x) result(res) Return 1/x Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function invz(z) result(res) Return 1/z for complex z. If the imaginary part of z is 0, flip its sign Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp) Functions public pure elemental module function delta (m, n) result(res) Return the Kronecker delta function Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value real(kind=dp) public pure elemental module function iseven (n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value logical public pure elemental module function isodd (n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value logical public pure elemental module function istriangle (a, b, c) result(res) returns whether the arguments satisfy the triangle inequality,\nassuming that they're positive quantities Arguments Type Intent Optional Attributes Name integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value logical public pure elemental module function neg (i) result(res) Returns the integer } Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer","tags":"","url":"module/rotex__functions.html"},{"title":"rotex__characters – ROTEX","text":"Contains procedures related to characters and character arrays, such as converting integers to characters Uses rotex__functions rotex__kinds Interfaces public        interface s2hms convert seconds to hours, minutes, seconds private pure module function int_s2hms(s) result(time) Given an integer 's' in seconds, convert to the format hh:mm:ss. Arguments Type Intent Optional Attributes Name integer, intent(in) :: s Return Value character(len=:), allocatable private pure module function real_s2hms(s_re) result(time) Given an integer in seconds, convert to the format hh:mm:ss. Input is a real, gets converted to int Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: s_re Return Value character(len=:), allocatable public        interface int2char private pure function scalar_int2char(i) result(res) Writes the value i to a character as I0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable private pure function vector_int2char(i) result(res) Writes the value i to a character as I0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) Return Value character(len=:), allocatable Functions public pure elemental function ndigits (n) result(num) Returns number of characters an integer will occupy Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer public pure module function dJ2char (dJ) result(res) Takes an integer dJ and results the character representing half of it.\ndJ2char(2) -> \"1\"\ndJ2char(3) -> \"3/2\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: dJ Twice the angular momentum Return Value character(len=:), allocatable The output character representation public pure function sub (x) result(res) Returns the subscript version of the integer x Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=:), allocatable public pure function sup (x) result(res) Returns the superscript version of the integer x Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=:), allocatable Subroutines public pure module subroutine add_trailing (chr, trail) Add a trailing character trail to the character chr if it is not already the\nlast character Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: chr character(len=*), intent(in) :: trail public pure elemental subroutine to_lower (chr) converts a character to lower case Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: chr public pure elemental subroutine to_upper (chr) converts a character to upper case Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: chr","tags":"","url":"module/rotex__characters.html"},{"title":"rotex__hamilton – ROTEX","text":"Module containing procedures to construct and diagonalize rotational Hamiltonians Uses rotex__types Subroutines public module subroutine H_asym (N, eigenH, Bx, By, Bz, cd4, cd6) Construct the symmetric top rigid-rotor Hamiltonian Arguments Type Intent Optional Attributes Name integer, intent(in) :: N The rotational quantum number type( eigenH_type ), intent(out) :: eigenH The eigenvectors and eigenvalues of The angular momentum number real(kind=dp), intent(in) :: Bx Rotational constants real(kind=dp), intent(in) :: By Rotational constants real(kind=dp), intent(in) :: Bz Rotational constants type( cd4_type ), intent(in), optional :: cd4 The quartic centrifugal distortion parameters type( cd6_type ), intent(in), optional :: cd6 The sextic centrifugal distortion parameters public module subroutine assign_projections (N, eigenH, absKvals, sort_eigvecs) Using the eigenvectors and energies from a diagonalized rotational Hamiltonian,\ndetermine which projection is maximal. The eigenvectors can be in the Ka or Kc basis.\nThis routine will return the array Kvals which indicats the absolute value of the projection that\ncontributes the most to a particular eigenvector Arguments Type Intent Optional Attributes Name integer, intent(in) :: N The rotational quantum number type( eigenH_type ), intent(in) :: eigenH Contains the eigenvalues and eigenvectors of the rotational Hamiltonian for the given value of N, digaonalized in\nthe Ka or the Kc symmetric top basis integer, intent(out), allocatable :: absKvals (:) Array of the absolte value of |K| that contributes the most to a particular eigenvector logical, intent(in), optional :: sort_eigvecs Sort the eigenvectors ?","tags":"","url":"module/rotex__hamilton.html"},{"title":"rotex__arrays – ROTEX","text":"Various routines for arrays Uses rotex__types Interfaces public        interface append_uniq private  subroutine append_uniq_i(arr, new) Append unique element \"new\" to array \"arr\" Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: new private pure module subroutine append_uniq_transition(old, new) Append unique element \"new\" to array \"old\" Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(inout), allocatable :: old (:) type( asymtop_rot_transition_type ), intent(in) :: new (:) public        interface append private pure module subroutine append_i(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: val private pure module subroutine append_r(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: arr (:) real(kind=dp), intent(in) :: val private pure module subroutine append_rvector(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name type( rvector_type ), intent(inout), allocatable :: arr (:) real(kind=dp), intent(in) :: val (:) private pure module subroutine append_asymtop_transition(arr, val) Append the value val to the array arr Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(inout), allocatable :: arr (:) type( asymtop_rot_transition_type ), intent(in) :: val private pure module subroutine append_elec_channel(channels, channel) Append elec_channel to the array elec_channels Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout), allocatable :: channels (:) type( elec_channel_type ), intent(in) :: channel private pure module subroutine append_elec_channels(channels, channels2) Append channels2 to the array channels Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout), allocatable :: channels (:) type( elec_channel_type ), intent(in) :: channels2 (:) private pure module subroutine append_asymtop_rot_channel(channels, channel) Append asymtop_rot_channel to the array asymtop_rot_channels Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_type ), intent(inout), allocatable :: channels (:) type( asymtop_rot_channel_type ), intent(in) :: channel private pure module subroutine append_asymtop_rot_channel_l(channels, channel) Append asymtop_rot_channel to the array asymtop_rot_channels Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_l_type ), intent(inout), allocatable :: channels (:) type( asymtop_rot_channel_l_type ), intent(in) :: channel public        interface adjoint private pure module function adjoint_i(A) result(res) Returns the adjoint of an integer-valued matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer, (size(A,2),size(A,1)) private pure module function adjoint_r(A) result(res) Returns the adjoint of a real-valued matrix Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp), (size(A,2),size(A,1)) private pure module function adjoint_c(A) result(res) Returns the adjoint of a complex-valued matrix Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp), (size(A,2),size(A,1)) public        interface size_check private pure module subroutine size_check_1d(arr, larr, name) Check that the size of the array arr is of length larr Arguments Type Intent Optional Attributes Name class(*), intent(in) :: arr (:) integer, intent(in) :: larr character(len=*), intent(in) :: name private pure module subroutine size_check_2d(arr, larr, name) Check that the size of the array arr is of length larr Arguments Type Intent Optional Attributes Name class(*), intent(in) :: arr (:,:) integer, intent(in) :: larr (:) character(len=*), intent(in) :: name public        interface norm_frob private pure module function norm_frob_i(A) result(res) Returns the Frobenius norm for a matrix A Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value real(kind=dp) private pure module function norm_frob_r(A) result(res) Returns the Frobenius norm for a matrix A Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private pure module function norm_frob_c(A) result(res) Returns the Frobenius norm for a matrix A Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) public        interface realloc private pure module subroutine realloc_1d_int(arr, n) Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_1d_real(arr, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_1d_cmplx(arr, n) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_1d_elec_channel(arr, n) Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout), allocatable :: arr (:) integer, intent(in) :: n private pure module subroutine realloc_2d_real(arr, n, m) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: arr (:,:) integer, intent(in) :: n integer, intent(in) :: m private pure module subroutine realloc_2d_cmplx(arr, n, m) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), allocatable :: arr (:,:) integer, intent(in) :: n integer, intent(in) :: m Functions public pure function unitary_defect (A) result(rF) Return the unitary defect with respect to the Frobenius norm Arguments Type Intent Optional Attributes Name class(*), intent(in) :: A (:,:) Return Value real(kind=dp) public pure function is_unitary (A, rtol) result(res) Determine whether a matrix is unitary w.r.t the Frobenius norm Arguments Type Intent Optional Attributes Name class(*), intent(in) :: A (:,:) The matrix real(kind=dp), intent(in), optional :: rtol The optional relative tolerance, default 1e-10 Return Value logical public pure function is_symmetric (A, rtol) result(res) Determine whether a matrix is symmetric Arguments Type Intent Optional Attributes Name class(*), intent(in) :: A (:,:) The matrix real(kind=dp), intent(in), optional :: rtol The optional relative tolerance, default 1e-10 Return Value logical public pure module function eye (n) result(res) Return an n x n identity matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer, (n,n) public pure module function uniq (arr) result(res) Returns the unique elements of arr Arguments Type Intent Optional Attributes Name integer, intent(in) :: arr (:) Return Value integer, allocatable, (:) Subroutines public pure module subroutine remove_value (arr, val) Remove all instances of the value val from the array arr Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: arr (:) integer, intent(in) :: val public pure module subroutine sort_index (vals, idx) Sort the array vals and return the permutation indices Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vals (:) integer, intent(out) :: idx (:)","tags":"","url":"module/rotex__arrays.html"},{"title":"rotex__system – ROTEX","text":"Contains the definitions of stdout, stdin, stderr, and procedures to interact with the program/system\nsuch as producing warnings and stopping the execution of the code while producing error messages Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: OS_ALL = -1 integer, public, parameter :: OS_UNKNOWN = 0 integer, public, parameter :: OS_LINUX = 1 integer, public, parameter :: OS_MACOS = 2 integer, public, parameter :: OS_WINDOWS = 3 integer, public, parameter :: OS_CYGWIN = 4 integer, public, parameter :: OS_SOLARIS = 5 integer, public, parameter :: OS_FREEBSD = 6 integer, public, parameter :: OS_OPENBSD = 7 logical, public :: OS_is_windows Is the current operating system Windows ? integer, public, parameter :: STDIN = input_unit The file unit associated with standard input integer, public, parameter :: STDOUT = output_unit The file unit associated with standard output integer, public, parameter :: STDERR = error_unit The file unit associated with standard error integer, public, parameter :: IOSTAT_OK = 0 The expected iostat result from a successful call to read() integer, public :: shell_ok The expected return value for the current environment and shell. Used in system calls. character(len=5), public, parameter :: PROGNAME = \"ROTEX\" The program name character(len=1), public :: DIRECTORY_SEPARATOR The OS-dependent directory separator Interfaces public        interface die private pure subroutine die_1(message) Stop program execution with a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message public        interface warn private  subroutine warn_1(message) Print a warning message, but don't stop the program's execution Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Functions public pure function OS_NAME (os) Arguments Type Intent Optional Attributes Name integer, intent(in) :: os Return Value character(len=:), allocatable Subroutines public  subroutine error (message) Print error messages to the screen without the WARNING prompt. This will typically precede a call to DIE Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message public  subroutine determine_system_properties () Detects the type of the operating system. As far as system calls and directory structure go,\nthis basically resolved to Windows or not Windows. Arguments None public  subroutine mkdir (directory) Makes the directory \"directory\" and checks that it exists and is writeable Arguments Type Intent Optional Attributes Name character(len=*) :: directory","tags":"","url":"module/rotex__system.html"},{"title":"rotex__utils – ROTEX","text":"Some small utilities Uses rotex__kinds Interfaces public        interface isint private pure elemental module function isint_r(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value logical private pure elemental module function isint_c(z) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value logical public        interface kbn_sum private pure elemental subroutine kbn_sum_rqp(summation, c, input) Improved Kahan-Babuška algorithm accumulation for summations Arguments Type Intent Optional Attributes Name real(kind=qp), intent(inout) :: summation real(kind=qp), intent(inout) :: c real(kind=qp), intent(in) :: input private pure elemental subroutine kbn_sum_cdp(summation, c, input) Improved Kahan-Babuška algorithm accumulation for summations Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: summation complex(kind=dp), intent(inout) :: c complex(kind=dp), intent(in) :: input private pure elemental subroutine kbn_sum_cqp(summation, c, input) Improved Kahan-Babuška algorithm accumulation for summations Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(inout) :: summation complex(kind=qp), intent(inout) :: c complex(kind=qp), intent(in) :: input public        interface downcast private pure elemental module subroutine downcast_r(hi, lo) Send the value of hi to lo, respecting the kind of the types Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: hi real(kind=dp), intent(out) :: lo private pure elemental module subroutine downcast_c(hi, lo) Send the value of hi to lo, respecting the kind of the types Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: hi complex(kind=dp), intent(out) :: lo public        interface upcast private pure elemental module subroutine upcast_r(lo, hi) Send the value of lo to hi, respecting the kind of the types Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lo real(kind=qp), intent(out) :: hi private pure elemental module subroutine upcast_c(lo, hi) Send the value of lo to hi, respecting the kind of the types Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lo complex(kind=qp), intent(out) :: hi public        interface printmat private module subroutine printmat_i(M, funit, header) Prints a matrix to the supplied funit, otherwise print to stdout Arguments Type Intent Optional Attributes Name integer, intent(in) :: M (:,:) integer, intent(in), optional :: funit character(len=*), intent(in), optional :: header private module subroutine printmat_r(M, funit, header) Prints a matrix to the supplied funit, otherwise print to stdout Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: M (:,:) integer, intent(in), optional :: funit character(len=*), intent(in), optional :: header private module subroutine printmat_c(M, funit, header) Prints a matrix to the supplied funit, otherwise print to stdout Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: M (:,:) integer, intent(in), optional :: funit character(len=*), intent(in), optional :: header Functions public pure elemental module function isin (x, xl, xr, lclosed, rclosed) result(res) Test whether x is in the interval spanned by x1,x2\nl/rclosed if true include xl and xr, respectively. They are true by default Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr logical, intent(in), optional :: lclosed logical, intent(in), optional :: rclosed Return Value logical Subroutines public pure elemental subroutine assert (test, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: test character(len=*), intent(in) :: message public  subroutine read_blank (read_unit, num_read) Reads num_read lines from unit read_unit, not storing any information. If num_read is not supplied, read one line. Arguments Type Intent Optional Attributes Name integer, intent(in) :: read_unit integer, intent(in), optional :: num_read","tags":"","url":"module/rotex__utils.html"},{"title":"rotex__splines – ROTEX","text":"Wrapper routines for the spline fitting procedures Subroutines public impure module subroutine interpolate_replace (xold, xnew, fx, idxx) Interpolate f(xold) -> f(xnew). Only consider xnew values that are contained within xold for now.\nXnew returns untouched, but fx is overwritten with interpolated values on the\ngrid xnew(idxx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xold (:) The grid of values on which our function has been evaluated real(kind=dp), intent(in) :: xnew (:) The new grid of values that we want our function to be evaluated on. real(kind=dp), intent(inout), allocatable :: fx (:) On input:  evaluated function f(xold)\nOn output: the evaluated function f(xnew) integer, intent(out), optional, allocatable :: idxx (:) The indices of values of xnew that are used to evaluate fx","tags":"","url":"module/rotex__splines.html"},{"title":"rotex__polygamma – ROTEX","text":"Routines for calculating Γ(z) and ln(Γ(z)). Uses rotex__kinds Interfaces public        interface gamma private impure elemental function gamma_cdp(z) result(res) MIT License Copyright (c) 2019-2021 stdlib contributors Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp) public        interface log_gamma private impure elemental function l_gamma_cdp(z) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: z Return Value complex(kind=dp)","tags":"","url":"module/rotex__polygamma.html"},{"title":"rotex__reading – ROTEX","text":"Contains procedures used in reading data (K-matrices and namelist data) Uses rotex__constants Subroutines public module subroutine read_kmats (kmat_dir, channels_dir, point_group, spinmult, kmat_lmax, Kmat, elec_channels, channel_E_units, kmat_eval_E_units, kmat_output_type, kmat_e_closest) Reads in a K-matrix from a file with a very particular file format given by kmat_output_type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kmat_dir Directory in which the files containing the K-matrices character(len=*), intent(in) :: channels_dir Directory in which the channel data are located character(len=*), intent(in) :: point_group The point group of the calculations integer, intent(in) :: spinmult The spin multiplicity (2S+1) of the system (target + e⁻) integer, intent(in) :: kmat_lmax The max value of l in the electronic partial wave basis real(kind=dp), intent(out), allocatable :: Kmat (:,:) K(i, j) type( elec_channel_type ), intent(out), allocatable :: elec_channels (:) The channel basis of the K-matrix: (the code calls λ ) character(len=1), intent(in) :: channel_E_units The units of the channel energies in the Kmat file. Options are :\n - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV character(len=1), intent(in) :: kmat_eval_E_units The units of the energy at which the K-matrix was evaluated in the Kmat file. Options are :\n - \"h\" for hartree\n - \"e\" for eV\n - \"r\" for Rydberg character(len=*), intent(in) :: kmat_output_type The kind of K-matrix output to read real(kind=dp), intent(in) :: kmat_e_closest Evaluate the K-matrix that is closest to this energy public  subroutine read_namelists (cfg) Reads user parameters and puts them into the config derived type\n Contains parameters and values that are necessary to run the program Read more… Arguments Type Intent Optional Attributes Name type( config_type ), intent(out) :: cfg","tags":"","url":"module/rotex__reading.html"},{"title":"rotex__symmetry – ROTEX","text":"All things related to symmetry Variables Type Visibility Attributes Name Initial integer, public, allocatable, save :: m_parity (:) Array containing the parity (1/even or -1/odd) of an electronic channel\nbased on its label m. This array is indexed by m directly. This is only\nfor calculation in the Cs point group integer, public, parameter :: Ap = 1 integer, public, parameter :: App = 2 integer, public, parameter :: Ag = 1 integer, public, parameter :: Au = 2 integer, public, parameter :: Bg = 3 integer, public, parameter :: Bu = 4 integer, public, parameter :: A = 1 integer, public, parameter :: A1 = 1 integer, public, parameter :: A2 = 4 integer, public, parameter :: B = 2 integer, public, parameter :: B1 = 2 integer, public, parameter :: B2 = 3 integer, public, parameter :: B3 = 4 integer, public, parameter :: B1g = 3 integer, public, parameter :: B1u = 4 integer, public, parameter :: B2g = 5 integer, public, parameter :: B2u = 6 integer, public, parameter :: B3g = 7 integer, public, parameter :: B3u = 8 integer, public, parameter :: even = 1 integer, public, parameter :: odd = -1 Interfaces public        interface is_spin_allowed private pure elemental module function is_spin_allowed_chan(channel1, channel2, spin_isomer_kind, symaxis) result(res) Test if two rotational channels respect ortho/para symmetry Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_type ), intent(in) :: channel1 type( asymtop_rot_channel_type ), intent(in) :: channel2 integer, intent(in) :: spin_isomer_kind character(len=1), intent(in) :: symaxis Return Value logical private pure elemental module function is_spin_allowed_qnums(nlo, kalo, kclo, nup, kaup, kcup, kind, symaxis) result(res) Determine if the transition Nlo,Kalo,Kclo -> Nup,Kaup,Kcup is allowed by nuclear spin symmetry\nselection rules Arguments Type Intent Optional Attributes Name integer, intent(in) :: nlo integer, intent(in) :: kalo integer, intent(in) :: kclo integer, intent(in) :: nup integer, intent(in) :: kaup integer, intent(in) :: kcup integer, intent(in) :: kind character(len=1), intent(in) :: symaxis Return Value logical public        interface is_spin_forbidden private pure elemental module function is_spin_forbidden_chan(channel1, channel2, spin_isomer_kind, symaxis) result(res) Test if two rotational channels respect ortho/para symmetry Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_type ), intent(in) :: channel1 type( asymtop_rot_channel_type ), intent(in) :: channel2 integer, intent(in) :: spin_isomer_kind character(len=1), intent(in) :: symaxis Return Value logical private pure elemental module function is_spin_forbidden_qnums(nlo, kalo, kclo, nup, kaup, kcup, kind, symaxis) result(res) Determine if the transition Nlo,Kalo,Kclo -> Nup,Kaup,Kcup is forbidden by nuclear spin symmetry\nselection rules Arguments Type Intent Optional Attributes Name integer, intent(in) :: nlo integer, intent(in) :: kalo integer, intent(in) :: kclo integer, intent(in) :: nup integer, intent(in) :: kaup integer, intent(in) :: kcup integer, intent(in) :: kind character(len=1), intent(in) :: symaxis Return Value logical Functions public pure module function group_size (point_group) result(n) Return the number of elements in point_group Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: point_group Return Value integer public pure module function irrep_name (irrep, point_group) result(output) Given an irrep index in point_group, return the name of the corresponding irrep Arguments Type Intent Optional Attributes Name integer, intent(in) :: irrep character(len=*), intent(in) :: point_group Return Value character(len=:), allocatable public pure module function possible_spin_symmetries (kind) result(res) Returns an array of possible spin symmetry values Arguments Type Intent Optional Attributes Name integer, intent(in) :: kind Return Value integer, allocatable, (:) public pure elemental module function spin_symmetry (n, ka, kc, kind, symaxis) result(res) Returns the spin symmetry of the current N, Ka, Kc state Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: ka integer, intent(in) :: kc integer, intent(in) :: kind character(len=1), intent(in) :: symaxis Return Value integer Subroutines public pure module subroutine get_group_irreps (point_group, irreps) Given the point group, output an array containing the names of the irreps in the supplied point_group.\nOnly Abelian point groups are considered. Irreps in the code will be referred to by their indicies Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: point_group character(len=:), intent(out), allocatable :: irreps (:)","tags":"","url":"module/rotex__symmetry.html"},{"title":"rotex__progress – ROTEX","text":"Interface to forbear , the Fortran (progress) B(e)ar environment Uses forbear","tags":"","url":"module/rotex__progress.html"},{"title":"rotex__types – ROTEX","text":"Contains type definitions and procedures for those types used throughout the program Uses rotex__constants rotex__kinds Interfaces public        interface sort_channels private impure module subroutine sort_elec_channels(elec_channels) Sorts the inout array based on the quantum numbers of the channels Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout) :: elec_channels (:) public        interface permsort_channels private impure module subroutine permsort_elec_channels(elec_channels, idx) Sorts the inout array based on the quantum numbers of the channels, and returns\nthe permutation array that would produce the same output Arguments Type Intent Optional Attributes Name type( elec_channel_type ), intent(inout) :: elec_channels (:) integer, allocatable :: idx (:) public        interface operator(.eq.) private pure elemental module function channel_iseq(channel1, channel2) result(res) Test for channel equality on the basis of their quantum numbers only Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channel1 class( channel_type ), intent(in) :: channel2 Return Value logical private pure elemental module function transition_iseq(transition1, transition2) result(res) Test if two transitions are equal Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(in) :: transition1 type( asymtop_rot_transition_type ), intent(in) :: transition2 Return Value logical public        interface operator(.ne.) private pure elemental module function channel_isne(channel1, channel2) result(res) Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channel1 class( channel_type ), intent(in) :: channel2 Return Value logical public        interface operator(.isin.) private pure module function channel_isin(channel, channels) result(res) Check if a channel is in the array channels Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channel class( channel_type ), intent(in) :: channels (:) Return Value logical private pure module function transition_isin(transition, transitions) result(res) Check if a transition is in the array transitions Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(in) :: transition type( asymtop_rot_transition_type ), intent(in) :: transitions (:) Return Value logical public        interface assignment(=) private impure elemental module subroutine channel_set_eq(channel_out, channel_in) Sets the channel left equal to the channel right Arguments Type Intent Optional Attributes Name class( channel_type ), intent(out) :: channel_out class( channel_type ), intent(in) :: channel_in Derived Types type, public :: eigenH_type Contains the eigenvectors and eigenvalues of a hamiltonian Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: eigvals (:) real(kind=dp), public, allocatable :: eigvecs (:,:) type, public :: N_states_type The rotational state of the system described by its eigenvectors, eigenvalues,\nand state labels Components Type Visibility Attributes Name Initial integer, public :: N type( eigenH_type ), public :: eigenH The decomposed Hamiltonian for this rotational level integer, public, allocatable :: Ka (:) The projections Ka integer, public, allocatable :: Kc (:) The projections Kc real(kind=dp), public, allocatable :: EinstA (:) The Einstein coefficients for transitions to all lower states (0 if none) type, public, abstract :: channel_type |nelec> (E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy type, public, extends( channel_type ) :: elec_channel_type Describes the electronic channel basis of the (optional) K and S-matrices by adding l and its projection ml\n|nelec,l,ml> (iq, E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy integer, public :: l Partial wave degree integer, public :: ml Partial wave order (projection on body-frame ẑ-axis) integer, public :: iq = IQ_DEFAULT The kind of normalization for the Coulomb f/g functions:\n  4: usual normalization\n  0: f₀/g₀ normalization type, public, extends( channel_type ) :: asymtop_rot_channel_type Describes the rotational and electronic channel basis of the (optional) S-matrix\nafter the rotational frame transformation by adding the and rotational quantum numbers to the channel type\n|nelec,N,Ka,Kc> (E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy integer, public :: N The rotatinal quantum number of the target integer, public :: Ka The projection Ka of N integer, public :: Kc The projection Kc of N integer, public :: sym The nuclear spin symmetry type, public, extends( asymtop_rot_channel_type ) :: asymtop_rot_channel_l_type Describes the rotational and electronic channel basis of the (optional) S-matrix\nafter the rotational frame transformation by adding the partial wave degree\nto the rotational quantum numbers\n|nelec,l,N,Ka,Kc> (iq, E) Components Type Visibility Attributes Name Initial integer, public :: nelec Electronic state real(kind=dp), public :: E The channel energy integer, public :: N The rotatinal quantum number of the target integer, public :: Ka The projection Ka of N integer, public :: Kc The projection Kc of N integer, public :: sym The nuclear spin symmetry integer, public :: l Partial wave degree integer, public :: iq The kind of normalization for the Coulomb f/g functions:\n  4: usual normalization\n  0: f₀/g₀ normalization type, public :: asymtop_rot_channel_l_vector_type Contains a vector of channels. The idea is that this type is indexed at\neach value of the angular momentum quantum number J, for which a different\ncombination of channels exists than for other Js Components Type Visibility Attributes Name Initial type( asymtop_rot_channel_l_type ), public, allocatable :: channels (:) type, public :: asymtop_rot_transition_type The a type containing the indices for a pair of initial and final rotational states Components Type Visibility Attributes Name Initial type( asymtop_rot_channel_type ), public :: lo type( asymtop_rot_channel_type ), public :: up type, public :: ivector_type The type of an integer vector Components Type Visibility Attributes Name Initial integer, public, allocatable :: vec (:) type, public :: rvector_type The type of a real vector Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: vec (:) type, public :: rmatrix_type The type of a real matrix Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: mtrx (:,:) type, public :: cmatrix_type The type of a complex matrix Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: mtrx (:,:) type, public :: cd4_type Centrifugal Distortion parameters for quartric (4) order Components Type Visibility Attributes Name Initial real(kind=dp), public :: dn ΔN  (AKA ΔJ) real(kind=dp), public :: dnk ΔNK (AKA ΔJK) real(kind=dp), public :: dk ΔK real(kind=dp), public :: deltan δn  (AKA δJ) real(kind=dp), public :: deltak δK type, public :: cd6_type Centrifugal Distortion parameters for sextic (6) order Components Type Visibility Attributes Name Initial real(kind=dp), public :: hn HN   (N²)³ real(kind=dp), public :: hnk HNK [(N²)² Nz²] real(kind=dp), public :: hkn HKN [ N²   Nz⁴] real(kind=dp), public :: hk HK         Nz⁶ real(kind=dp), public :: etan ηN  [N⁴,    (J₊)²+(J₋)²]₊ / 2 real(kind=dp), public :: etank ηNK [N²Nz², (J₊)²+(J₋)²]₊ / 2 real(kind=dp), public :: etak ηK  [Nz⁴,   (J₊)²+(J₋)²]₊ / 2 type, public :: config_type Derived type containing data from the namelist variables Components Type Visibility Attributes Name Initial logical, public :: add_cd4 = .true. Add centrifugal distortion for fourth order ? logical, public :: add_cd6 = .true. Add centrifugal distortion for sixth order ? logical, public :: only_einsta Whether to only calculate the Einstein A coefficients in the Coulomb-Born\ncross section routine logical, public :: use_CDMS_einstA Whether to use Einstein A coefficients obtained from the CDMS or calculate them ourselves\nPath for the file containing the CDMS data to be read (if use_CDMS_einstA is .true.) logical, public :: analytic_total_cb (2) Array of logicals that has the size 2. Choose whether to use the analytic equation\ndescribing the multipole expansions for the dipole (element 1) and the quadrupole (element 2, not yet available) logical, public :: do_xtrap Do the extrapolation of (de-)excitation cross sections as 1/E to the excitation threshold ? logical, public :: do_dipole Choose whether to use the dipole term of the potential expansion logical, public :: do_quadrupole Choose whether to use the quadrupole term of the potential expansion logical, public :: use_kmat Calculate (de-)excitation cross sections using precomputed K-matrices ? logical, public :: use_cb Calculate (de-)excitation cross sections using the Coulomb-Born approxiation ? logical, public :: real_spherical_harmonics Whether the input K-matrices are evaluated in a basis of real spherical harmonics\nfor the scattering electron. If .true., it will be transformed to a basis of\ncomplex-valued spherical harmonics integer, public :: spin_isomer_kind Whether and how to enforce ortho/para symmetry for molecules with identical nuclei.\n  0: don't\n  2: C2v rotor (H₂X-like): preserve Ka+Kc parity\nNote that this just disables certain transitions from bein calculated\nin the CB approx as well as from the S-matrix. This does not affect\nthe RFT because higher J-blocks of the S-matrix are more affected\nby K-mixing (Ka and Kc are not exact quantum numbers) integer, public :: nE The number of scattering energies to consider. This does not need to be very high; the CB\ncross sections are very smooth and can easily be interpolated. integer, public :: nE_xtrap Number of extrapolation energies. Excitation cross sections are extrapolated as 1/E to the excitation threshold,\nde-excitation cross sections are extrapolated as 1/E to Ei_xtrap. If this is 0, no exptrapolation will be performed. integer, public :: lmax_partial The maximum value of l to consider in the contribution of the partial CB cross section\nfrom the dipole and the quadrupole. If you're replacing the low-l CB cross sections\nwith other cross sections, set this to the max l that you have available. integer, public :: lmax_total The maximum value of l to consider in the contribution of the total CB cross section\nin the even that you're not using the analytic expression,\nfrom the dipole  and the quadrupole integer, public :: Nmin The minimum value of the rotational quantum number (N) to consider integer, public :: Nmax The maximum value of the rotational quantum number (N) to consider integer, public :: target_charge The electric charge of the target integer, public :: lmax_kmat The max partial wave to be included in the K-matrix basis. Cannot exceed the available\nbasis in the calculation, but can be smaller than the largest available partial wave integer, public :: num_egrid_segs Number of energy grid segments (evaluation energy for the cross sections) integer, public, allocatable :: num_egrid (:) Array of number of energies per grid segment (length num_egrid_segs) integer, public, allocatable :: spinmults (:) Array of spin multiplicities (2S+1) for which the system's (target + e⁻) K-matrices were calculated real(kind=dp), public :: xs_zero_threshold Any cross section with value only smaller than this (cm²) will\nbe ignore and will not be printed real(kind=dp), public :: Ei The first electron energy for excitation to consider relative to the initial state's energy real(kind=dp), public :: Ef The last  electron energy for excitation to consider relative to the initial state's energy real(kind=dp), public :: Ei_xtrap The lowest electron energy for de-excitation relative to the initial state's energy.\nThe results will be extrapolated from Ei down to this assuming a 1/E dependence for the\ncross section, i.e., constant excitation probablility. If this .le. 0, no extrapolation will not be performed.\nUnits: (eV) real(kind=dp), public :: kmat_energy_closest Input K-matrices are evaluated at a specific energy. If this code is run energy-independently\n(most likely the case unless I add energy dependence in the future) The K-matrix that is\nselected will be the FIRST ONE whose evaluation energy is CLOSEST to this energy in (eV).\nNOTE: UKRMOL+ outputs K-matrix energies in the .kmat files in Rydberg. real(kind=dp), public :: abc (3) Array of reals of length 3\nThe rotational constants A, B, and C of the target molecule (cm⁻¹). real(kind=dp), public :: cartesian_dipole_moments (3) Array of cartesian dipole moments (Debye)\nin the order dx, dy, dz real(kind=dp), public :: cartesian_quadrupole_moments (6) Array of cartesian quadrupole moments (Debye)\nin the order Qxx, Qxy, Qxz, Qyy, Qyz, Qzz real(kind=dp), public, allocatable :: egrid_segs (:) Array of the bounds (non-degenerate) of the energy grid segments (length num_egrid_segs + 1) character(len=1), public :: rotor_kind The kind of rotor that describes the targer. Character(1).\nChoice of :\n \"l\"inear\n \"a\"symmetric top\n \"s\"ymmetric  top character(len=1), public :: zaxis The molecular axis (a, b, or c) along which the z-axis is oriented This should also be the symmetry axis character(len=1), public :: channel_energy_units_override The units of the channel energies in the file that holds channels. Options are :\n - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV\nBy default, this is not set and will allow the code to determine\nchannel energies on its own based on KMAT_OUTPUT_TYPE, but can\nbe forcibly overridden with this character(len=1), public :: kmat_energy_units_override The units of the K-matrix evaluation energies in the kmat file. Options are :\n - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV\nBy default, this is not set and will allow the code to determine\nchannel energies on its own based on KMAT_OUTPUT_TYPE, but can\nbe forcibly overridden with this character(len=3), public :: egrid_spacing The kind of spacing for the energy grid segments. \"lin\" for linear and \"log\" for logarithmic character(len=:), public, allocatable :: point_group The point group in which the K-matrices were calculated character(len=:), public, allocatable :: kmat_dir Path for the file containing the K-matrix to be read. Absolute or relative character(len=:), public, allocatable :: channels_dir Path for the file containing the channels for the K-matrix to be read. Absolute or relative\nThis is only used if kmat_output_type is ukrmol+ because the channel and K-matrix files are separate character(len=:), public, allocatable :: output_directory The directory in which to write the output data\nThis directory must already exist character(len=:), public, allocatable :: CDMS_file The file containing CDMS transitions character(len=7), public :: kmat_output_type Determines what kind of K-matrices we're reading. Two possible values:\n  'UKRMOL+': default UKRmol+ .kmat file\n  'MQDTR2K': a specific format given in the writeup. K-matrices are generated\n    directly from the R-matrix, possibly with channel elimination and differently\n    normalized Coulomb wavefunctions type( cd4_type ), public :: cd4 Centrifugal distortion parameters (4th order) for the rigid rotor Hamiltonian correction type( cd6_type ), public :: cd6 Centrifugal distortion parameters (6th order) for the rigid rotor Hamiltonian correction Functions public pure module function get_channel_index (channels, channel, reverse) result(i) Return the first index i where channel .eq. channels(i) is .true., or\nthe last index is reverse is .true. Arguments Type Intent Optional Attributes Name class( channel_type ), intent(in) :: channels (:) class( channel_type ), intent(in) :: channel logical, intent(in), optional :: reverse Return Value integer public impure elemental module function trim_channel_l (channel_with_l) result(channel_without_l) Given a rotational channel with the l quantum number, return the equvalent channel without the l quantum number Arguments Type Intent Optional Attributes Name type( asymtop_rot_channel_l_type ), intent(in) :: channel_with_l Return Value type( asymtop_rot_channel_type ) public pure module function findloc_transitions (targs, search) result(idxtarg) Find the indices for each element in targs that map to the elements in search.\nReturn 0 if there is no such mapping. Arguments Type Intent Optional Attributes Name type( asymtop_rot_transition_type ), intent(in) :: targs (:) type( asymtop_rot_transition_type ), intent(in) :: search (:) Return Value integer, allocatable, (:) TARGS -> SEARCH mapping Subroutines public impure module subroutine sort_channels_by_energy (channels) Bubble sort the array of channels such that the channel energies are in ascending order Arguments Type Intent Optional Attributes Name class( channel_type ), intent(inout) :: channels (:)","tags":"","url":"module/rotex__types.html"},{"title":"rotex – ROTEX","text":"Uses rotex__RFT rotex__hamilton rotex__reading rotex__types rotex__drivers rotex__system The main program Variables Type Attributes Name Initial integer :: jmin The min/max values of J = N + l to consider integer :: jmax The min/max values of J = N + l to consider integer :: nmin_ft The min/max values of N to consider for the frame transformation. integer :: nmax_ft The min/max values of N to consider for the frame transformation. integer :: i_n integer :: num_n integer, allocatable :: N_values (:) Contains the values of N to consider real(kind=dp) :: start real(kind=dp) :: finish real(kind=dp) :: Eground real(kind=dp), allocatable :: egrid_tot_smat (:) The total energy grid for the S-matrix calculations character(len=:), allocatable :: pcb_output_directory character(len=:), allocatable :: tcb_output_directory character(len=:), allocatable :: smat_output_directory type( N_states_type ), allocatable :: n_states (:) The states of the system for a given N type( asymtop_rot_transition_type ), allocatable :: transitions_cb (:) type( asymtop_rot_transition_type ), allocatable :: transitions_smat (:) type( rvector_type ), allocatable :: Eel_grid_cb (:) Array of arrays of electron/collision energies for each transition type( rvector_type ), allocatable :: xs_xcite_tcb (:) Array of arrays of the Total and Partial Coulomb-Born cross sections for each transition type( rvector_type ), allocatable :: xs_xcite_pcb (:) Array of arrays of the Total and Partial Coulomb-Born cross sections for each transition type( rvector_type ), allocatable :: xs_xcite_smat (:) type( rvector_type ), allocatable :: xs_dxcite_smat (:) type( config_type ) :: cfg Subroutines subroutine print_header () Arguments None subroutine print_footer (time_start, time_end) Arguments Type Intent Optional Attributes Name real(kind=dp) :: time_start real(kind=dp) :: time_end subroutine print_rot_targ_states (n_states) Arguments Type Intent Optional Attributes Name type( N_states_type ), intent(in) :: n_states (:) subroutine print_dipoles (dipole_xyz, x, y, z) Print the dipole components in the determined ABC frame Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dipole_xyz (3) character(len=1), intent(in) :: x character(len=1), intent(in) :: y character(len=1), intent(in) :: z","tags":"","url":"program/rotex.html"},{"title":"rotex__hypergeometric.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__hypergeometric !! For calculating the Gauss hypergeometric function ₂F₁(a,b;c;z) use rotex__kinds , only : dp , qp use rotex__constants , only : macheps_dp implicit none private public :: f21 public :: f21_dispatch public :: f21_ts ! public :: f21_ode_eval real ( dp ), parameter :: TS_DEFAULT_TOLERANCE = macheps_dp ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental function f21_dispatch ( za , zb , zc , z , ts_tol ) result ( res ) !! Checks if x is indeed in (0,1/2), and then makes a choice of evaluating the ODE (large a,b,c) !! or defaulting to the usual Taylor series use rotex__utils , only : isin use rotex__constants , only : ABC_THRESHOLD => HYPGEO_ABC_THRESHOLD use rotex__system , only : die , stderr implicit none complex ( dp ), intent ( in ) :: za complex ( dp ), intent ( in ) :: zb complex ( dp ), intent ( in ) :: zc complex ( dp ), intent ( in ) :: z real ( dp ), intent ( in ), optional :: ts_tol complex ( dp ) :: res logical :: bigabc real ( dp ) :: x , ts_tol_ !! The tolerance for which  \\frac{ \\left\\lvert S_{N+1} - S_{N} \\right\\rvert }{ \\left\\lvert S_N \\right\\rvert } !! must be met for the series to be considered converged. If this is not supplied, this value will be taken !! to be machine epsilon `macheps_dp` from the `hypergeometric__constants` module. ! -- argument in range if ( z % im . ne . 0._dp ) then write ( stderr , '(\"Im(Z): \", e20.10)' ) z % im call die ( \"Z is nonreal in F21_DISPATCH !\" ) endif x = z % re if ( isin ( x , 0._dp , 0.5_dp , lclosed = . false ., rclosed = . true .) . eqv . . false .) then write ( stderr , '(\"Re(Z): \", e20.10)' ) x call die ( \"Re(Z) must be between 0 and 1/2 in F21_DISPATCH\" ) endif ! -- size check on a, b, c bigabc = abs ( za ) . ge . ABC_THRESHOLD . OR . abs ( zb ) . ge . ABC_THRESHOLD . OR . abs ( zc ) . ge . ABC_THRESHOLD ! -- ODE if a, b, c too big if ( bigabc ) then ! res = f21_ode_eval(za, zb, zc, x) write ( stderr , '(\"WARN: Large value of a parameter detected ! The electron energy& & is probably very close to a threshold, resulting in very large η=-Z/k.\")' ) write ( stderr , '(\"      |A|: \", F7.3)' ) abs ( za ) write ( stderr , '(\"      |B|: \", F7.3)' ) abs ( zb ) write ( stderr , '(\"      |C|: \", F7.3)' ) abs ( zc ) ! res = f21_ode_eval(za, zb, zc, x) ts_tol_ = TS_DEFAULT_TOLERANCE ; if ( present ( ts_tol )) ts_tol_ = ts_tol res = f21_ts ( za , zb , zc , z , ts_tol_ ) return endif ! -- Taylor series otherwise ts_tol_ = TS_DEFAULT_TOLERANCE ; if ( present ( ts_tol )) ts_tol_ = ts_tol res = f21_ts ( za , zb , zc , z , ts_tol_ ) end function f21_dispatch ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function f21_ts ( a , b , c , z , tol ) result ( res ) !! Returns the Gauss hypergeometric function ₂F₁(a,b,;c;z via a Taylor series method, with quad precision use rotex__utils , only : downcast , upcast , kbn_sum , isint use rotex__system , only : die use rotex__constants , only : macheps => macheps_dp , zero , one implicit none complex ( dp ), intent ( in ) :: a complex ( dp ), intent ( in ) :: b complex ( dp ), intent ( in ) :: c complex ( dp ), intent ( in ) :: z real ( dp ), intent ( in ), optional :: tol !! The tolerance for which  \\frac{ \\left\\lvert S_{N+1} - S_{N} \\right\\rvert }{ \\left\\lvert S_N \\right\\rvert } !! must be met for the series to be considered converged. If this is not supplied, this value will be taken !! to be machine epsilon `macheps_dp` from the `hypergeometric__constants` module. complex ( dp ) :: res integer , parameter :: kmax = 20000 real ( dp ) :: tol_local real ( qp ) :: tol_local_qp integer :: k real ( qp ) :: kq complex ( qp ) :: r complex ( qp ) :: aa , bb , cc , zz complex ( qp ) :: numer , denom complex ( qp ) :: sumq , diff , comp tol_local = TS_DEFAULT_TOLERANCE ; if ( present ( tol )) tol_local = tol call upcast ( tol_local , tol_local_qp ) ! -- terminating seris -> calculate exactly if ( isint ( a ) . AND . nint ( a % re ) . lt . 0 ) then res = f21_finite ( a , b , c , z ) return elseif ( isint ( b ) . AND . nint ( b % re ) . lt . 0 ) then res = f21_finite ( a , b , c , z ) return endif ! -- upcast to quad precision call upcast ( a , aa ) call upcast ( b , bb ) call upcast ( c , cc ) call upcast ( z , zz ) sumq = 1 comp = 0 diff = 1 k = 0 do k = k + 1 kq = real ( k , kind = qp ) numer = ( aa + kq - 1._qp ) * ( bb + kq - 1._qp ) denom = kq * ( cc + kq - 1_qp ) r = numer / denom diff = diff * r * zz call kbn_sum ( sumq , comp , diff ) if ( abs ( diff ) . le . tol_local_qp * abs ( sumq ) ) exit if ( k . lt . kmax ) cycle call die ( \"k = kmax has been achieved without convergence in gauss_2f1_ts\" ) enddo ! -- downcast to double precision for return value call downcast ( sumq + comp , res ) end function f21_ts ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental module function f21 ( a , b , c , x ) result ( res ) !! Returns one of the following transforms !!   1. ₂F₁(a,b;c;x) = (1-x)&#94;{-b} ₂F₁(b,c-a;c;x/(x-1)) !!   2. ₂F₁(a,b;c;x) = (1-x)&#94;{-a} ₂F₁(a,c-b;c;x/(x-1)) !!   3. ₂F₁(a,b;c;x) = (1-x)&#94;{-a} Γ(c)Γ(b-a)/(Γ(b)Γ(c-a)) ₂F₁(a,c-b;a-b+1;1/(1-x)) !!                   + (1-x)&#94;{-b} Γ(c)Γ(a-b)/(Γ(a)Γ(c-b)) ₂F₁(b,c-a;b-a+1;1/(1-x)) !!   4. ₂F₁(a,b;c;x) =               Γ(c)Γ(c-a-b)/Γ(c-a)Γ(c-b) ₂F₁(c-a, c-b, c-a-b+1, 1-x) !!                   + (1-x)&#94;(c-a-b) Γ(c)Γ(a+b-c)/Γ(a)Γ(b)     ₂F₁(c-a,c-b;c-a-b+1;1-x) !! Regions of validity: !!   1. |a| < |b|, -1 ≤ x < 0 !!   2. |a| > |b|, -1 ≤ x < 0 !!   3. -∞ < x < -1 !!   4. ½ < x < 1 !! !! Assumes that x is on the real axis use rotex__utils , only : isint use rotex__system , only : die use rotex__functions , only : inv use rotex__polygamma , only : lgamma => log_gamma implicit none complex ( dp ), intent ( in ) :: a , b , c real ( dp ), intent ( in ) :: x complex ( dp ) :: res complex ( dp ) :: wx complex ( dp ) :: zx if ( isint ( c ) . eqv . . true .) then if ( nint ( c % re ) . lt . 1 ) call die ( \"Hypergeometric function not not defined for c = 0, -1, -2, ..\" ) endif if ( x . ge . 1 ) call die ( \"Hypergeometric function got x > 1, which shouldn't happen..\" ) zx = cmplx ( x , kind = dp ) ! -- transform closer to 0 for better convergence if ( x . gt . 0.5_dp ) then wx = 1._dp - zx res = exp ( lgamma ( c ) + lgamma ( c - a - b ) - lgamma ( c - a ) - lgamma ( c - b )) * f21_dispatch ( a , b , a + b - c + 1 , wx ) & + exp (( c - a - b ) * lgamma ( 1 - x ) + lgamma ( c ) + lgamma ( a + b - c ) - lgamma ( a ) - lgamma ( a )) * f21_dispatch ( c - a , c - b , c - a - b + 1._dp , wx ) return ! -- 0 < x ≤ ½ elseif ( x . gt . 0.0_dp ) then ! res = michelf21(a, b, c, zx) res = f21_dispatch ( a , b , c , zx ) return endif ! -- -1 ≤ x < 0 if ( x . ge . - 1 ) then wx = cmplx ( x / ( x - 1 ), 0.0_dp , kind = dp ) if ( abs ( a ) . lt . abs ( b )) then ! res = (1-zx)**(-b) * michelf21(b, c-a, c, wx) res = ( 1 - zx ) ** ( - b ) * f21_dispatch ( b , c - a , c , wx ) else ! res = (1-zx)**(-a) * michelf21(a, c-b, c, wx) res = ( 1 - zx ) ** ( - a ) * f21_dispatch ( a , c - b , c , wx ) endif return endif ! -- -∞ < x < -1 wx = cmplx ( inv ( 1 - x ), 0.0_dp , kind = dp ) res = exp ( - a * log ( 1 - x ) + lgamma ( c ) + lgamma ( b - a ) - lgamma ( b ) - lgamma ( c - a )) * f21_dispatch ( a , c - b , a - b + 1 , wx ) & + exp ( - b * log ( 1 - x ) + lgamma ( c ) + lgamma ( a - b ) - lgamma ( a ) - lgamma ( c - b )) * f21_dispatch ( b , c - a , b - a + 1 , wx ) end function f21 ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function f21_finite ( a , b , c , z ) result ( res ) !! Calculate the finite sum of ₂F₁(a,b;c;z) when a or b is a negative integer because the !! rising factorial will eventually be 0 use rotex__utils , only : isint , kbn_sum use rotex__system , only : die , stderr implicit none complex ( dp ), intent ( in ) :: a , b , c , z complex ( dp ) :: res , Sk , comp integer :: n , m , nc integer :: k n = 1 m = 1 if ( isint ( a )) n = nint ( a % re ) if ( isint ( b )) m = nint ( b % re ) if ( n . lt . 0 . AND . m . lt . 0 ) then n = max ( n , m ) elseif ( n . lt . 0 . neqv . m . lt . 0 ) then n = min ( n , m ) else call die ( \"Finite 2F1 will not be finite because n and m are both positive\" ) endif ! -- poch(c) might terminate before n terms, so guard against that ccheck : if ( isint ( c )) then nc = nint ( c % re ) if ( nc . gt . 0 ) exit ccheck if ( abs ( n ) . gt . abs ( nc )) & call die ( \"Finite ₂F₁ hits a pole of poch(c), because c is a negative integer close to 0 than a or b\" ) endif ccheck Sk = 1 res = Sk comp = 0 do k = 1 , abs ( n ) Sk = Sk * ( a + k - 1 ) * ( b + k - 1 ) / (( c + k - 1 ) * real ( k , kind = dp )) * z call kbn_sum ( res , comp , Sk ) end do res = res + comp end function f21_finite ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure subroutine f21_ode_rhs(x, y, a, b, c, dydx) !   !! y(1)    = y  ; y(2)    = y' !   !! dydx(1) = y' ; dydx(2) = y'' !   use rotex__system, only: die !   implicit none !   real(dp),    intent(in)  :: x !   complex(dp), intent(in)  :: y(2) !   complex(dp), intent(in)  :: a, b, c !   complex(dp), intent(out) :: dydx(2) !   complex(dp) :: denom !   denom = cmplx(x*(1.0_dp - x), 0.0_dp, kind=dp) !   if(abs(denom) .eq. 0) call die(\"x = 0 or 1 detected // illegal value\") !   dydx(1) = y(2) !   dydx(2) = ( -(c - (a+b+1.0_dp)*x)*y(2) + a*b*y(1) ) / denom ! end subroutine f21_ode_rhs ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure subroutine get_hypgeo_ode_matrix(x, a, b, c, M) !   !! Set up the 2 x 2 ODE matrix !   !!  |       0     ;      1                 | !   !!  | ab/[x(1-x)] ;-[c-(a+b+1)x]/[x(1-x)] | !   !! Solve the 2x2 matrix equation M !   use rotex__system, only: die !   implicit none !   real(dp),    intent(in)  :: x !   complex(dp), intent(in)  :: a, b, c !   complex(dp), intent(out) :: M(2,2) !   complex(dp) :: denom !   denom = cmplx(x*(1.0_dp - x), 0.0_dp, kind=dp) !   if(abs(denom) .eq. 0) call die(\"x = 0 or 1 detected // illegal value\") !   M(1,1) = 0.0_dp !   M(2,1) = (a*b)/denom !   M(1,2) = (1.0_dp, 0.0_dp) !   M(2,2) = -( c - (a+b+1.0_dp)*x ) / denom ! end subroutine get_hypgeo_ode_matrix ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure subroutine solve2x2(m, b, x) !   !! Solve the 2x2 matrix equation Mx = b !   implicit none !   complex(dp), intent(in)  :: m(2,2), b(2) !   complex(dp), intent(out) :: x(2) !   complex(dp) :: det !   det  = m(1,1)*m(2,2) - m(1,2)*m(2,1) !   x(1) = (  m(2,2)*b(1) - m(1,2)*b(2) ) / det !   x(2) = ( -m(2,1)*b(1) + m(1,1)*b(2) ) / det ! end subroutine solve2x2 ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure subroutine step_midpt(xn, h, a, b, c, Yn, Ynp1) !   !! Implicit midpoint !   !!   (I - (h/2)*Amid)Ynp1 = (I + (h/2)*Amid )Yn; Amid = A(xn + h/2) !   implicit none !   real(dp), intent(in) :: xn !     !! The point x(n) !   real(dp), intent(in) :: h !     !! Step size !   complex(dp), intent(in) :: a, b, c !     !! Hypergeometric function parameters !   complex(dp), intent(in) :: Yn(2) !     !! Solution vector y(n) !   complex(dp), intent(out) :: Ynp1(2) !     !! Solution vector y(n+1) at the next step !   complex(dp) :: Amid(2,2), I(2,2), M1(2,2), M2(2,2), rhs(2) !   real(dp) :: xmid !   complex(dp), parameter :: one  = (1.0_dp, 0.0_dp) !   complex(dp), parameter :: zero = (0.0_dp, 0.0_dp) !   xmid = xn + 0.5_dp*h !   call get_hypgeo_ode_matrix(xmid, a, b, c, Amid) !   I = reshape([one, zero, zero, one], [2,2]) !   M1 = I - 0.5_dp*h*Amid !   M2 = I + 0.5_dp*h*Amid !   rhs = matmul(M2, Yn) !   call solve2x2(M1, rhs, Ynp1) ! end subroutine step_midpt ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure subroutine f21_seed_series(a, b, c, x0, f0, fp0, tol) !   !! Seed the ₂F₁ hypergeometric series starting from x0 !   use rotex__utils,     only: kbn_sum !   use rotex__system,    only: die !   use rotex__constants, only: macheps_dp !   implicit none !   complex(dp), intent(in) :: a, b, c !     !! Hypergeometric function parameters !   real(dp), intent(in) :: x0 !     !! The starting point !   complex(dp), intent(out) :: f0, fp0 !     !! Initial values for ₂F₁(a,b,c,x0) and its derivative !   real(dp), intent(in), optional :: tol !   integer,     parameter :: NMAX = 20000 !   real(dp),    parameter :: MINMAX = 1e-300_dp !   complex(dp), parameter :: ONE  = (1.0_dp, 0.0_dp) !   integer     :: n !   real(dp)    :: tol_local !   complex(dp) :: sumf, compf, sumfp, compfp, term, ratio !   complex(dp) :: zn, z0 !   tol_local = 100*macheps_dp ; if(present(tol)) tol_local = tol !   sumf = 1  ; compf = 0 !   sumfp = 0 ; compfp = 0 !   term = 1 !   if(x0 .le. 0) call die(\"Domain error: x0 must be > 0\") !   if(x0 .ge. 1) call die(\"Domain error: x0 must be < 1\") !   z0 = cmplx(x0, kind = dp) !   do n=0, NMAX-1 !     zn = cmplx(n, kind = dp) !     if (n .gt. 0) call kbn_sum(sumfp, compfp, zn*term/z0) !     call kbn_sum(sumf, compf, term) !     ratio = (a+zn)*(b+zn) / ((c+zn)*(n+ONE)) * z0 !     term = term * ratio !     if(abs(term) .le. tol_local*max(MINMAX, abs(sumf))) exit !   enddo !   f0  = sumf  + compf !   fp0 = sumfp + compfp ! end subroutine f21_seed_series ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! impure elemental function f21_ode_eval(za, zb, zc, xtarg, rtol, atol, nsteps, nreject) result(res) !   !! Evaluate the Hypergeometric function ₂F₁(za,zb;zc;xtarg) by stepping an initial solution of the !   !! hypergeometric function towards xtarg. This routine should be called once the parameters !   !! z{a,b,c} and argument xtarg have been transformed so that 0 < x < 1/2 !   use rotex__constants, only: macheps_dp, zero, one !   use rotex__utils,     only: isin !   use rotex__system,    only: die, stderr !   implicit none !   complex(dp), intent(in) :: za, zb, zc !     !! The parameters a,b,c !   real(dp),    intent(in) :: xtarg !     !! The argument x !   real(dp),    intent(in), optional :: rtol, atol !     !! The relative and absolute tolerance !   integer,     intent(out), optional :: nsteps, nreject !     !! The number of actual steps taken and trial steps rejected by the error test !   complex(dp) :: res !   real(dp), parameter :: ATOL_DEFAULT_ = MACHEPS_DP * 100 !   real(dp), parameter :: RTOL_DEFAULT_ = MACHEPS_DP * 10000 !   real(dp), parameter :: X0MIN         = 1e-8_dp !   real(dp), parameter :: X0MAX         = 1e-2_dp !   real(dp), parameter :: X0SCALE       = 0.2_dp !   real(dp), parameter :: HSCALE        = 0.1_dp !   real(dp), parameter :: MIDPT_GUARD   = 0.2_dp !   real(dp), parameter :: SAFE          = 0.9_dp !   real(dp), parameter :: FACMIN        = .2_dp !   real(dp), parameter :: FACMAX        = 5._dp !   real(dp), parameter :: EXPERR        = -1._dp/(2._dp+1._dp)  ! -1/([p=2]+1) !   integer  :: nsteps_, nreject_ !   real(dp) :: rtol_, atol_, err !   real(dp) :: absab, A0, d0, h, x, x0, denom, hnew, sc1, sc2, xmin !   complex(dp) :: zx !   complex(dp) :: Y(2), Yfull(2), Yhalf(2), E(2) !   ! -- xtarg checks !   if(isin(xtarg, X0MIN, ONE) .eqv. .false.) then !     write(stderr, *) !     write(stderr, '(\"XTARG: \", e20.10)') xtarg !     write(stderr, '(\"X0MIN: \", e20.10)') X0MIN !     call die(\"To solve the hypergeometric ODE, XTARG must be in the interval, [X0MIN,1).& !       & X0MIN is chosen to be only slightly larger than zero because it is a pole of the ODE.\") !   endif !   ! -- defaults !   rtol_ = RTOL_DEFAULT_ ; if(present(rtol)) rtol_ = rtol !   atol_ = ATOL_DEFAULT_ ; if(present(atol)) atol_ = atol !   if(present(nsteps))  nsteps_  = 0 !   if(present(nreject)) nreject_ = 0 !   absab = abs(za*zb) !   ! -- x0min ≤ x0 ≤ x0max !   x0 = min(X0MAX, X0SCALE*abs(zc)/max(1._dp, abs(za*zb))) !   x0 = max(X0MIN, x0) !   ! -- initialize stepsize h0 !   zx = cmplx(x0, kind = dp) !   denom = x0 * (1.0_dp - x0) !   A0 = max( absab, abs(zc - (za+zb+one)*zx) ) / denom !   A0 = max( A0, one ) !   d0 = min( x0, one - x0 ) !   h  = min( HSCALE/A0, MIDPT_GUARD*d0, abs(xtarg - x0) ) !   ! -- x0 -> xtarg !   x = x0 !   march: do !     if(x + h .ge. xtarg) h = xtarg - x !     call step_midpt(x,          h,        za, zb, zc, Y,     Yfull) ! <-- get full step !     call step_midpt(x,          0.5_dp*h, za, zb, zc, Y,     Yhalf) ! <-- get half step !     call step_midpt(x+0.5_dp*h, 0.5_dp*h, za, zb, zc, Yhalf, Yhalf) ! <-- get second half step !     ! -- error estimate !     E   = (Yhalf - Yfull) / 3.0_dp !     sc1 = atol_ + rtol_*abs(Yhalf(1)) !     sc2 = atol_ + rtol_*abs(Yhalf(2)) !     err = max( abs(E(1))/sc1, abs(E(2))/sc2 ) !     if(err .le. one) then !       ! -- OK !       x = x + h !       Y = Yhalf !       nsteps_ = nsteps_ + 1 !       if(x .ge. xtarg) exit march !       xmin = min(x, one-x) !       hnew = h * SAFE * err**(EXPERR) !       hnew = min( FACMAX*h, max(FACMIN*h, hnew) ) !       h = sign(one, xtarg-x) * min( MIDPT_GUARD*xmin, hnew ) !     else !       ! -- NOT OK !       nreject_ = nreject_ + 1 !       hnew = h*SAFE*err**(EXPERR) !       h = sign(one, h) * max(FACMIN*h, min(hnew, h)) !       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ! ODE STALLS HERE !       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !     endif !   enddo march !   res = Y(1) !   if(present(nsteps))  nsteps  = nsteps_ !   if(present(nreject)) nreject = nreject_ ! end function f21_ode_eval ! ================================================================================================================================ ! end module rotex__hypergeometric ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__hypergeometric.f.html"},{"title":"rotex__drivers.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__drivers !! Driver used by the PROGRAM (helps me keep variables local and be sure I'm not accidentally !! using globals if I make typos or something) use rotex__types , only : dp use rotex__constants , only : UKRMOLX , MQDTR2K , DEFAULT_CHAR1 implicit none private public :: do_coulomb_born_approx public :: do_kmat_xs public :: make_grid public :: convert_multipoles #ifdef USE_CDMSREADER public :: get_cdms_data public :: get_cdms_einsta public :: get_cdms_state_energies #endif public :: diagonalize_rotational_hamiltonian public :: make_output_directories public :: combine_cb_smat_xs ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine do_coulomb_born_approx ( & cfg & , n_states & , egrid_elec_cb & , transitions_cb & , xs_xcite_pcb & , xs_xcite_tcb & , pcb_output_directory & , tcb_output_directory ) !! Use the Coulomb-Born approximation to get scattering cross sections for e⁻ + target. !! Also determines Einstein A coefficients and excited state average lifetimes within !! !! the radiative dipole/multipole approximation. The target charge Z is supplied and !! used by the routine that are called here, so various target charges can be used, including Z = 0 (neutral targets). !! This routine loops over the different pairs  Nτ —→ N'τ' use rotex__kinds , only : dp use rotex__arrays , only : append use rotex__symmetry , only : is_spin_forbidden , spin_symmetry use rotex__system , only : stdout , die use rotex__functions , only : istriangle , logrange use rotex__types , only : asymtop_rot_channel_type , asymtop_rot_transition_type , operator (. eq .) & , n_states_type , rvector_type , config_type use rotex__writing , only : write_CB_xs_to_file , write_lifetimes_to_file use rotex__cbxs , only : get_cb_xs_asym , get_einsta_only , xtrapolate_cb_xs use rotex__characters , only : i2c => int2char #ifdef USE_CDMSREADER use CDMSreader__types , only : asymtop_state_type => asymtop_state_nohfs & , asymtop_transition_type => asymtop_transition_nohfs #endif implicit none type ( config_type ), intent ( in ) :: cfg type ( n_states_type ), intent ( inout ), allocatable :: n_states (:) type ( rvector_type ), intent ( out ), allocatable :: egrid_elec_cb (:) !! Array of arrays of electron/collision energies for each transition type ( asymtop_rot_transition_type ), intent ( out ), allocatable :: transitions_cb (:) !! Array containing transitions between rotational states for the long-range CB excitations type ( rvector_type ), intent ( out ), allocatable :: xs_xcite_pcb (:), xs_xcite_tcb (:) !! Array of arrays of the Partial and Total Coulomb-Born cross sections for each transition character ( * ), intent ( in ) :: pcb_output_directory character ( * ), intent ( in ) :: tcb_output_directory integer :: ipair , inlo , inup , itaulo , itauup integer :: nlo , nup , kalo , kaup , kclo , kcup , neleclo , nelecup integer :: num_n integer :: sym integer , allocatable :: lambdas (:) real ( dp ) :: elo , eup , de , estart , eend real ( dp ) :: einsta real ( dp ), allocatable :: Eel (:) real ( dp ), allocatable :: sigma_pcb (:), sigma_tcb (:) real ( dp ), allocatable :: eigveclo (:), eigvecup (:) complex ( dp ) :: spherical_dipole_moments ( 3 ) complex ( dp ) :: spherical_quadrupole_moments ( 5 ) type ( asymtop_rot_channel_type ) :: lo , up !! Rotational channels of the target for an excitation pair type ( asymtop_rot_transition_type ) :: transition !! A single rotational transition #ifdef USE_CDMSREADER type ( asymtop_state_type ), allocatable :: cdms_states (:) !! Array of states involved in the CDMS transitions, averaged over hyperfine contributions. Output !! of CDMSreader type ( asymtop_transition_type ), allocatable :: CDMS_transitions (:) !! Array of CDMS transitions, averaged over hyperfine contributions. Output of CDMSreader #endif num_n = size ( n_states , 1 ) ! -- cartesian multipoles → spherical multipoles. if ( cfg % do_dipole . eqv . . true .) & call convert_multipoles ( cfg % cartesian_dipole_moments , spherical_dipole_moments ) if ( cfg % do_quadrupole . eqv . . true .) & call convert_multipoles ( cfg % cartesian_quadrupole_moments , spherical_quadrupole_moments ) lambdas = pack ([ 1 , 2 ], [ cfg % do_dipole , cfg % do_quadrupole ]) #ifdef USE_CDMSREADER ! -- whether to use the CDMS einstein A coefficients in our Coulomb-Born approximation if ( cfg % use_cdms_einsta . eqv . . true .) then call get_cdms_data ( cfg % cdms_file , cfg % output_directory , cdms_states , cdms_transitions ) call get_cdms_state_energies ( n_states , cdms_states ) ! n_states <— cdms data endif #endif write ( stdout , * ) write ( stdout , '(A)' ) \"--------------------------------------------------\" write ( stdout , '(A)' ) \"Looping over allowed Coulomb-Born excitation pairs\" write ( stdout , '(A)' ) \"⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻\" ipair = 0 nlo_loop : do inlo = 1 , num_n nlo = n_states ( inlo ) % n if ( nlo . lt . cfg % nmin ) cycle nlo_loop if ( nlo . gt . cfg % nmax ) cycle nlo_loop ! -- only consider 1 electronic state for now neleclo = 1 ! -- only consider excitation pairs; de-excitation is handled symmetrically nup_loop : do inup = inlo , num_n nup = n_states ( inup ) % n if ( nup . lt . cfg % nmin ) cycle nup_loop if ( nup . gt . cfg % nmax ) cycle nup_loop ! -- only consider 1 electronic state for now nelecup = 1 ! -- skip if the pair Nlo, Nup don't satisfy the triangle inequality !    |Nlo-Nup| <= λ <= Nlo+Nup for any λ if ( all ( istriangle ( nlo , nup , lambdas ) . eqv . . false . )) cycle write ( stdout , '(\"N : \", I0, \" —> \", I0)' ) nlo , nup taulo_loop : do itaulo = 1 , 2 * nlo + 1 kalo = n_states ( inlo ) % ka ( itaulo ) kclo = n_states ( inlo ) % kc ( itaulo ) elo = n_states ( inlo ) % eigenh % eigvals ( itaulo ) sym = spin_symmetry ( nlo , kalo , kclo , cfg % spin_isomer_kind , cfg % zaxis ) lo = asymtop_rot_channel_type ( nelec = neleclo , n = nlo , ka = kalo , kc = kclo , e = elo , sym = sym ) tauup_loop : do itauup = 1 , 2 * nup + 1 kaup = n_states ( inup ) % ka ( itauup ) kcup = n_states ( inup ) % kc ( itauup ) eup = n_states ( inup ) % eigenh % eigvals ( itauup ) sym = spin_symmetry ( nup , kaup , kcup , cfg % spin_isomer_kind , cfg % zaxis ) up = asymtop_rot_channel_type ( nelec = nelecup , n = nup , ka = kaup , kc = kcup , e = eup , sym = sym ) ! -- ignore elastic collisions and de-excitation pairs if ( lo . eq . up ) cycle tauup_loop if ( Eup . lt . Elo ) cycle ! -- add this pair of states to the list of transitions ipair = ipair + 1 transition = asymtop_rot_transition_type ( lo = lo , up = up ) write ( stdout , '(2X, \"(Ka,Kc) : \", I0,\",\",I0, \" --> \", I0,\",\",I0, \" ... \")' , advance = \"no\" ) & kalo , kclo , kaup , kcup eigveclo = n_states ( inlo ) % eigenh % eigvecs (:, itaulo ) eigvecup = n_states ( inup ) % eigenh % eigvecs (:, itauup ) select case ( cfg % rotor_kind ) case ( \"l\" ) call die ( \"linear xs not yet programmed; use ABC and set a large A (hundreds+)\" ) case ( \"s\" , \"a\" ) continue case default call die ( \"ROTOR_KIND  must be (l)inear, (s)ymmetric top, or (a)symmetric top\" ) end select ! -- check if we need to respect ortho-para symmetry if ( is_spin_forbidden ( nlo , kalo , kclo , nup , kaup , kcup , cfg % spin_isomer_kind , cfg % zaxis ) ) then write ( stdout , \"(A)\" ) \"is forbidden (ortho-para violation) !\" cycle tauup_loop endif ! -- coulomb-born energy grid starts at the excitation threshold + Ei, and goes to !    some absolute electron energy ef that does not depend on the threshold de = eup - elo estart = de + cfg % ei eend = cfg % ef if ( eend . le . estart ) call die ( \"The starting energy of this coulomb-born energy grid is higher than the ending energy\" ) Eel = logrange ( estart , eend , cfg % ne ) einsta = 0 #ifdef USE_CDMSREADER ! -- get CDMS Einstein A coefficients if ( cfg % use_cdms_einsta . eqv . . true .) call get_cdms_einsta ( nlo , kalo , kclo , nup , kaup , kcup , cdms_transitions , einsta ) #endif if ( cfg % only_einsta . eqv . . false .) then ! -- get partial CB cross sections Nτ —> N'τ' call get_cb_xs_asym ( & Eel & , sigma_pcb & , cfg % target_charge & , nlo & , nup & , elo & , eup & , eigveclo & , eigvecup & , einsta & , cfg % use_cdms_einsta & , cfg % do_dipole & , cfg % do_quadrupole & , spherical_dipole_moments & , spherical_quadrupole_moments & , [. false ., . false .] & ! explicitly request partial xs , cfg % lmax_partial & ) elseif ( einsta . eq . 0 ) then ! -- get calculate only Einstein A coefficients if they're not found in the CDMS call get_einsta_only ( & einsta & , nlo & , nup & , elo & , eup & , eigveclo & , eigvecup & , cfg % use_cdms_einsta & , cfg % do_dipole & , cfg % do_quadrupole & , spherical_dipole_moments & , spherical_quadrupole_moments & ) endif ! -- add the einstein coefficients to the upper state for this transition n_states ( inup ) % einsta ( itauup ) = n_states ( inup ) % einsta ( itauup ) + einsta if ( cfg % only_einsta . eqv . . true .) then if ( EinstA . eq . 0 ) then write ( stdout , \"(A)\" ) \"is forbidden (Einstein A coefficient is 0)!\" else write ( stdout , \"(A)\" ) \"done !\" endif cycle tauup_loop endif if ( all ( sigma_pcb . eq . 0 )) then write ( stdout , \"(A)\" ) \"is forbidden (all cross sections are 0)!\" cycle tauup_loop endif ! -- append to the list of transitions, electron energies, and PCB cross sections call append ( transitions_CB , transition ) ! -- only include the grid elements where we successfully got a well-behaved !    cross section. This defines the shared Eel Coulomb-Born grid that will be !    used for the TCB cross sections as well Eel = pack ( Eel , sigma_pcb . gt . 0.0_dp ) sigma_pcb = pack ( sigma_pcb , sigma_pcb . gt . 0.0_dp ) ! -- get total CB cross sections Nτ —> N'τ' call get_cb_xs_asym ( & Eel & , sigma_tcb & , cfg % target_charge & , nlo & , nup & , elo & , eup & , eigveclo & , eigvecup & , einsta & , cfg % use_cdms_einsta & , cfg % do_dipole & , cfg % do_quadrupole & , spherical_dipole_moments & , spherical_quadrupole_moments & , cfg % analytic_total_cb & ! as per user request , cfg % lmax_total & ) ! -- extrapolate excitation CB cross sections as 1/E to threshold ? if ( cfg % do_xtrap ) call xtrapolate_cb_xs ( cfg % Ei_xtrap , dE , cfg % nE_xtrap , Eel , sigma_pcb , sigma_tcb ) ! -- append energy grid, including extrapolated energies if that happened call append ( egrid_elec_cb , Eel ) ! -- append PCB and TCB excitation to corresponding arrays, including !    extrapolated cross sections if that happened call append ( xs_xcite_pcb , sigma_pcb ) call append ( xs_xcite_tcb , sigma_tcb ) ! -- write this excitation to disk call write_CB_xs_to_file ( & \"PCB\" & , pcb_output_directory & , cfg % zaxis & , Eel & , sigma_pcb & , transition % lo & , transition % up & , i2c ( cfg % lmax_partial ) & ) call write_CB_xs_to_file ( & \"TCB\" & , tcb_output_directory & , cfg % zaxis & , Eel & , sigma_tcb & , transition % lo & , transition % up & , i2c ( cfg % lmax_partial ) & ) ! -- get corresponding de-excitation cross section call convert_xcite2dxcite ( Eel , sigma_pcb , transition ) call convert_xcite2dxcite ( Eel , sigma_tcb , transition ) ! -- storing de-excitation cross sections is redundant, especially if !    we'll be interpolating theses later, so just write them to file now !    and don't worry about storing them ! -- write this de-excitation to disk call write_CB_xs_to_file ( & \"PCB\" & , pcb_output_directory & , cfg % zaxis & , Eel - dE & , sigma_pcb & , transition % up & , transition % lo & , i2c ( cfg % lmax_partial ) & ) call write_CB_xs_to_file ( & \"TCB\" & , tcb_output_directory & , cfg % zaxis & , Eel - dE & , sigma_tcb & , transition % up & , transition % lo & , i2c ( cfg % lmax_partial ) & ) write ( stdout , \"(A)\" ) \"done !\" enddo tauup_loop enddo taulo_loop enddo nup_loop enddo Nlo_loop call write_lifetimes_to_file ( cfg % output_directory , cfg % nmin , cfg % nmax , n_states , cfg % zaxis ) end subroutine do_coulomb_born_approx ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine do_kmat_xs ( cfg , n_states , egrid_tot_smat , smat_output_directory , transitions , xs_xcite_spinavg , xs_dxcite_spinavg ) !! Read K-matrices from an electron-molecule scattering calculation, get S-matrices, add the rotation via !! the rotational frame transformation for asymmetric tops, then use the MQDT channel elimination to !! get electron-impact excitation cross sections entirely from the K-matrix scattering data. use rotex__types , only : dp , n_states_type , cmatrix_type , elec_channel_type & , asymtop_rot_channel_l_type , asymtop_rot_channel_l_vector_type & , asymtop_rot_transition_type , rvector_type , config_type , findloc_transitions use rotex__system , only : die , DS => DIRECTORY_SEPARATOR , stdout use rotex__constants , only : spinmult_names use rotex__rft , only : rft_nonlinear use rotex__arrays , only : append_uniq use rotex__mqdtxs , only : get_smat_probs use rotex__characters , only : i2c => int2char use rotex__reading , only : read_kmats use rotex__writing , only : write_smat_xs_to_file , write_channels_to_file implicit none type ( config_type ), intent ( in ) :: cfg type ( n_states_type ), intent ( in ) :: n_states (:) real ( dp ), intent ( in ) :: egrid_tot_smat (:) !! Total energy grid for the S-matrix cross sections character ( * ), intent ( in ) :: smat_output_directory type ( asymtop_rot_transition_type ), intent ( out ), allocatable :: transitions (:) type ( rvector_type ), intent ( out ), allocatable :: xs_xcite_spinavg (:) !! Array of arrays of excitation cross sections for all spin multiplicities type ( rvector_type ), intent ( out ), allocatable :: xs_dxcite_spinavg (:) !! Array of arrays of de-excitation cross sections for all spin multiplicities ! -- default values of the channel and K-matrix energies character ( 1 ), parameter :: UKRMOLX_CHANNEL_ENERGY_UNITS = \"r\" !ydberg character ( 1 ), parameter :: MQDTR2K_CHANNEL_ENERGY_UNITS = \"e\" !ydberg character ( 1 ), parameter :: UKRMOLX_KMAT_ENERGY_UNITS = \"r\" !ydberg character ( 1 ), parameter :: MQDTR2K_KMAT_ENERGY_UNITS = \"e\" !lectron-Volts integer :: ispin , nspins , jmin , jmax , itrans , ntrans , ne integer , allocatable :: idxmap (:) real ( dp ), allocatable :: kmat (:,:) character ( 1 ) :: kmat_eval_E_units , channel_e_units character (:), allocatable :: smat_output_directory_this_spin , smat_output_directory_all_spins character (:), allocatable :: channels_file_this_spin type ( cmatrix_type ), allocatable :: smat_j (:) type ( elec_channel_type ), allocatable :: elec_channels (:) type ( rvector_type ), allocatable :: prob_smat (:), xs_xcite (:), xs_dxcite (:) type ( asymtop_rot_channel_l_type ), allocatable :: asymtop_rot_channels_l (:) type ( asymtop_rot_channel_l_vector_type ), allocatable :: asymtop_rot_channels_l_j (:) type ( asymtop_rot_transition_type ), allocatable :: transitions_this_spin (:) nspins = size ( cfg % spinmults , 1 ) spinsdo : do ispin = 1 , nspins ! -- determine energy and channel units kmat_eval_e_units = cfg % kmat_energy_units_override channel_e_units = cfg % channel_energy_units_override ! -- check if we need to use default values select case ( cfg % kmat_output_type ) case ( UKRMOLX ) if ( kmat_eval_e_units . eq . DEFAULT_CHAR1 ) kmat_eval_e_units = UKRMOLX_KMAT_ENERGY_UNITS if ( channel_e_units . eq . DEFAULT_CHAR1 ) channel_e_units = UKRMOLX_CHANNEL_ENERGY_UNITS case ( MQDTR2K ) if ( kmat_eval_e_units . eq . DEFAULT_CHAR1 ) kmat_eval_e_units = MQDTR2K_KMAT_ENERGY_UNITS if ( channel_e_units . eq . DEFAULT_CHAR1 ) channel_e_units = MQDTR2K_CHANNEL_ENERGY_UNITS case default call die ( \"KMAT_OUTPUT_TYPE (\" // cfg % kmat_output_type // \") must be one of \" // UKRMOLX // \" or \" // MQDTR2K ) end select call read_kmats ( & kmat_dir = cfg % kmat_dir & , channels_dir = cfg % channels_dir & , point_group = cfg % point_group & , spinmult = cfg % spinmults ( ispin ) & , kmat_lmax = cfg % lmax_kmat & , kmat = kmat & , elec_channels = elec_channels & , channel_e_units = channel_e_units & , kmat_eval_E_units = kmat_eval_e_units & , kmat_output_type = cfg % kmat_output_type & , kmat_e_closest = cfg % kmat_energy_closest & ) if ( maxval ( elec_channels % l ) . gt . cfg % lmax_kmat ) call die ( \"K-matrix has at least one channel with& & l > LMAX_KMAT: \" // i2c ( maxval ( elec_channels % l )) // \" > \" // i2c ( cfg % lmax_kmat )) write ( stdout , '(A)' ) \"Performing the rotational frame transformation\" write ( stdout , '(A)' ) \"----------------------------------------------\" write ( stdout , * ) select case ( cfg % rotor_kind ) case ( \"l\" ) call die ( \"Linear RFT not programmed yet. Just use ABC with large A (hundreds+)\" ) case ( \"s\" , \"a\" ) continue case default call die ( \"ROTOR_KIND  must be (l)inear, (s)ymmetric top, or (a)symmetric top\" ) end select ! -- min and max values of total J jmin = max ( 0 , cfg % nmin - cfg % lmax_kmat ) jmax = abs ( cfg % nmax + cfg % lmax_kmat ) allocate ( smat_j ( jmin : jmax )) allocate ( asymtop_rot_channels_l_j ( jmin : jmax )) call rft_nonlinear ( kmat & , jmin , jmax & , smat_j ( jmin : jmax ) & , elec_channels & , n_states & , asymtop_rot_channels_l & , asymtop_rot_channels_l_j ( jmin : jmax ) & , cfg % spin_isomer_kind & , cfg % zaxis & , cfg % real_spherical_harmonics & , cfg % point_group & ) deallocate ( elec_channels ) channels_file_this_spin = cfg % output_directory & // spinmult_names ( cfg % spinmults ( ispin )) // \".channels\" call write_channels_to_file ( channels_file_this_spin , jmin , jmax , n_states & , asymtop_rot_channels_l , asymtop_rot_channels_l_j ( jmin : jmax ) & , cfg % spin_isomer_kind , cfg % zaxis ) write ( stdout , * ) write ( stdout , '(A)' ) \"--------------------------\" write ( stdout , '(A)' ) \"Calculating cross sections\" write ( stdout , '(A)' ) \"⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻\" call get_smat_probs ( & egrid_tot_smat & , prob_smat & , transitions_this_spin & , cfg % nmin & , cfg % nmax & , smat_j ( jmin : jmax ) & , jmin , jmax & , asymtop_rot_channels_l_j & , asymtop_rot_channels_l & , cfg % spin_isomer_kind & , cfg % zaxis ) deallocate ( smat_J ) deallocate ( asymtop_rot_channels_l ) deallocate ( asymtop_rot_channels_l_j ) ! -- this routine also remove transitions whose cross sectiosn are too small call get_xs_from_smat ( & prob_smat & , transitions_this_spin & , egrid_tot_smat & , xs_xcite & , xs_dxcite & , cfg % xs_zero_threshold & ) write ( stdout , * ) write ( stdout , '(A)' ) \"Writing \" // spinmult_names ( cfg % spinmults ( ispin )) // \" S-matrix cross sections to disk\" write ( stdout , * ) smat_output_directory_this_spin = & & smat_output_directory // spinmult_names ( cfg % spinmults ( ispin )) // DS do itrans = 1 , size ( transitions_this_spin , 1 ) call write_smat_xs_to_file ( & \"Smat\" & , smat_output_directory_this_spin & , cfg % zaxis & , egrid_tot_smat & , transitions_this_spin ( itrans ) & , xs_xcite ( itrans )% vec & , xs_dxcite ( itrans )% vec & , cfg % lmax_kmat & ) enddo ! -- append the transitions for this spin to the array of transitions !    for all spins uniquely (don't double-count existing transitions). call append_uniq ( transitions , transitions_this_spin ) ! -- if there's only one spin, don't worry about spin averaging if ( nspins . eq . 1 ) then call move_alloc ( xs_xcite , xs_xcite_spinavg ) call move_alloc ( xs_dxcite , xs_dxcite_spinavg ) return endif ! -- xs_xcite, xs_dxcite,and transitions_this_spin are always indexed in the same basis. !    This is probably true for transitions, but not necessarily.Figure out how !    they map to transitions so that we ensure contributions are added properly idxmap = findloc_transitions ( transitions_this_spin , transitions ) ! -- allocate the spinavg cross section arrays if necessary before adding this spin's contribution ne = size ( egrid_tot_smat , 1 ) ntrans = size ( transitions_this_spin , 1 ) if (. not . allocated ( xs_xcite_spinavg )) then allocate ( xs_xcite_spinavg ( ntrans )) allocate ( xs_dxcite_spinavg ( ntrans )) do itrans = 1 , ntrans ; allocate ( xs_xcite_spinavg ( itrans )% vec ( ne ), source = 0.0_dp ) ; enddo do itrans = 1 , ntrans ; allocate ( xs_dxcite_spinavg ( itrans )% vec ( ne ), source = 0.0_dp ) ; enddo endif ! -- σ_allspins += σ_thisspin * (2S+1) / Σ(2S+1) call add_xs_contrib_this_spin ( & transitions & , idxmap & , cfg % spinmults & , ispin & , xs_xcite & , xs_dxcite & , xs_xcite_spinavg & , xs_dxcite_spinavg ) if ( allocated ( prob_smat )) deallocate ( prob_smat ) enddo spinsdo ! -- write spin-averaged S-matrix cross sections to disk write ( stdout , '(A)' ) \"Writing  S-matrix cross sections ∀ spins to disk\" smat_output_directory_all_spins = & & smat_output_directory // \"all_spins\" // DS do itrans = 1 , size ( transitions , 1 ) call write_smat_xs_to_file ( & \"Smat\" & , smat_output_directory_all_spins & , cfg % zaxis & , egrid_tot_smat & , transitions ( itrans ) & , xs_xcite_spinavg ( itrans )% vec & , xs_dxcite_spinavg ( itrans )% vec & , cfg % lmax_kmat & ) enddo end subroutine do_kmat_xs ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine convert_multipoles ( cartesian_moments_array , spherical_moments_array ) !! Convert the supplied array of multipole moments from cartesian, obtained as typical output from !! quantum chemistry codes, to spherical multipole moments !!  Q_{\\lambda,\\mu} = \\int d\\vec{r} \\rho(\\vec{r}) Y_lambda&#94;\\mu(\\hat{r})  use rotex__types , only : dp use rotex__system , only : die use rotex__constants , only : im implicit none real ( dp ), intent ( in ) :: cartesian_moments_array (:) !! Array containing cartesian multipole moments. complex ( dp ), intent ( out ) :: spherical_moments_array (:) !! Array containing spherical multipole moments. integer :: nelements integer :: ilambda_start real ( dp ) :: dx , dy , dz real ( dp ) :: Qxx , Qxy , Qxz , Qyy , Qyz , Qzz ilambda_start = 1 nelements = size ( cartesian_moments_array ) select case ( nelements ) ! -- dipole case ( 3 ) dx = cartesian_moments_array ( 1 ) dy = cartesian_moments_array ( 2 ) dz = cartesian_moments_array ( 3 ) spherical_moments_array = [ & !  μ ( dx - im * dy ) / sqrt ( 2.0_dp ) & ! -1 , cmplx ( dz , kind = dp ) & !  0 , - ( dx + im * dy ) / sqrt ( 2.0_dp ) & !  1 ] ! -- quadrupole case ( 6 ) Qxx = cartesian_moments_array ( ilambda_start ) Qxy = cartesian_moments_array ( ilambda_start + 1 ) Qxz = cartesian_moments_array ( ilambda_start + 2 ) Qyy = cartesian_moments_array ( ilambda_start + 3 ) Qyz = cartesian_moments_array ( ilambda_start + 4 ) Qzz = cartesian_moments_array ( ilambda_start + 5 ) spherical_moments_array = [ & !  μ ( Qxx - Qyy - 2 * im * Qxy ) / 2 & ! -2 , ( Qxz - im * Qyz ) / sqrt ( 2.0_dp ) & ! -1 , ( 2 * Qzz - Qxy - Qyy ) / sqrt ( 6.0_dp ) + 0 * im & !  0 , - ( Qxz + im * Qyz ) / sqrt ( 2.0_dp ) & !  1 , ( Qxx - Qyy + 2 * im * Qxy ) / 2 & !  2 ] case default call die ( \"Passed a cartesian multipole moment array of unacceptable size !\" ) end select end subroutine convert_multipoles ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine make_grid ( grid , E0 , num_segments , grid_segments , nelemnts_per_seg , spacing ) !! Make a segmented grid starting at E0 !! Example with !!   num_segments = 3, grid_segments = [1e-3, 1e-2, 1e-1, 1], nelemnts_per_seg = [1000,1000, 100] !! E0+1e-3           E0+1e-2              E0+1e-1           E0+1.0 !!   !------------------!-------------------!- - - - - - - - -! !!      1000 energies     1000 energies      100 energies use rotex__system , only : die use rotex__arrays , only : realloc implicit none real ( dp ), intent ( inout ), allocatable :: grid (:) !! The energy grid real ( dp ), intent ( in ) :: E0 !! The lowest energy integer , intent ( in ) :: num_segments !! The number of segments in the energy grid real ( dp ), intent ( in ) :: grid_segments (:) !! The boundaries of the grid segments integer , intent ( in ) :: nelemnts_per_seg (:) !! The number of elements in each grid segment character ( 3 ), intent ( in ) :: spacing !! The spacing type in each segment. \"LIN\" for linear or \"LOG\" for logarithmic integer :: ie , iseg real ( dp ), allocatable :: dE (:) allocate ( dE ( num_segments ), source = 0.0_dp ) select case ( spacing ) case ( \"lin\" ) dE = [( & ( grid_segments ( iseg + 1 ) - grid_segments ( iseg )) / ( nelemnts_per_seg ( iseg ) - 1 ) & , iseg = 1 , num_segments & )] grid = [ & E0 & , E0 + grid_segments ( 1 ) & , ( ( E0 + grid_segments ( iseg ) + ie * dE ( iseg ), ie = 1 , nelemnts_per_seg ( iseg ) - 1 ), iseg = 1 , num_segments ) & ] case ( \"log\" ) dE = [( & ( grid_segments ( iseg + 1 ) / grid_segments ( iseg )) ** ( 1 / real ( nelemnts_per_seg ( iseg ) - 1 , kind = dp )) & , iseg = 1 , num_segments & )] grid = [ & E0 & , E0 + grid_segments ( 1 ) & , ( ( E0 + grid_segments ( iseg ) * dE ( iseg ) ** ie , ie = 1 , nelemnts_per_seg ( iseg ) - 1 ), iseg = 1 , num_segments ) & ] case default call die ( \"EGRID_SPACING (\" // spacing // \") must be LIN or LOG\" ) end select end subroutine make_grid ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine make_output_directories ( output_directory , use_CB , spinmults , use_kmat & , pcb_output_directory , tcb_output_directory , smat_output_directory ) use rotex__system , only : DS => DIRECTORY_SEPARATOR , mkdir use rotex__constants , only : spinmult_names implicit none character ( * ), intent ( in ) :: output_directory logical , intent ( in ) :: use_cb , use_kmat integer , intent ( in ) :: spinmults (:) character (:), intent ( inout ), allocatable :: pcb_output_directory , tcb_output_directory , smat_output_directory integer :: ispin call mkdir ( output_directory ) if ( use_CB . eqv . . true .) then pcb_output_directory = output_directory // \"PCB\" // DS tcb_output_directory = output_directory // \"TCB\" // DS call mkdir ( PCB_output_directory ) call mkdir ( TCB_output_directory ) endif if ( use_kmat . eqv . . true .) then smat_output_directory = output_directory // \"Smat\" // DS call mkdir ( smat_output_directory ) do ispin = 1 , size ( spinmults , 1 ) call mkdir ( smat_output_directory // spinmult_names ( spinmults ( ispin )) // DS ) enddo endif end subroutine make_output_directories #ifdef USE_CDMSREADER ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_CDMS_data ( filename , output_directory , CDMS_states , CDMS_transitions ) !! Read a file from the CDMS search to get Einstein A coefficients that will be used in determining !! Coulomb-Born cross sections. use CDMSreader__readwrite , only : CDMS_readfile_nohfs use CDMSreader__types , only : asymtop_state_type => asymtop_state_nohfs & , asymtop_transition_type => asymtop_transition_nohfs implicit none character ( * ), intent ( in ) :: filename character ( * ), intent ( in ) :: output_directory integer :: funit_in , funit_out type ( asymtop_state_type ), allocatable , intent ( out ) :: CDMS_states (:) type ( asymtop_transition_type ), allocatable , intent ( out ) :: CDMS_transitions (:) open ( newunit = funit_in , file = filename ) open ( newunit = funit_out , file = output_directory // \"CDMSreader.output.dat\" ) call CDMS_readfile_nohfs ( funit_in & , funit_out & , states_nohfs = CDMS_states & , transitions_nohfs = CDMS_transitions ) close ( funit_in ) close ( funit_out ) end subroutine get_CDMS_data ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_cdms_state_energies ( n_states , cdms_states ) !! Update the energy of our rotational states with those from the CDMS use rotex__types , only : n_states_type use rotex__constants , only : au2invcm use cdmsreader__types , only : asymtop_state_type => asymtop_state implicit none type ( n_states_type ), intent ( inout ) :: n_states (:) class ( asymtop_state_type ), intent ( in ) :: cdms_states (:) integer :: in , itau , icdms integer :: n , n_cdms integer :: ka , ka_cdms integer :: kc , kc_cdms real ( dp ) :: e_cdms do in = 1 , size ( n_states , 1 ) n = n_states ( in ) % n do itau = 1 , 2 * n + 1 ka = n_states ( in ) % ka ( itau ) kc = n_states ( in ) % kc ( itau ) do icdms = 1 , size ( cdms_states , 1 ) n_cdms = cdms_states ( icdms ) % dn / 2 ka_cdms = cdms_states ( icdms ) % dka / 2 kc_cdms = cdms_states ( icdms ) % dkc / 2 if ( n . ne . n_cdms ) cycle if ( ka . ne . ka_cdms ) cycle if ( kc . ne . kc_cdms ) cycle ! n_states E <— CDMS E e_cdms = cdms_states ( icdms ) % e / au2invcm ! -- CDMS energies in cm⁻¹ n_states ( in ) % eigenh % eigvals ( itau ) = e_cdms enddo enddo enddo end subroutine get_CDMS_state_energies ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_CDMS_einstA ( Nlo , Kalo , Kclo , Nup , Kaup , Kcup , CDMS_transitions , EinstA ) !! Given the quantum numbers of a rotational transition, find the matching CDMS transition !! and get the corresponding Einstein A coefficient use rotex__system , only : stderr , die use rotex__constants , only : au2sec use CDMSreader__types , only : asymtop_transition_type => asymtop_transition & , asymtop_transition_nohfs_type => asymtop_transition_nohfs implicit none integer , intent ( in ) :: Nlo , Kalo , Kclo , Nup , Kaup , Kcup class ( asymtop_transition_type ), intent ( in ) :: CDMS_transitions (:) real ( dp ), intent ( out ) :: EinstA integer :: i EinstA = 0 select type ( transitions => CDMS_transitions ) type is ( asymtop_transition_nohfs_type ) do i = 1 , size ( transitions , 1 ) if ( Nlo . ne . transitions ( i ) % lo % dN / 2 ) cycle if ( Nup . ne . transitions ( i ) % up % dN / 2 ) cycle if ( Kalo . ne . transitions ( i ) % lo % dKa / 2 ) cycle if ( Kclo . ne . transitions ( i ) % lo % dKc / 2 ) cycle if ( Kaup . ne . transitions ( i ) % up % dKa / 2 ) cycle if ( Kcup . ne . transitions ( i ) % up % dKc / 2 ) cycle ! -- EinstA coeffs are in 1/s EinstA = transitions ( i ) % EinstA * au2sec return enddo class default call die ( \"CDMS_TRANSITIONS is not of type ASYMTOP_TRANSITION_NOHFS_TYPE\" ) end select end subroutine get_CDMS_einstA #endif ! ------------------------------------------------------------------------------------------------------------------------------- module subroutine diagonalize_rotational_hamiltonian ( cfg , num_n , n_values , n_states ) !! Build the rigid-rotor hamiltonian for each N and diagonalize it. Keep eigenenergies and !! eigenvectors, stored in the eigenH type of n_states use rotex__types , only : dp , n_states_type , eigenh_type , config_type use rotex__system , only : die use rotex__arrays , only : size_check use rotex__hamilton , only : h_asym , assign_projections !, get_different_K_projections implicit none type ( config_type ), intent ( in ) :: cfg integer , intent ( in ) :: num_n , n_values (:) type ( n_states_type ), intent ( out ) :: n_states (:) integer :: i_n , n type ( eigenh_type ) :: hka , hkb , hkc call size_check ( n_values , num_n , \"N_VALUES\" ) call size_check ( n_states , num_n , \"N_STATES\" ) do i_n = 1 , num_n n = n_values ( i_n ) allocate ( n_states ( i_n ) % einsta ( 2 * n + 1 )) n_states ( i_n ) % n = n n_states ( i_n ) % einsta = 0 select case ( cfg % rotor_kind ) case ( \"l\" , \"a\" , \"s\" ) associate ( a => cfg % abc ( 1 ), b => cfg % abc ( 2 ), c => cfg % abc ( 3 )) call rigid_rotor ( n , hka , b , c , a ) ! <-- A basis, Ka = Kz call rigid_rotor ( n , hkb , c , a , b ) ! <-- B basis, Kb = Kz call rigid_rotor ( n , hkc , a , b , c ) ! <-- C basis, Kc = Kz end associate ! -- Select the right basis select case ( cfg % zaxis ) case ( \"a\" ) ; N_states ( i_N ) % eigenH = HKa case ( \"b\" ) ; N_states ( i_N ) % eigenH = HKb case ( \"c\" ) ; N_states ( i_N ) % eigenH = HKc case default call die ( \"ZAXIS must be A, B, or C\" ) end select ! -- assign Ka and Kc labels call assign_projections ( N , Hka , N_states ( i_N ) % Ka ) ! Ka labels call assign_projections ( N , Hkc , N_states ( i_N ) % Kc ) ! Kc labels case default call die ( \"Undefined value for namelist variable ROTOR_KIND: \" // cfg % rotor_kind ) end select enddo ! ------------------------------------------------------------------------------------------------------------------------------ ! contains ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine rigid_rotor ( nn , ham , bx , by , bz ) !! Wrapper for calling the hamiltonian routine implicit none integer , intent ( in ) :: nn type ( eigenh_type ), intent ( out ) :: ham real ( dp ), intent ( in ) :: bx , by , bz integer :: test ! -- add cd4 ? test = merge ( 1 , 0 , cfg % add_cd4 . eqv . . true .) ! -- add cf4 & cd6 ? test = merge ( 2 , test , ( cfg % add_cd6 . eqv . . true .) . AND . ( cfg % add_cd4 . eqv . . true .)) select case ( test ) case ( 2 ) ; call h_asym ( nn , ham , bx , by , bz , cfg % cd4 , cfg % cd6 ) case ( 1 ) ; call h_asym ( nn , ham , bx , by , bz , cfg % cd4 ) case ( 0 ) ; call h_asym ( nn , ham , bx , by , bz ) case default call die ( \"Somehow got something other than 0,1,2 !\" ) end select end subroutine rigid_rotor end subroutine diagonalize_rotational_hamiltonian ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine add_xs_contrib_this_spin ( & transitions & , idxmap & , ispinmults & , ispin & , xs_xcite & , xs_dxcite & , xs_xcite_spinavg & , xs_dxcite_spinavg ) !! This subrotine is called when calculating cross sections for a particular spin multiplicity. !! It adds the contribution of XS_(D)XCITE for this spin to the total XS_(D)XCITE_SPINAVG as !!   XS_SPINAVG += spinmul(ispin)*XS(ispin) / sum(spinmults) use rotex__types , only : asymtop_rot_transition_type , rvector_type use rotex__utils , only : assert use rotex__arrays , only : size_check implicit none type ( asymtop_rot_transition_type ), intent ( in ) :: transitions (:) !! List of transitions between states lo and up integer , intent ( in ) :: idxmap (:) !! Mapping from XS_(D)XCITE to the arrays {TRANSITIONS, XS_(D)XCITE_SPINAVG} integer , intent ( in ) :: ispinmults (:) !! Array of spin multiplicities 2S+1 integer , intent ( in ) :: ispin !! The current index of ispinmults type ( rvector_type ), intent ( in ) :: xs_xcite (:), xs_dxcite (:) !! Cross sections for this spin multiplicity type ( rvector_type ), intent ( inout ) :: xs_dxcite_spinavg (:), xs_xcite_spinavg (:) integer :: itrans , ntrans real ( dp ) :: sum_spinmults ntrans = size ( transitions , 1 ) call size_check ( xs_xcite , ntrans , \"XS_XCITE\" ) call size_check ( xs_dxcite , ntrans , \"XS_DXCITE\" ) call assert ( size ( xs_xcite_spinavg , 1 ) . eq . ntrans , \"XS_XCITE and XS_XCITE_SPINAVG do not have& & the same number of elements, which means that they do not have the same number of transitions.& & This should not be the case if only one electronic state was included, which is the only case that& & this code is currently expected to handle.\" ) call assert ( size ( xs_dxcite_spinavg , 1 ) . eq . ntrans , \"XS_DXCITE_SPINAVG and XS_DXCITE do not have& & the same number of elements, which means that they do not have the same number of transitions.& & However, this XS_XCITE and XS_DXCITE_SPINAVAG have the same number of elements, so something& & very unexpected has happened\" ) sum_spinmults = real ( sum ( ispinmults ), kind = dp ) ! -- σ_allspins += + σ(ispin) * (2S+1)/Σ(2S+1) do itrans = 1 , ntrans xs_xcite_spinavg ( itrans )% vec = xs_xcite_spinavg ( itrans )% vec & + xs_xcite ( idxmap ( itrans ))% vec * ispinmults ( ispin ) / sum_spinmults xs_dxcite_spinavg ( itrans )% vec = xs_dxcite_spinavg ( itrans )% vec & + xs_dxcite ( idxmap ( itrans ))% vec * ispinmults ( ispin ) / sum_spinmults enddo end subroutine add_xs_contrib_this_spin ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_xs_from_smat ( prob , transitions , egrid_tot , xs_xcite , xs_dxcite , xs_zero_threshold ) !! Calculate excitation and de-excitation cross sections from probabilities use rotex__kinds , only : dp use rotex__types , only : rvector_type , asymtop_rot_transition_type , asymtop_rot_channel_type use rotex__arrays , only : size_check use rotex__constants , only : pi implicit none type ( rvector_type ), intent ( in ) :: prob (:) !! Array of arrays of probabilities P type ( asymtop_rot_transition_type ), intent ( inout ), allocatable :: transitions (:) !! Array of transitions between states lo -> up real ( dp ), intent ( in ) :: egrid_tot (:) !! Array of total energies on which the calculations were performed type ( rvector_type ), intent ( out ), allocatable :: xs_xcite (:) !! Array of arrays of excitation cross sections σ ~ P/E type ( rvector_type ), intent ( out ), allocatable :: xs_dxcite (:) !! Array of arrays of de-excitation cross sections σ ~ P/E real ( dp ), intent ( in ) :: xs_zero_threshold !! Transitions with excitation and de-excitation cross sections below this will !! be removed logical , allocatable :: keeptrans (:) integer :: ntrans , itrans , iemin , nlo , nup , ne real ( dp ) :: Elo , Eup real ( dp ), allocatable :: Eel_ex (:), Eel_dex (:) type ( asymtop_rot_channel_type ) :: lo , up ntrans = size ( prob , 1 ) call size_check ( transitions , ntrans , \"TRANSITIONS\" ) ne = size ( egrid_tot , 1 ) ! -- allocate cross sections to have the same size as egrid allocate ( xs_xcite ( ntrans ), xs_dxcite ( ntrans )) do itrans = 1 , ntrans allocate ( xs_xcite ( itrans )% vec ( ne ), source = 0.0_dp ) allocate ( xs_dxcite ( itrans )% vec ( ne ), source = 0.0_dp ) enddo allocate ( keeptrans ( ntrans ), source = . true .) do itrans = 1 , ntrans ! -- get state info for this transition lo = transitions ( itrans ) % lo up = transitions ( itrans ) % up nlo = lo % n nup = up % n Elo = lo % E Eup = up % E ! -- find the starting point of our energy grid iemin = findloc ( prob ( itrans ) % vec (:) . gt . 0.0_dp , . true ., 1 ) ! -- electron energy grids Eel_ex = egrid_tot ( iemin :) - Elo Eel_dex = egrid_tot ( iemin :) - Eup ! -- cross sections xs_xcite ( itrans ) % vec ( iemin :) = prob ( itrans )% vec ( iemin :) * pi / ( 2 * Eel_ex (:)) / ( 2 * Nlo + 1 ) xs_dxcite ( itrans ) % vec ( iemin :) = prob ( itrans )% vec ( iemin :) * pi / ( 2 * Eel_dex (:)) / ( 2 * Nup + 1 ) if ( all ( xs_xcite ( itrans ) % vec ( iemin :). gt . xs_zero_threshold ) ) cycle if ( all ( xs_dxcite ( itrans ) % vec ( iemin :). gt . xs_zero_threshold ) ) cycle keeptrans ( itrans ) = . false . enddo xs_xcite = pack ( xs_xcite , keeptrans ) xs_dxcite = pack ( xs_dxcite , keeptrans ) transitions = pack ( transitions , keeptrans ) end subroutine get_xs_from_smat ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine combine_cb_smat_xs ( & cfg & , egrid_cb & , egrid_tot_smat & , transitions_cb & , xs_xcite_pcb & , xs_xcite_tcb & , transitions_smat & , xs_xcite_smat & , xs_dxcite_smat & ) !! Combine Coulomb-Born and S-matrix cross sections to be on the same electron energy grid. !! In general, a different number of transitions will exist for the Coulomb-Born cross sections !! and for the S-matrix cross sections. This routine matches the transitions, interpolates the !! CB cross sections to the total energy grid used by the S-matrix routines, and adds them !! together: !!   σ(tot) = σ(S-mat) + σ(TCB) - σ(PCB) use rotex__types , only : rvector_type , art_type => asymtop_rot_transition_type , findloc_transitions & , config_type , n_states_type use rotex__system , only : stdout , stderr , die , DS => DIRECTORY_SEPARATOR use rotex__arrays , only : append_uniq , size_check use rotex__splines , only : interpolate_replace use rotex__writing , only : write_cb_xs_to_file , write_smat_xs_to_file , write_total_xs_to_file implicit none type ( config_type ), intent ( in ) :: cfg !! Program config variables type ( rvector_type ), intent ( in ) :: egrid_cb (:) !! Array of arrays of electron energy grids for the CB cross sections for each transition real ( dp ), intent ( in ) :: egrid_tot_smat (:) !! The total energy grid on which the S-matrix cross sections were evaluated type ( art_type ), intent ( in ) :: transitions_cb (:) !! Array of arrays of transition between two rotational states lo and up in the CB approx type ( rvector_type ), intent ( inout ) :: xs_xcite_pcb (:) !! Array of arrays of partial CB cross sections for each transition (excitation only, de-excitation handled by detailed balance) type ( rvector_type ), intent ( inout ) :: xs_xcite_tcb (:) !! Array of arrays of total CB cross sections for each transition (excitation only, de-excitation handled by detailed balance) type ( art_type ), intent ( in ) :: transitions_smat (:) !! Array of arrays of transition between two rotational states lo and up using the S-matrix type ( rvector_type ), intent ( inout ) :: xs_xcite_smat (:) !! Array of arrays of S-matrix cross sections for each transition; excitation type ( rvector_type ), intent ( inout ) :: xs_dxcite_smat (:) !! Array of arrays of S-matrix cross sections for each transition; de-excitation integer :: itrans_cb , itrans_smat , itrans_all integer :: ntrans_cb , ntrans_smat , ntrans_all , nlo , nup integer , allocatable :: idx_all2smat (:), idx_all2cb (:) !! Mappings between various transition arrays integer , allocatable :: idx_smat (:) !! Indices for the S-matrix energy grid after interpolation (some energies might have been removed) logical :: warned_smat real ( dp ) :: Eground , Elo , Eup , dE real ( dp ), allocatable :: xs_pcb (:), xs_tcb (:), Egrid_xcite (:), Egrid_dxcite (:) real ( dp ), allocatable :: egrid_tot_cb (:) real ( dp ), allocatable :: xs_xcite_combined (:) !! Array of combined S-matrix + TCB - PCB cross sections; excitation real ( dp ), allocatable :: xs_dxcite_combined (:) !! Array of combined S-matrix + TCB - PCB cross sections; de-excitation character (:), allocatable :: total_xs_output_dir type ( art_type ), allocatable :: transitions_all (:) ! -- size checks on the arrays ntrans_cb = size ( transitions_cb , 1 ) call size_check ( egrid_cb , ntrans_cb , \"EGRID_CB\" ) call size_check ( xs_xcite_tcb , ntrans_cb , \"XS_XCITE_TCB\" ) call size_check ( xs_xcite_pcb , ntrans_cb , \"XS_XCITE_PCB\" ) write ( stdout , '(\"Detected \", I0, \" Coulomb-Born excitations\")' ) ntrans_cb ntrans_smat = size ( transitions_smat , 1 ) call size_check ( xs_xcite_smat , ntrans_smat , \"XS_XCITE_SMAT\" ) call size_check ( xs_dxcite_smat , ntrans_smat , \"XS_DXCITE_SMAT\" ) write ( stdout , '(\"Detected \", I0, \" S-matrix excitations\")' ) ntrans_smat ! -- create a unified transitions array call append_uniq ( transitions_all , transitions_smat ) call append_uniq ( transitions_all , transitions_cb ) ntrans_all = size ( transitions_all , 1 ) write ( stdout , '(\"Detected \", I0, \" unique excitations between the Coulomb-Born and S-matrix& & transitions\")' ) ntrans_all write ( stdout , * ) ! -- mapping from total transitions to CB and S-matrix transitions idx_all2cb = findloc_transitions ( transitions_all , transitions_cb ) idx_all2smat = findloc_transitions ( transitions_all , transitions_smat ) ! -- the rotational ground state (may not be 0, like when using CDMS averaging) Eground = minval ( transitions_smat (:) % lo % E ) Eground = minval ([ Eground , transitions_cb (:) % lo % E ]) warned_smat = . false . ! -- loop over all transitions transloop : do itrans_all = 1 , ntrans_all itrans_smat = idx_all2smat ( itrans_all ) itrans_cb = idx_all2cb ( itrans_all ) total_xs_output_dir = cfg % output_directory // \"Total\" // DS if ( itrans_cb . eq . 0 ) then if ( itrans_smat . eq . 0 ) call die ( \"Found a transition that is not in either the S-matrix& & or the CB transitions arrays ! Sounds like a bug.\" ) ! -- no CB transition, but we do have an S-matrix. Print the corresponding S-matrix !    cross sections as the Total cross sections call write_smat_xs_to_file ( & \"Total\" & , total_xs_output_dir & , cfg % zaxis & , egrid_tot_smat & , transitions_all ( itrans_all ) & , xs_xcite_smat ( itrans_smat )% vec & , xs_dxcite_smat ( itrans_smat )% vec & , cfg % lmax_kmat & ) ! -- transitions are unique, so it should be safe to deallocate here deallocate ( xs_xcite_smat ( itrans_smat )% vec ) deallocate ( xs_dxcite_smat ( itrans_smat )% vec ) ! -- move on to next transition cycle transloop elseif ( itrans_smat . eq . 0 ) then ! -- no S-matrix transition, but we do have an Coulomb-Born transition. if ( warned_smat . eqv . . false .) then warned_smat = . true . write ( stderr , '(A)' ) & \"At least one transition has been detected that is available in the CB approx but not with& & the supplied S-matrix. This may or may not be an error.\" write ( stderr , '(A)' ) & & \"This should ONLY happen if XS_ZERO_THRESHOLD was set to some positive value, in which& & case the S-matrix amplitudes probably experience some destructive interference.\" write ( stderr , '(A)' ) & & \"Otherwise, the S-matrix should cover at least all dipole-allowed transitions.\" endif ! -- write CB excitation as Total excitation call write_CB_xs_to_file ( & \"Total\" & , total_xs_output_dir & , cfg % zaxis & , egrid_cb ( itrans_cb )% vec & , xs_xcite_tcb ( itrans_cb )% vec & , transitions_all ( itrans_all )% lo & , transitions_all ( itrans_all )% up & , \"inf\" & , \"TCB\" & ) ! -- convert σ excite  to σ de-excite nlo = transitions_all ( itrans_all )% lo % n nup = transitions_all ( itrans_all )% up % n Elo = transitions_all ( itrans_all )% lo % E Eup = transitions_all ( itrans_all )% up % E dE = Eup - Elo Egrid_dxcite = egrid_cb ( itrans_cb )% vec - dE xs_tcb = xs_xcite_tcb ( itrans_cb )% vec * egrid_cb ( itrans_cb )% vec / Egrid_dxcite & * real ( 2 * nlo + 1 , kind = dp ) / real ( 2 * nup + 1 , kind = dp ) ! -- write CB de-excitation as Total de-excitation call write_CB_xs_to_file ( & \"Total\" & , total_xs_output_dir & , cfg % zaxis & , egrid_cb ( itrans_cb )% vec - dE & , xs_tcb & , transitions_all ( itrans_all )% up & , transitions_all ( itrans_all )% lo & , \"inf\" & ) deallocate ( xs_tcb ) ! -- move to next transition cycle transloop endif ! -- At this part in the loop, we have both CB and S-matrix cross sections that !    need to be combined. Interpolate the CB cross sections (they have no resonances) !    to match the S-matrix energy grid ! -- CB grid is electron energy, convert to total energy egrid_tot_cb = egrid_cb ( itrans_cb ) % vec + Eup - Eground ! -- PCB call interpolate_replace ( & egrid_tot_cb & , egrid_tot_smat & , xs_xcite_pcb ( itrans_cb )% vec & , idx_smat & ) ! -- TCB call interpolate_replace ( & egrid_tot_cb & , egrid_tot_smat & , xs_xcite_tcb ( itrans_cb )% vec & ) ! -- σTot = σSmat + σTCB - σPCB (excitation) xs_xcite_combined = xs_xcite_smat ( itrans_smat )% vec ( idx_smat ) & + xs_xcite_tcb ( itrans_cb )% vec (:) & - xs_xcite_pcb ( itrans_cb )% vec (:) ! -- detailed balance, get de-excitation CB cross sections because we haven't stored !    those explicitly nlo = transitions_all ( itrans_all )% lo % n nup = transitions_all ( itrans_all )% up % n Elo = transitions_all ( itrans_all )% lo % E Eup = transitions_all ( itrans_all )% up % E dE = Eup - Elo ! -- electron energy grid for de-excitation Egrid_xcite = egrid_tot_smat ( idx_smat ) - Elo Egrid_dxcite = egrid_tot_smat ( idx_smat ) - Eup ! Egrid_dxcite = Egrid_xcite - dE if ( any ( Egrid_xcite . le . 0.0_dp )) call die ( \"Excitation electron energy grid has negative& & energies, which means there was an issue converting the CB electron-energy grid to& & a total-energy grid\" ) if ( any ( Egrid_dxcite . le . 0.0_dp )) call die ( \"De-excitation electron energy grid has negative& & energies, which means there was an issue converting the CB electron-energy grid to& & a total-energy grid\" ) ! -- σ(E1) * E1 = σ(E2) * E2 xs_pcb = xs_xcite_pcb ( itrans_cb )% vec & * Egrid_xcite & / Egrid_dxcite & * real ( 2 * nlo + 1 , kind = dp ) & / real ( 2 * nup + 1 , kind = dp ) xs_tcb = xs_xcite_tcb ( itrans_cb )% vec & * Egrid_xcite & / Egrid_dxcite & * real ( 2 * nlo + 1 , kind = dp ) & / real ( 2 * nup + 1 , kind = dp ) ! -- σTot = σSmat + σTCB - σPCB (de-excitation) xs_dxcite_combined = xs_dxcite_smat ( itrans_smat )% vec ( idx_smat ) & + xs_tcb (:) & - xs_pcb (:) ! -- no longer needed, deallocate deallocate ( xs_xcite_smat ( itrans_smat )% vec ) deallocate ( xs_xcite_pcb ( itrans_cb )% vec ) deallocate ( xs_xcite_tcb ( itrans_cb )% vec ) deallocate ( xs_dxcite_smat ( itrans_smat )% vec ) ! -- Write excitation to disk call write_total_xs_to_file ( & \"Total\" & , total_xs_output_dir & , cfg % zaxis & , egrid_tot_smat ( idx_smat ) - Elo & , transitions_all ( itrans_all ) & , xs_xcite_combined & , xs_dxcite_combined & , cfg % lmax_kmat & ) enddo transloop end subroutine combine_cb_smat_xs ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine convert_xcite2dxcite ( Eel_xcite , xs , transition ) !! Convert XS from excitation cross sections to de-excitation cross sections use rotex__kinds , only : dp use rotex__types , only : asymtop_rot_transition_type use rotex__system , only : die implicit none real ( dp ), intent ( in ) :: Eel_xcite (:) real ( dp ), intent ( inout ) :: xs (:) type ( asymtop_rot_transition_type ), intent ( in ) :: transition integer :: Nlo , Nup real ( dp ) :: Elo , Eup , dE real ( dp ), allocatable :: Eel_dxcite (:) Nlo = transition % lo % N Nup = transition % up % N Elo = transition % lo % E Eup = transition % up % E dE = Eup - Elo Eel_dxcite = Eel_xcite (:) - dE if ( any ( Eel_dxcite . le . 0 )) call die ( \"Non-positive electron energies when calculating& & de-excitation cross sections from excitation cross sections ! The excitation electron& & energy grid has values that are below threshold, which is not expected behavior !\" ) xs = xs * Eel_xcite / Eel_dxcite * real ( 2 * nlo + 1 , kind = dp ) / real ( 2 * nup + 1 , kind = dp ) end subroutine convert_xcite2dxcite ! ================================================================================================================================ ! end module rotex__drivers ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__drivers.f.html"},{"title":"rotex__cbxs.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__CBXS !! Routines to calculate cross sections in the Coulomb-Born approximation implicit none private public :: get_einsta_only public :: get_CB_xs_asym public :: M public :: xtrapolate_cb_xs ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_einsta_only ( einsta , nlo , nup , elo , eup , eigveclo , eigvecup & , use_CDMS , do_dipole , do_quadrupole , dipole_moments , quadrupole_moments ) !! Calculate only the Einstein A coefficeints for a transition use rotex__types , only : dp use rotex__system , only : die use rotex__constants , only : invc use rotex__functions , only : istriangle implicit none integer , intent ( in ) :: nlo !! the angular momentum quantum number N integer , intent ( in ) :: nup !! the angular momentum quantum number N' real ( dp ), intent ( in ) :: elo !! The energy (hartrees) of the initial state real ( dp ), intent ( in ) :: eup !! The energy (hartrees) of the final state real ( dp ), intent ( in ) :: eigveclo (:) !! Eigenvector of the initial state in the basis of symmetric top wavefunctions; the coefficients !! c&#94;{N,\\tau}_K) real ( dp ), intent ( in ) :: eigvecup (:) !! Eigenvector of the final state in the basis of symmetric top wavefunctions; the coefficients !! c&#94;{N',\\tau'}_{K}) real ( dp ), intent ( inout ) :: einsta !! The Einstein coefficient for the transition logical , intent ( in ) :: use_CDMS !! Whether to calculate the Einstein A coefficients ourselves (.true.) or to use values obtained !! from the CDMS catalogue (.false.) logical , intent ( in ) :: do_dipole , do_quadrupole complex ( dp ), intent ( in ), target :: dipole_moments ( 3 ) !! The spherical dipole moments complex ( dp ), intent ( in ), target :: quadrupole_moments ( 5 ) !! The spherical quadrupole moments integer :: lambda real ( dp ) :: omega , am_summation complex ( dp ), pointer :: multipole_moments (:) omega = eup - elo multipoles : do lambda = 1 , 1 am_summation = 0 select case ( lambda ) case ( 1 ) if ( do_dipole . eqv . . false .) cycle multipoles multipole_moments => dipole_moments case ( 2 ) if ( do_quadrupole . eqv . . false .) cycle multipoles multipole_moments => quadrupole_moments case default call die ( \"Somehow, λ ≠ 1 or 2\" ) end select ! -- enforce 3j rules if ( . false . . eqv . istriangle ( nlo , nup , lambda ) ) cycle multipoles ! -- do the summation over angular momenta and multipole components !    or use the CDMS Einstein A coeffs for the dipole case select case ( lambda ) case ( 1 ) if (( use_CDMS . eqv . . false .) . OR . einsta . eq . 0 ) then ! -- calculate the am_summation ourselves if not using the CDMS !    or if it was not present in the CDMS data call multipole_am_summation_asym ( am_summation , lambda , nlo , nup , multipole_moments , eigveclo , eigvecup ) else ! -- use pre-existing Einstein A coeff from the CDMS read nullify ( multipole_moments ) cycle multipoles endif case ( 2 ) call multipole_am_summation_asym ( am_summation , lambda , nlo , nup , multipole_moments , eigveclo , eigvecup ) end select nullify ( multipole_moments ) select case ( lambda ) case ( 1 ) einsta = einsta & + am_summation * 4._dp / 3._dp * ( omega * invc ) ** 3 * ( 2 * nlo + 1 ) case ( 2 ) einsta = einsta + am_summation * 2._dp / 1 5._dp * ( omega * invc ) ** 5 * ( 2 * nlo + 1 ) end select enddo multipoles end subroutine get_einsta_only ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_CB_xs_asym ( energies , sigma , Z & , N , Np , E , Ep , eigvec , eigvecp & , einsta , use_CDMS & , do_dipole , do_quadrupole & , dipole_moments , quadrupole_moments & , analytic_total_cb , lmax ) ! , analytic_total_cb, lmax, atol, rtol) !! Calculate the excitation and de-excitation cross sections (xs) for an asymmetric top up. !! The sum over partial waves is either truncated to l_\\text{max} or determined analytically. !! The summation over the angular momentum components, multipole terms, and partial waves are separable !! for each value of λ as summation = (sum over angular momentum and multipole moments) \\times (sum overpartial waves). use rotex__types , only : dp use rotex__system , only : die use rotex__constants , only : invc use rotex__functions , only : istriangle implicit none real ( dp ), intent ( in ) :: energies (:) !! Array of scattering energies to consider real ( dp ), intent ( out ), allocatable :: sigma (:) !! Cross sections calculated on a grid of scattering energies for Nτ \\rightarrow N'τ' !! Returned with the same size as `energies` integer , intent ( in ) :: Z !! Target charge integer , intent ( in ) :: N !! the angular momentum quantum number N integer , intent ( in ) :: Np !! the angular momentum quantum number N' real ( dp ), intent ( in ) :: E !! The energy (hartrees) of the initial state real ( dp ), intent ( in ) :: Ep !! The energy (hartrees) of the final state real ( dp ), intent ( in ) :: eigvec (:) !! Eigenvector of the initial state in the basis of symmetric top wavefunctions; the coefficients !! c&#94;{N,\\tau}_K) real ( dp ), intent ( in ) :: eigvecp (:) !! Eigenvector of the final state in the basis of symmetric top wavefunctions; the coefficients !! c&#94;{N',\\tau'}_{K}) real ( dp ), intent ( inout ) :: einsta !! The Einstein coefficient for the transition logical , intent ( in ) :: use_CDMS !! Whether to calculate the Einstein A coefficients ourselves (.true.) or to use values obtained !! from the CDMS catalogue (.false.) logical , intent ( in ) :: do_dipole , do_quadrupole complex ( dp ), intent ( in ), target :: dipole_moments ( 3 ) !! The spherical dipole moments complex ( dp ), intent ( in ), target :: quadrupole_moments ( 5 ) !! The spherical quadrupole moments logical , intent ( in ) :: analytic_total_cb (:) !! Array of values telling us whether we want to use the analytic expression for lmax -> infintiy integer , intent ( in ) :: lmax !! The max value of the orbital angular momentum quantum number l to consider complex ( dp ), pointer :: multipole_moments (:) integer :: nE integer :: lambda real ( dp ) :: am_summation real ( dp ) :: omega real ( dp ), allocatable :: pw_summation (:) nE = size ( energies , 1 ) omega = Ep - E if ( Z . eq . 0 ) call die ( \"Coulomb-Born method should not be called on neutral targets !\" ) ! -- (re)allocate sigma arrays if necessary if ( allocated ( sigma )) then if ( size ( sigma , 1 ) . ne . nE ) then deallocate ( sigma ) allocate ( sigma ( nE )) endif else allocate ( sigma ( nE )) endif allocate ( pw_summation ( nE )) sigma = 0 ! -- loop over dipole, quadrupole terms multipoles : do lambda = 1 , 1 ! multipoles: do lambda = 1, 2 am_summation = 0 pw_summation = 0 select case ( lambda ) case ( 1 ) if ( do_dipole . eqv . . false .) cycle multipoles multipole_moments => dipole_moments case ( 2 ) if ( do_quadrupole . eqv . . false .) cycle multipoles multipole_moments => quadrupole_moments case default call die ( \"Somehow, lambda is neither 1 nor 2\" ) end select ! -- enforce 3j rules to avoid extra computation if ( . false . . eqv . istriangle ( N , Np , lambda ) ) cycle multipoles ! -- do the summation over angular momenta and multipole components !    or use the CDMS Einstein A coeffs for the dipole case select case ( lambda ) case ( 1 ) if (( use_CDMS . eqv . . false .) . OR . einsta . eq . 0 ) then ! -- calculate the am_summation ourselves call multipole_am_summation_asym ( am_summation , lambda , N , Np , multipole_moments , eigvec , eigvecp ) else ! -- use pre-existing Einstein A coeff from the CDMS read am_summation = einsta * 3._dp / 4._dp * ( omega * invc ) ** ( - 3 ) / ( 2 * N + 1 ) endif case ( 2 ) call multipole_am_summation_asym ( am_summation , lambda , N , Np , multipole_moments , eigvec , eigvecp ) end select nullify ( multipole_moments ) if ( abs ( am_summation ) . lt . 1e-16 ) cycle multipoles if ( am_summation . lt . 0 ) call die ( \"The angular momentum summation is negative, which is not physical !\" ) ! -- if the summation is basically 0 for this multipole term, check the next one ! if(am_summation .lt. 1e-16_dp) cycle multipoles ! -- do the summation over partial waves if ( analytic_total_cb ( lambda ) . eqv . . true .) then call get_infinite_pwsum ( pw_summation , energies , E , Ep , lambda , Z ) else call get_truncated_pwsum ( pw_summation , energies , E , Ep , lambda , lmax , Z ) endif if ( any ( pw_summation . lt . 0 )) & call die ( \"The partial wave summation is negative for at least one energy, which is not physical !\" ) sigma = sigma + pw_summation * am_summation / ( 2 * lambda + 1 ) select case ( lambda ) case ( 1 ) if (( use_CDMS . eqv . . false .) . OR . einsta . eq . 0 ) then einsta = einsta & + am_summation * 4._dp / 3._dp * ( omega * invc ) ** 3 * ( 2 * N + 1 ) endif case ( 2 ) einsta = einsta + am_summation * 2._dp / 1 5._dp * ( omega * invc ) ** 5 * ( 2 * N + 1 ) end select enddo multipoles nancheck : block use rotex__system , only : stderr use ieee_arithmetic , only : ieee_is_nan integer :: i integer , allocatable :: indices (:) if ( all ( ieee_is_nan ( sigma ) . eqv . . false .)) exit nancheck indices = [( i , i = 1 , size ( sigma , 1 ))] indices = pack ( indices , ieee_is_nan ( sigma ) . eqv . . true .) write ( stderr , '(A)' , advance = \"no\" ) \"NaNs detected at the following indices:\" write ( stderr , * ) indices write ( stderr , '(A, I0)' ) \"Lmax = \" , lmax call die ( \"NaN(s) detected in cross sections ! Maybe lmax is too big for wigner& & or Ei is too small for the hypergeometric functions (or their normalizations)\" ) end block nancheck ! -- σ: N Ka Kc -> N' Ka' Kc' (2N'+1 factor for excitation cross sections) sigma = sigma * ( 2 * Np + 1 ) ! -- A: N Ka Kc <- N' Ka' Kc' (divide out the initial 2N'+1) ! einsta  = einsta * (2*N+1) end subroutine get_CB_xs_asym ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine multipole_am_summation_asym ( summation , lambda , N , Np , multipole_moments , eigvec , eigvecp ) !! Carry out the summation of the angular momentum projections !! and multipole components use rotex__types , only : dp use rotex__system , only : die use rotex__wigner , only : wigner3j implicit none real ( dp ), intent ( out ) :: summation !! The result of the summation integer , intent ( in ) :: lambda !! The multipole expansion term !! 1: dipole !! 2: quadrupole integer , intent ( in ) :: N !! the quantum number N integer , intent ( in ) :: Np !! the quantum number N' complex ( dp ), intent ( in ) :: multipole_moments (:) !! array of spherical multipole moments real ( dp ), intent ( in ) :: eigvec (:) !! The eigenvector for the initial state Nτ real ( dp ), intent ( in ) :: eigvecp (:) !! The eigenvector for the final state N'τ' integer :: ilambda1 , ilambda2 integer :: mu1 , mu2 integer :: K1 , K2 integer :: K1p , K2p integer :: i_K1 , i_K2 integer :: i_K1p , i_K2p complex ( dp ) :: tmpz complex ( dp ) :: zummation zummation = 0 ! -- sum over μ, K, etc do mu1 = - lambda , lambda do K1 = - N , N ! do K1p = -Np, Np ! -- the only nonzero 3j term, cycle if it's not physical K1p = K1 + mu1 if ( abs ( K1p ) . gt . Np ) cycle ilambda1 = mu1 + lambda + 1 i_K1 = ( K1 + N ) + 1 i_K1p = ( K1p + Np ) + 1 do mu2 = - lambda , lambda do K2 = - N , N ! do K2p = -Np, Np ! -- the only nonzero 3j term, cycle if it's not physical K2p = K2 + mu2 if ( abs ( K2p ) . gt . Np ) cycle ilambda2 = mu2 + lambda + 1 i_K2 = ( K2 + N ) + 1 i_K2p = ( K2p + Np ) + 1 tmpz = multipole_moments ( ilambda1 ) & * conjg ( multipole_moments ( ilambda2 )) & * eigvecp ( i_K1p ) * eigvec ( i_K1 ) & * eigvec ( i_K2 ) * eigvecp ( i_K2p ) & * wigner3j ( 2 * N , 2 * Np , 2 * lambda , - 2 * K1 , 2 * K1p , - 2 * mu1 ) & * wigner3j ( 2 * N , 2 * Np , 2 * lambda , - 2 * K2 , 2 * K2p , - 2 * mu2 ) ! * wigner3j(2*N, 2*Np, 2*lambda,  2*K1, -2*K1p,  2*mu1)   & ! * wigner3j(2*N, 2*Np, 2*lambda,  2*K2, -2*K2p,  2*mu2) zummation = zummation + tmpz ! enddo ; enddo enddo enddo enddo ! enddo ; enddo enddo if ( abs ( zummation % im ) . gt . 1e-16 ) call die ( \"Large imaginary cross section detected. Check your multipole moments.\" ) summation = zummation % re end subroutine multipole_am_summation_asym ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine get_infinite_pwsum ( summation , energies , E , Ep , lambda , Z ) !! Return the analytic expression for the partial wave sum in the limit l\\to\\infty use rotex__types , only : dp use rotex__system , only : die , stderr use ieee_arithmetic , only : ieee_is_nan use rotex__constants , only : pi , im use rotex__functions , only : expm1 use rotex__hypergeometric , only : f21 implicit none real ( dp ), intent ( out ) :: summation (:) !! the result of the summation, for each energy real ( dp ), intent ( in ) :: energies (:) !! the scattering eneriges real ( dp ), intent ( in ) :: E !! the energy of the initial state Nτ real ( dp ), intent ( in ) :: Ep !! the energy of the final state N'τ' integer , intent ( in ) :: lambda !! the multipole term !! 1: dipole !! 2: quadrupole integer , intent ( in ) :: Z !! Target charge logical :: flag integer :: ie , nE integer :: iemin real ( dp ) :: k , kp real ( dp ) :: eta , etap real ( dp ) :: dE real ( dp ) :: x complex ( dp ), parameter :: onez = ( 1 , 0 ) if ( lambda . ne . 1 ) call die ( \"analytic partial wave sum not available for lambda =/= 1\" ) nE = size ( energies , 1 ) dE = Ep - E flag = . false . summation = 0 iemin = findloc ( energies . gt . dE , . true ., 1 ) !$omp parallel do default(none) & !$omp& shared(energies, summation, E, Ep, dE, lambda, Z, iemin, nE, flag) & !$omp& private(ie, k, kp, eta, etap, x) do ie = iemin , nE ! do concurrent(ie = 1 : nE) k = sqrt ( 2 * energies ( ie )) kp = sqrt ( 2 * ( energies ( ie ) - dE )) eta = - Z / k etap = - Z / kp x = - 4 * eta * etap / (( etap - eta ) ** 2 ) summation ( ie ) = - 16 * pi * pi * pi / ( k * k * k * kp ) * x & * exp ( 2 * pi * eta ) / ( expm1 ( 2 * pi * eta ) * expm1 ( 2 * pi * etap ) ) & * real ( & f21 ( im * eta , im * etap , onez , x ) & * f21 ( - im * eta + 1 , - im * etap + 1 , 2 * onez , x ), kind = dp & ) ! * real(F21(im*eta, im*etap, onez, zx) * F21(-im*eta + 1, -im*etap + 1, 2*onez, zx), kind = dp) if ( summation ( ie ) . ge . 0 ) cycle if ( flag . eqv . . true .) cycle flag = . true . block use rotex__constants , only : au2ev write ( stderr , * ) write ( stderr , * ) E * au2ev , Ep * au2ev write ( stderr , * ) energies ( ie ) * au2ev , ( energies ( ie ) - dE ) * au2ev write ( stderr , * ) ie , energies ( ie ), eta , etap , x , 1 / ( 1 - x ) write ( stderr , '(A)' ) \"WARN: negative cross sections when evaluating the infinite partial wave sum.\" end block enddo !$omp end parallel do end subroutine get_infinite_pwsum ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine get_truncated_pwsum ( summation , energies , E , Ep , lambda , lmax , Z ) !! Calculate the truncated partial wave sum !! \\sum\\limits_{ll'}&#94;{\\l_\\text{max}} (2l+1)(2l'+1) (l,l,\\lambda;0,0,0)&#94;2 |M&#94;\\lambda_{ll'}|&#94;2, given in !!   \"Electromagnetic Excitation: Theory of Coulomb Excitation with Heavy Ions \" by Kurt Alder and Aage Winther, Chapter IX, !!    section 2, page 244, equation 14. !! The integral given in that text is I&#94;\\lambda_{ll'}=-4M&#94;\\lambda_{ll'} in atomic units, based on equations 7 and 11 of the !! same section. For values of l larger than 1, a recursion formula is used for the integral M&#94;\\lambda_{ll'}, given in !!   \"Study of Nuclear Structure by Electromagnetic Excitation with Accelerated Ions\" by K. Alder, A. Bohr, T. Huus, !!    B. Mottelson, and A. Winther, equation II B.70–71 on page 453 for the λ=1 case. use rotex__types , only : dp use rotex__system , only : stderr ! use WignerSymbol, only: wigner3j use rotex__wigner , only : wigner3j use rotex__constants , only : pi , CB_MINT_IMAG_THRESH use rotex__functions , only : istriangle ! use rotex__wigner, only: wigner3j => threej implicit none real ( dp ), intent ( out ) :: summation (:) !! the summation to carry out for each energy real ( dp ), intent ( in ) :: energies (:) !! scattering energies (au) real ( dp ), intent ( in ) :: E !! energy of the initial (lower) state real ( dp ), intent ( in ) :: Ep !! energy of the final (higher) state integer , intent ( in ) :: lambda !! the multipole> !! 1: dipole !! 2: quadrupole integer , intent ( in ) :: lmax !! the max partial wave to consider integer , intent ( in ) :: Z !! Target charge logical :: flag integer :: l integer :: iemin integer :: ie , nE real ( dp ) :: k , kp real ( dp ) :: dE ! real(dp), allocatable :: weights(:) ! real(dp), allocatable :: M1(:) ! real(dp), allocatable :: M2(:) real ( dp ) :: weights ( 0 : lmax - lambda ) complex ( dp ) :: M1 ( 0 : lmax - lambda ) complex ( dp ) :: M2 ( 0 : lmax - lambda ) nE = size ( energies , 1 ) dE = Ep - E flag = . false . summation = 0 ! -- the starting energy index to ensure positive energies iemin = findloc ( energies . gt . dE , . true ., 1 ) ! -- the sum over ll' !$omp parallel do default(none) & !$omp& shared(energies, summation, E, Ep, dE, lambda, Z, iemin, nE, flag, lmax) & !$omp& private(ie, k, kp, weights, l, M1, M2) nrg : do ie = iemin , nE k = sqrt ( 2 * energies ( ie )) kp = sqrt ( 2 * ( energies ( ie ) - dE )) ! -- build the 3j symbols (they're symmetric w.r.t l and lp for λ=1) and integrals that we'll sum over. We only !    go to l=lmax-λ because we will get the values M_c{l+λ, l} and the l+λ value is what will be at most lmax. !    Because the dipole recursion is second order and only mixed sequential values of l with the same λ, we can !    calculate each sequence separately, !      - M_{l+λ,l}(k,k') !      - M_{l+λ,l}(k',k) !    and then just take the sum over these arrays with their 3j weights weights = [( ( 2 * l + 1 ) * ( 2 * ( l + lambda ) + 1 ) * wigner3j ( 2 * l , 2 * ( lambda + l ), 2 * lambda , 0 , 0 , 0 ) ** 2 , l = 0 , lmax - lambda )] M1 = Mrecur ( lambda , lmax - lambda , kp , k , Z ) M2 = Mrecur ( lambda , lmax - lambda , k , kp , Z ) if ( any ( abs ( M1 % im ) . gt . CB_MINT_IMAG_THRESH ) . OR . any ( abs ( M2 % im ) . gt . CB_MINT_IMAG_THRESH )) then write ( stderr , * ) write ( stderr , '(\"WARN: Skipping energy \", I0, \": the Coulomb integrals are nonreal\")' ) ie write ( stderr , * ) cycle nrg endif summation ( ie ) = 16 * pi * kp / k * sum ( weights * ( abs ( M1 ) ** 2 + abs ( M2 ) ** 2 ) ) if ( summation ( ie ) . ge . 0 ) cycle if ( flag . eqv . . true .) cycle flag = . true . write ( stderr , * ) write ( stderr , '(A)' ) \"WARN: negative cross sections when evaluating the truncated partial wave sum.\" enddo nrg !$omp end parallel do end subroutine get_truncated_pwsum ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental function M ( l , ki , kf , Z ) result ( res ) !! Calculates the integral M&#94;\\lambda_{l+λ,l} via the expression given in !!   \"Electromagnetic Excitation: Theory of Coulomb Excitation with Heavy Ions \" by Kurt Alder and Aage Winther, Chapter IX, !!    section 2, page 244, equation 14. !! for λ = 1, where -4M&#94;\\lambda_{l+λ,l} = I&#94;λ_{l+λ, l}. There is an expression for λ = 2 in !!   \"Study of Nuclear Structure by Electromagnetic Excitation with Accelerated Ions\" by K. Alder, A. Bohr, T. Huus, !!   B. Mottelson, and A. Winther, but only the dipole is used (at least for now). use rotex__types , only : dp use rotex__constants , only : im , pi use rotex__polygamma , only : lgamma => log_gamma use rotex__functions , only : factorial use rotex__hypergeometric , only : f21 implicit none integer , intent ( in ) :: l real ( dp ), intent ( in ) :: ki , kf integer , intent ( in ) :: Z complex ( dp ) :: res real ( dp ) :: etai , etaf , deta , x0 complex ( dp ) :: c1 , c2 etai = - Z / ki etaf = - Z / kf deta = etaf - etai x0 = - 4 * etaf * etai / deta ** 2 c1 = cmplx ( 2 * l + 2 , kind = dp ) c2 = cmplx ( 2 * l + 4 , kind = dp ) ! -- the original formula assumes k > k' (ki > kf). This is the symmetrized version so that we can !    freely call this procedure while switching ki and kf without worry. The only changes are to the !    `etaf - etai` and `deta` terms. Of course, ki and kf are both assumed to be positive given the context !    of electronic excitation res = 2 * abs (( etaf - etai ) / ( etaf + etai )) ** ( im * ( etaf + etai )) & * exp ( pi * abs ( deta ) / 2 ) * ( - x0 ) ** ( l + 1 ) / factorial ( 2 * l + 2 ) & * abs ( exp ( lgamma ( l + 1 + im * etai ) + lgamma ( l + 2 + im * etaf ) ) ) & * ( etai * F21 ( l + 1 - im * etai , l + 1 - im * etaf , c1 , x0 ) & - etaf * abs ( l + 1 + im * etai ) ** 2 / (( 2 * l + 2 ) * ( 2 * l + 3 )) * ( - x0 ) * F21 ( l + 2 - im * etai , l + 2 - im * etaf , c2 , x0 ) & ) ! -- get the integral M, not I res = res / ( - 4.0_dp ) end function M ! ------------------------------------------------------------------------------------------------------------------------------ ! function Mrecur ( lambda , ltarg , ki , kf , Z ) result ( res ) !! Calculate all integrals M&#94;\\lambda_{λ,0} to (M&#94;\\lambda_{l_text[targ]+λ,l_\\text{targ}}) via recursion formula !!   \"Study of Nuclear Structure by Electromagnetic Excitation with Accelerated Ions\" by K. Alder, A. Bohr, T. Huus, !!   B. Mottelson, and A. Winther, equation II B.70–71 on page 453 for the λ=1 case. use rotex__types , only : dp , qp use rotex__system , only : die , stderr implicit none integer , intent ( in ) :: lambda integer , intent ( in ) :: ltarg !! The truncating value of l+λ, l for the recursion. real ( dp ), intent ( in ) :: ki , kf integer , intent ( in ) :: Z !! Target charge complex ( dp ) :: res ( 0 : ltarg ) complex ( dp ) :: M0 , M1 complex ( qp ) :: resqp ( 0 : ltarg ) integer :: l real ( qp ) :: etai , etaf etai = real ( - Z / ki , kind = qp ) etaf = real ( - Z / kf , kind = qp ) if ( ltarg . lt . 2 ) then res = [( M ( l , kf , ki , Z ), l = 0 , ltarg )] block use ieee_arithmetic , only : isnan => ieee_is_nan if ( any ( isnan ( abs ( res )))) then write ( stderr , * ) write ( stderr , '(6(A15))' ) \"λ\" , \"l\" , \"kf\" , \"ki\" , \"ηf\" , \"ηi\" write ( stderr , '(2I15, 4e15.6)' ) lambda , ltarg , kf , ki , etaf , etai write ( stderr , * ) res call die ( \"NaNs detected\" ) endif end block return endif ! -- starting values M0 = M ( 0 , kf , ki , Z ) M1 = M ( 1 , kf , ki , Z ) resqp ( 0 ) = cmplx ( M0 % re , M0 % im , kind = qp ) resqp ( 1 ) = cmplx ( M1 % re , M1 % im , kind = qp ) select case ( lambda ) case ( 1 ) do l = 2 , ltarg resqp ( l ) = - ( y1 ( l , etai , etaf ) * resqp ( l - 2 ) + y2 ( l , etai , etaf ) * resqp ( l - 1 )) / y3 ( l , etai , etaf ) enddo case default call die ( \"λ =/= 1 unsupported\" ) end select res = cmplx ( resqp % re , resqp % im , kind = dp ) ! ------------------------------------------------------------------------------------------------------------------------------ ! contains ! ------------------------------------------------------------------------------------------------------------------------------ ! ! -- The recursion terms impure elemental function y1 ( l , etai , etaf ) result ( res ) use rotex__types , only : dp use rotex__constants , only : im implicit none integer , intent ( in ) :: l real ( qp ), intent ( in ) :: etai , etaf real ( qp ) :: res res = 2 * etai * etaf * abs ( l - 1 + im * etaf ) * abs ( l + im * etai ) end function y1 impure elemental function y2 ( l , etai , etaf ) result ( res ) use rotex__types , only : dp use rotex__constants , only : im implicit none integer , intent ( in ) :: l real ( qp ), intent ( in ) :: etai , etaf real ( qp ) :: res res = - 4 * etai ** 2 * etaf ** 2 - l * ( 2 * l + 1 ) * etai ** 2 - l * ( 2 * l - 1 ) * etaf ** 2 end function y2 impure elemental function y3 ( l , etai , etaf ) result ( res ) use rotex__types , only : dp use rotex__constants , only : im implicit none integer , intent ( in ) :: l real ( qp ), intent ( in ) :: etai , etaf real ( qp ) :: res res = 2 * etai * etaf * abs ( l + im * etaf ) * abs ( l + 1 + im * etai ) end function y3 end function Mrecur ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine xtrapolate_cb_xs ( Ei_xtrap , Ethresh , nE_xtrap , Eel , xs_pcb , xs_tcb ) !! Extrapolate an excitation/de-excitation cross section to its excitation threshold. !! Re-allocates Eel and xs to contain the extrapolated values use rotex__kinds , only : dp use rotex__system , only : die use rotex__functions , only : logrange implicit none real ( dp ), intent ( in ) :: Ei_xtrap !! Extrapolate down Ethresh + Ei_xtrap real ( dp ), intent ( in ) :: Ethresh !! The excitation threshold integer , intent ( in ) :: nE_xtrap !! Number of extrapolation energies real ( dp ), intent ( inout ), allocatable :: Eel (:) !! On input, the electron energy grid. !! On output, the electron energy grid with extrapolated energies prepended real ( dp ), intent ( inout ), allocatable :: xs_pcb (:) !! On input, the partial Coulomb-Born cross sections. !! On output, the partial Coulomb-Born cross sections with extrapolated cross sections prepended real ( dp ), intent ( inout ), allocatable :: xs_tcb (:) !! On input, the total Coulomb-Born cross sections. !! On output, the total Coulomb-Born cross sections with extrapolated cross sections prepended real ( dp ), allocatable :: Eel_pre (:), xs_pre_pcb (:), xs_pre_tcb (:) if ( nE_xtrap . le . 1 ) call die ( \"NE_XTRAP must be > 1\" ) ! -- extrapolated energies Eel_pre = logrange ( Ethresh + Ei_xtrap , Eel ( 1 ), nE_xtrap , inclast = . false .) ! -- extrapolated cross sections σ1*E1 = σ2*E2 xs_pre_pcb = xs_pcb ( 1 ) * Eel ( 1 ) / Eel_pre xs_pre_tcb = xs_tcb ( 1 ) * Eel ( 1 ) / Eel_pre ! -- new energy grid Eel = [ Eel_pre , Eel ] ! -- prepend extrapolated cross sections xs_pcb = [ xs_pre_pcb , xs_pcb ] xs_tcb = [ xs_pre_tcb , xs_tcb ] end subroutine xtrapolate_cb_xs ! ================================================================================================================================ ! end module rotex__CBXS ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__cbxs.f.html"},{"title":"rotex__kinds.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__kinds !! Contains kind definitions (double, xtended double, quad precision) implicit none private integer , parameter , public :: dp = selected_real_kind ( 15 ) integer , parameter , public :: xdp = selected_real_kind ( 18 ) integer , parameter , public :: qp = selected_real_kind ( 33 ) ! ================================================================================================================================ ! end module rotex__kinds ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__kinds.f.html"},{"title":"rotex__wigner.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__wigner !! Calculate the Wigner 3j symbols implicit none private public :: wigner3j public :: clebsch ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function clebsch ( j1 , m1 , j2 , m2 , j , m ) result ( res ) !! Returns the Clebsch-Gordan coefficient !! C&#94;{jm}_{j_1m_1,j_2m_2} \\equiv \\left\\langle j_1m_1,j_2_m2|jm \\right\\rangle !! by using its relation to the Wigner 3j symbol use rotex__types , only : dp use rotex__functions , only : neg implicit none integer , intent ( in ) :: j1 , m1 , j2 , m2 , j , m real ( dp ) :: res if ( m . ne . m1 + m2 ) then res = 0 return endif res = neg ( - j1 + j2 - m ) * sqrt ( real ( 2 * j + 1 , kind = dp )) * wigner3j ( 2 * j1 , 2 * j2 , 2 * j , 2 * m1 , 2 * m2 , - 2 * m ) end function clebsch ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function wigner3j ( dj1 , dj2 , dj3 , dm1 , dm2 , dm3 ) result ( res ) !! returns the Wigner 3j symbol via explicit calculation. These should probably be !! precomputed, but this works for now. The [WignerSymbol-f](https://github.com/0382/WignerSymbol-f) !! repo seems like a good implementation. The [wigner](https://github.com/ogorton/wigner) !! repo by ogorton takes up way too much memory for the high partial waves because !! it tries to allocate (2N+1)&#94;6 doubles. NOTE: for the high partial wave, we know that !! we'll only need values with m1 = m2 = m3 = 0, so take advantage of this ? use rotex__types , only : dp use rotex__system , only : die use rotex__constants , only : two use rotex__functions , only : istriangle , iseven , logfac => log_factorial implicit none integer , intent ( in ) :: dj1 , dj2 , dj3 !! twice the angular momenta j integer , intent ( in ) :: dm1 , dm2 , dm3 !! twice the angular momenta m real ( dp ) :: res !! the result integer :: dk , kmin , kmax real ( dp ) :: phase , summation , logs res = 0 ! -- check basic properties if ( dj1 . lt . 0 ) call die ( \"j1 cannot be less than 0 in the Wigner 3j symbol\" ) if ( dj2 . lt . 0 ) call die ( \"j2 cannot be less than 0 in the Wigner 3j symbol\" ) if ( dj3 . lt . 0 ) call die ( \"j3 cannot be less than 0 in the Wigner 3j symbol\" ) if (. not . istriangle ( dj1 , dj2 , dj3 )) return ! -- triangle inequality if ( dm1 + dm2 + dm3 . ne . 0 ) return ! -- m1 + m2 + m3 = 0 if (. not . iseven ( dj1 + dj2 + dj3 )) return ! -- j1 + j2 + j3 is integer if ( abs ( dm1 ) . gt . abs ( dj1 )) return if ( abs ( dm2 ) . gt . abs ( dj2 )) return if ( abs ( dm3 ) . gt . abs ( dj3 )) return phase = ( - 1.0_dp ) ** ( ( dj1 - dj2 - dm3 ) / two ) ! -- sqrt of factorials calculated as a logarithm logs = ( & logfac (( dj1 + dj2 - dj3 ) / two ) + logfac (( dj1 - dj2 + dj3 ) / two ) & + logfac (( - dj1 + dj2 + dj3 ) / two ) - logfac (( dj1 + dj2 + dj3 ) / two + 1 ) & + logfac (( dj1 - dm1 ) / two ) + logfac (( dj1 + dm1 ) / two ) & + logfac (( dj2 - dm2 ) / two ) + logfac (( dj2 + dm2 ) / two ) & + logfac (( dj3 - dm3 ) / two ) + logfac (( dj3 + dm3 ) / two ) & ) / two ! -- the summation variable z runs over the integers for which !    all factorial arguments are non negative kmin = max ( 0 , max ( ( dj2 - dj3 - dm1 ), ( dj1 - dj3 + dm2 ) ) ) kmax = min ( ( dj1 + dj2 - dj3 ), min ( ( dj1 - dm1 ), ( dj2 + dm2 ) ) ) summation = 0 ! -- this summation could easily be done recursively to avoid recalulating !    logfac for each k do dk = kmin , kmax , 2 summation = summation + ( - 1 ) ** ( dk / two ) & / exp ( logfac ( dk / two ) + logfac (( dj1 + dj2 - dj3 - dk ) / two ) + logfac (( dj1 - dm1 - dk ) / two ) & + logfac (( dj2 + dm2 - dk ) / two ) + logfac (( dj3 - dj2 + dm1 + dk ) / two ) + logfac (( dj3 - dj1 - dm2 + dk ) / two ) ) end do res = phase * exp ( logs ) * summation end function wigner3j ! ================================================================================================================================ ! end module rotex__wigner ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__wigner.f.html"},{"title":"rotex__writing.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__writing !! Procedures for writing data to disk implicit none private public :: write_lifetimes_to_file public :: write_channels_to_file public :: write_CB_xs_to_file public :: write_smat_xs_to_file public :: write_total_xs_to_file character ( * ), parameter :: ENERGY_XS_WRITE_FMT = '(2X, 2E30.20)' ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine write_lifetimes_to_file ( output_directory , N_min , N_max , N_states , zaxis ) !! Writes the states involved in the excitation and their lifetimes use rotex__types , only : dp , N_states_type use rotex__constants , only : au2ev , au2sec implicit none character ( * ), intent ( in ) :: output_directory !! The directory in which output files are placed integer , intent ( in ) :: N_min , N_max !! Minimum and maximum value of N for which lifetimes were evaluated type ( N_states_type ), intent ( in ) :: N_states (:) character ( 1 ), intent ( in ) :: zaxis !! The array of states integer :: funit integer :: inlo , i_tau integer :: N , Ka , Kc integer :: nc real ( dp ) :: E , EinstA , lifetime character (:), allocatable :: filename character (:), allocatable :: fmt character ( 15 ) :: lifetime_char filename = output_directory // \"lifetimes.dat\" open ( newunit = funit , file = filename ) nc = maxval ( N_states (:) % N ) + 1 ! -- write file header write ( funit , '(\"# The z-axis is aligned with the \", A, \" axis\")' ) zaxis write ( funit , '(\"# \", 3A6, 2A16)' ) \"N\" , \"Ka\" , \"Kc\" , \"energy (meV)\" , \"lifetime (s)\" do inlo = 1 , size ( N_states , 1 ) N = N_states ( inlo ) % N if ( N . lt . N_min ) cycle if ( N . gt . N_max ) cycle do i_tau = 1 , 2 * N + 1 Ka = N_states ( inlo ) % Ka ( i_tau ) Kc = N_states ( inlo ) % Kc ( i_tau ) E = N_states ( inlo ) % eigenH % eigvals ( i_tau ) * au2ev * 1000 EinstA = N_states ( inlo ) % einstA ( i_tau ) if ( EinstA . eq . 0 ) then write ( lifetime_char , '(A15)' ) \"inf\" else lifetime = 1 / EinstA * au2sec write ( lifetime_char , '(F15.6)' ) lifetime if ( lifetime . lt . 1e-2 . OR . lifetime . gt . 9.9e5 ) write ( lifetime_char , '(E15.6)' ) lifetime endif write ( funit , '(2X, 3I6)' , advance = \"no\" ) N , Ka , Kc fmt = '(X,F15.6)' if ( E . ne . 0 . AND . E . lt . 1e-2 ) fmt = '(X,E15.6)' write ( funit , fmt , advance = \"no\" ) E write ( funit , '(X, A)' ) lifetime_char enddo enddo close ( funit ) end subroutine write_lifetimes_to_file ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine write_CB_xs_to_file ( & prefix & , output_directory & , zaxis & , E_el & , xs & , init & , fin & , lmax & , xs_type & ) !! Writes a Coulomb-Born cross section to a file whos name and file header !! carry information about the state symmetry use rotex__types , only : dp , N_states_type , asymtop_rot_channel_type use rotex__characters , only : add_trailing , sub , sup use rotex__constants , only : au2eV , au2cm use rotex__functions , only : logrange implicit none character ( * ), intent ( in ) :: prefix !! filename prefix character ( * ), intent ( in ) :: output_directory !! The directory in which output files are placed character ( 1 ), intent ( in ) :: zaxis !! The A, B, or C axis that lies along z real ( dp ), intent ( in ) :: E_el (:) !! the scattering eneries in au real ( dp ), intent ( in ) :: xs (:) !! The excitation cross sections type ( asymtop_rot_channel_type ), intent ( in ) :: init , fin !! Initial and final states for this transition character ( * ), intent ( in ) :: lmax !! The max value of l for the CB cross sections (\"inf\" if total) character ( * ), intent ( in ), optional :: xs_type !! The kind of cross section that this is integer :: ie , iemin integer :: ni , nf , kai , kci , kaf , kcf , ne integer :: funit real ( dp ) :: Ei , Ef , dE character (:), allocatable :: state_name1 character (:), allocatable :: state_name2 character (:), allocatable :: filename character (:), allocatable :: prefix_local character (:), allocatable :: xs_type_ prefix_local = trim ( prefix ) xs_type_ = trim ( prefix ) ; if ( present ( xs_type )) xs_type_ = xs_type call add_trailing ( prefix_local , \".\" ) ne = size ( E_el , 1 ) ! -- filenames ni = init % n nf = fin % n kai = init % Ka kci = init % Kc kaf = fin % Ka kcf = fin % Kc allocate ( character ( 10 ) :: state_name1 ) allocate ( character ( 10 ) :: state_name2 ) write ( state_name1 , '(I0, \"_\", I0, \"_\", I0)' ) ni , kai , kci write ( state_name2 , '(I0, \"_\", I0, \"_\", I0)' ) nf , kaf , kcf state_name1 = trim ( state_name1 ) state_name2 = trim ( state_name2 ) ! -- get lower and upper state energies Ei = init % E Ef = fin % E dE = Ef - Ei ! -- write cross sections filename = output_directory // prefix_local // state_name1 // \".\" // state_name2 // \".dat\" open ( newunit = funit , file = filename ) call write_xs_header ( funit , zaxis , ni , kai , kci , nf , kaf , kcf , xs_type_ , lmax ) iemin = findloc ( xs . gt . 0 , . true ., 1 ) do ie = iemin , ne write ( funit , ENERGY_XS_WRITE_FMT ) E_el ( ie ) * au2eV , xs ( ie ) * au2cm * au2cm enddo close ( funit ) end subroutine write_CB_xs_to_file ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine write_smat_xs_to_file ( & prefix & , output_directory & , zaxis & , egrid_total & , transition & , exxs & , dexxs & , lmax & ) !! Writes an S-matrix (+CB) cross section to a file whos name and file header !! carry information about the state symmetry use rotex__types , only : dp , rvector_type , asymtop_rot_transition_type , asymtop_rot_channel_type use rotex__arrays , only : size_check use rotex__system , only : die , warn , mkdir use rotex__characters , only : add_trailing , sub , sup , i2c => int2char use rotex__constants , only : au2eV , au2cm , pi use rotex__functions , only : logrange implicit none character ( * ), intent ( in ) :: prefix !! filename prefix character ( * ), intent ( in ) :: output_directory !! The directory in which output files are placed character ( 1 ), intent ( in ) :: zaxis !! The A, B, or C axis that lies along z real ( dp ), intent ( in ) :: egrid_total (:) !! The grid of total energies in au type ( asymtop_rot_transition_type ), intent ( in ) :: transition !! The transition (excitation pair) to be consdered real ( dp ), intent ( in ) :: exxs (:) !! Array of excitation cross sections for this/all spin multiplicities real ( dp ), intent ( in ) :: dexxs (:) !! Array of de-excitation cross sections for all spin multiplicities integer , intent ( in ) :: lmax !! The max value of l for the K-matrices integer :: ie , iemin integer :: ne integer :: nlo , nup , kalo , kclo , kaup , kcup integer :: funit_ex , funit_dex real ( dp ) :: Elo , Eup , Eel_ex , Eel_dex , sigmaup , sigmadown character (:), allocatable :: state_name1 character (:), allocatable :: state_name2 character (:), allocatable :: filename_ex , filename_dex character (:), allocatable :: prefix_local type ( asymtop_rot_channel_type ) :: lo , up prefix_local = trim ( prefix ) call add_trailing ( prefix_local , \".\" ) ne = size ( egrid_total , 1 ) call size_check ( exxs , ne , \"EXXS\" ) call size_check ( dexxs , ne , \"DEXXS\" ) ! -- make sure the output directory exists before trying to create files therein call mkdir ( output_directory ) lo = transition % lo up = transition % up ! -- filenames nlo = lo % n nup = up % n kalo = lo % ka kclo = lo % kc kaup = up % ka kcup = up % kc if ( allocated ( state_name1 )) deallocate ( state_name1 ) if ( allocated ( state_name2 )) deallocate ( state_name2 ) allocate ( character ( 10 ) :: state_name1 ) allocate ( character ( 10 ) :: state_name2 ) write ( state_name1 , '(I0, \"_\", I0, \"_\", I0)' ) Nlo , Kalo , Kclo write ( state_name2 , '(I0, \"_\", I0, \"_\", I0)' ) Nup , Kaup , Kcup state_name1 = trim ( state_name1 ) state_name2 = trim ( state_name2 ) ! -- get upper and lower channel energy Elo = lo % E Eup = up % E ! -- write (de-)excitation data filename_ex = output_directory // prefix_local // state_name1 // \".\" // state_name2 // \".dat\" filename_dex = output_directory // prefix_local // state_name2 // \".\" // state_name1 // \".dat\" iemin = findloc ( exxs . gt . 0.0_dp , . true ., 1 ) open ( newunit = funit_ex , file = filename_ex ) open ( newunit = funit_dex , file = filename_dex ) call write_xs_header ( funit_ex , zaxis , Nlo , Kalo , Kclo , Nup , Kaup , Kcup , \"S-matrix\" , i2c ( lmax )) call write_xs_header ( funit_dex , zaxis , Nup , Kaup , Kcup , Nlo , Kalo , Kclo , \"S-matrix\" , i2c ( lmax )) do ie = iemin , ne sigmaup = exxs ( ie ) sigmadown = dexxs ( ie ) Eel_ex = egrid_total ( ie ) - Elo Eel_dex = egrid_total ( ie ) - Eup write ( funit_ex , ENERGY_XS_WRITE_FMT ) Eel_ex * au2eV , sigmaup * au2cm * au2cm write ( funit_dex , ENERGY_XS_WRITE_FMT ) Eel_dex * au2eV , sigmadown * au2cm * au2cm enddo close ( funit_ex ) close ( funit_dex ) end subroutine write_smat_xs_to_file ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine write_total_xs_to_file ( & prefix & , output_directory & , zaxis & , egrid_total & , transition & , xs_xcite & , xs_dxcite & , lmax & ) !! Write the total cross-sections (S-matrix + CB correction) to disk for a single transition use rotex__kinds , only : dp use rotex__types , only : asymtop_rot_transition_type , asymtop_rot_channel_type use rotex__characters , only : add_trailing , i2c => int2char use rotex__arrays , only : size_check use rotex__system , only : mkdir use rotex__constants , only : au2ev , au2cm implicit none character ( * ), intent ( in ) :: prefix !! filename prefix character ( * ), intent ( in ) :: output_directory !! The directory in which output files are placed character ( 1 ), intent ( in ) :: zaxis !! The A, B, or C axis that lies along z real ( dp ), intent ( in ) :: egrid_total (:) !! The grid of total energies in au type ( asymtop_rot_transition_type ), intent ( in ) :: transition !! The transition to write to file real ( dp ), intent ( in ) :: xs_xcite (:) !! Array of arrays of excitation cross sections for all spin multiplicities real ( dp ), intent ( in ) :: xs_dxcite (:) !! Array of arrays of de-excitation cross sections for all spin multiplicities integer , intent ( in ) :: lmax !! The max value of l for the K/S-matrices integer :: ne , ie , iemin integer :: nlo , nup , kalo , kaup , kclo , kcup integer :: funit_ex , funit_dex real ( dp ) :: Elo , Eup real ( dp ) :: Eel_dex , Eel_ex character (:), allocatable :: prefix_local , state_name1 , state_name2 , filename_ex , filename_dex character ( * ), parameter :: XS_TYPE = \"S-matrix + Coulomb-Born correction\" type ( asymtop_rot_channel_type ) :: lo , up prefix_local = trim ( prefix ) call add_trailing ( prefix_local , \".\" ) ne = size ( egrid_total , 1 ) call size_check ( xs_xcite , ne , \"XS_XCITE\" ) call size_check ( xs_dxcite , ne , \"XS_DXCITE\" ) call mkdir ( output_directory ) lo = transition % lo up = transition % up ! -- filenames nlo = lo % n nup = up % n kalo = lo % ka kclo = lo % kc kaup = up % ka kcup = up % kc if ( allocated ( state_name1 )) deallocate ( state_name1 ) if ( allocated ( state_name2 )) deallocate ( state_name2 ) allocate ( character ( 10 ) :: state_name1 ) allocate ( character ( 10 ) :: state_name2 ) write ( state_name1 , '(I0, \"_\", I0, \"_\", I0)' ) Nlo , Kalo , Kclo write ( state_name2 , '(I0, \"_\", I0, \"_\", I0)' ) Nup , Kaup , Kcup state_name1 = trim ( state_name1 ) state_name2 = trim ( state_name2 ) Elo = lo % E Eup = up % E ! -- filenames filename_ex = output_directory // prefix_local // state_name1 // \".\" // state_name2 // \".dat\" filename_dex = output_directory // prefix_local // state_name2 // \".\" // state_name1 // \".dat\" ! -- find first nonzero energy iemin = findloc ( xs_xcite . gt . 0.0_dp , . true ., 1 ) ! -- write data to file open ( newunit = funit_ex , file = filename_ex ) open ( newunit = funit_dex , file = filename_dex ) call write_xs_header ( funit_ex , zaxis , Nlo , Kalo , Kclo , Nup , Kaup , Kcup , XS_TYPE , i2c ( lmax ), \"∞\" ) call write_xs_header ( funit_dex , zaxis , Nup , Kaup , Kcup , Nlo , Kalo , Kclo , XS_TYPE , i2c ( lmax ), \"∞\" ) do ie = iemin , ne Eel_ex = egrid_total ( ie ) - Elo Eel_dex = egrid_total ( ie ) - Eup write ( funit_ex , ENERGY_XS_WRITE_FMT ) Eel_ex * au2ev , xs_xcite ( ie ) * au2cm * au2cm write ( funit_dex , ENERGY_XS_WRITE_FMT ) Eel_dex * au2ev , xs_dxcite ( ie ) * au2cm * au2cm enddo close ( funit_ex ) close ( funit_dex ) end subroutine write_total_xs_to_file ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure elemental function xtrap_xs(xs1, E1, Etarg) result(res) !   !! Extrapolate a cross section as 1/E towards 0, given the cross section xs1 at !   !! energy E1 !   use rotex__types, only: dp !   implicit none !   real(dp), intent(in) :: xs1, E1, Etarg !   real(dp) :: res !   res = xs1*E1/Etarg ! end function xtrap_xs ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine write_xs_header ( funit , axis , N , Ka , Kc , Np , kaup , kcup , xs_type , lmax , lmax2 ) use rotex__characters , only : ndigits , i2c => int2char implicit none integer , intent ( in ) :: funit character ( * ), intent ( in ) :: axis integer , intent ( in ) :: N , Ka , Kc , Np , kaup , kcup character (:), allocatable :: fmt , fmtp character (:), allocatable :: nc , ncp character ( * ), intent ( in ) :: xs_type character ( * ), intent ( in ) :: lmax character ( * ), intent ( in ), optional :: lmax2 ! -- determine how many characters to take up for N, Ka, and and values nc = i2c ( max ( ndigits ( N ), 2 ) + 1 ) ncp = i2c ( max ( ndigits ( Np ), 2 ) + 1 ) write ( funit , '(\"# Cross section type: \", A)' ) xs_type if ( present ( lmax2 )) then write ( funit , '(\"# S-matrix: l = 0 – \", A)' ) lmax write ( funit , '(\"# Coulomb-Born correction: l = \", A, \"..\", A)' ) achar ( ichar ( lmax ) + 1 ), lmax2 else write ( funit , '(\"# lmax: \", A)' ) lmax endif write ( funit , '(\"# The z-axis is aligned with the \", A, \" axis\")' ) axis write ( funit , '(\"# \", 2(A' // nc // ',\",\"), A' // nc // ')' , advance = \"no\" ) \"N\" , \"Ka\" , \"Kc\" write ( funit , '(2X,A)' , advance = \"no\" ) \"-->\" write ( funit , '(2(A' // ncp // ',\",\"), A' // ncp // ')' ) \"N\" , \"Ka\" , \"Kc\" fmt = '(2(I' // nc // ', \",\"), I' // nc // ',)' fmtp = '(2(I' // ncp // ', \",\"), I' // ncp // ',)' write ( funit , '(A)' , advance = \"no\" ) \"# \" write ( funit , fmt , advance = \"no\" ) N , Ka , Kc write ( funit , '(2X,A)' , advance = \"no\" ) \"-->\" write ( funit , fmtp ) Np , kaup , kcup write ( funit , '(\"# \", 2(A30))' ) \"scattering energy (eV)\" , \"cross section (cm²)\" end subroutine write_xs_header ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine write_channels_to_file ( filename , jmin , jmax , n_states , channels_l , channels_l_j , spin_isomer_kind , symaxis ) !! Write rotational channel info to file use rotex__types , only : dp , asymtop_rot_channel_l_type , asymtop_rot_channel_l_vector_type & , n_states_type , asymtop_rot_channel_type , operator (. eq .) use rotex__constants , only : au2ev use rotex__symmetry , only : spin_symmetry implicit none character ( * ), intent ( in ) :: filename !! File to which we write channels integer , intent ( in ) :: jmin , jmax !! Total angular momentum mim/max integer , intent ( in ) :: spin_isomer_kind !! Kind of nuclear spin to preserve character ( 1 ), intent ( in ) :: symaxis !! Symmetry axis for nuclear spin type ( n_states_type ), intent ( in ) :: n_states (:) type ( asymtop_rot_channel_l_type ), intent ( in ) :: channels_l (:) !! Rotational channels type ( asymtop_rot_channel_l_vector_type ), intent ( in ) :: channels_l_j ( jmin : jmax ) !! Rotational channels for each J type ( asymtop_rot_channel_type ) :: channel_without_l logical , allocatable :: jtest (:) integer :: funit , nchans , j integer :: in , n , itau , ka , kc , sym integer , allocatable :: lvals (:), jvals (:) real ( dp ) :: e nchans = size ( channels_l , 1 ) open ( newunit = funit , file = filename ) write ( funit , '(\"# \", 3(A7), A15, A7, 3X, A4, A7)' ) \"N\" , \"Ka\" , \"Kc\" , \"E (meV)\" , \"sym\" , \"l\" , \"J\" do in = 1 , size ( n_states , 1 ) n = n_states ( in ) % n do itau = 1 , 2 * n + 1 ka = n_states ( in ) % ka ( itau ) kc = n_states ( in ) % kc ( itau ) e = n_states ( in ) % eigenh % eigvals ( itau ) sym = spin_symmetry ( n , ka , kc , spin_isomer_kind , symaxis ) channel_without_l = asymtop_rot_channel_type ( nelec = 1 , e = e , n = n , ka = ka , kc = kc , sym = sym ) ! -- which l values are inlcuded ? lvals = channels_l % l lvals = pack ( lvals , channels_l (:) . eq . channel_without_l ) ! -- which J values are included ? jtest = [( any ( channels_l_j ( j ) % channels (:) . eq . channel_without_l ), j = jmin , jmax )] jvals = pack ([( j , j = jmin , jmax )], jtest ) ! -- N, Ka, Kc, E write ( funit , '(2X, 3(I7), F15.8, I7)' , advance = \"no\" ) n , ka , kc , e * au2ev * 1000 , sym ! -- l write ( funit , '(I4)' , advance = \"no\" ) minval ( lvals ) if ( size ( lvals , 1 ) . gt . 2 ) then write ( funit , '(A2,I0)' , advance = \"no\" ) \"..\" , maxval ( lvals ) elseif ( size ( lvals , 1 ) . eq . 2 ) then write ( funit , '(A1,I0)' , advance = \"no\" ) \",\" , maxval ( lvals ) endif ! -- j write ( funit , '(I4)' , advance = \"no\" ) minval ( jvals ) if ( size ( jvals , 1 ) . gt . 2 ) then write ( funit , '(A2,I0)' , advance = \"no\" ) \"..\" , maxval ( jvals ) elseif ( size ( jvals , 1 ) . eq . 2 ) then write ( funit , '(A1,I0)' , advance = \"no\" ) \",\" , maxval ( jvals ) endif write ( funit , * ) enddo enddo close ( funit ) end subroutine write_channels_to_file ! ================================================================================================================================ ! end module rotex__writing","tags":"","url":"sourcefile/rotex__writing.f.html"},{"title":"rotex__mqdtxs.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__MQDTXS !! Routines to calculate cross sections with MQDT + S-matrix implicit none private public :: get_smat_probs ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine get_smat_probs ( & total_energy_grid & , prob & , transitions & , nmin & , nmax & , smat_j & , jmin & , jmax & , channels_j & , channels_tot & , spin_isomer_kind & , symaxis & ) !! Given a rotationally resolved S-matrix, calculate rotational (de-)excitation !! cross section probabilities for the supplied transitions. use rotex__types , only : dp , rvector_type , asymtop_rot_channel_l_vector_type , asymtop_rot_channel_l_type & , asymtop_rot_channel_type , cmatrix_type , n_states_type , asymtop_rot_transition_type & , operator (. ne .), operator (. eq .), operator (. isin .) & , trim_channel_l , get_channel_index use rotex__arrays , only : append , size_check , realloc use rotex__symmetry , only : is_spin_forbidden use rotex__system , only : die , stdout , stderr use rotex__constants , only : pi use rotex__characters , only : i2c => int2char #ifdef USE_FORBEAR use rotex__progress , only : progressbar_type #endif #ifdef USE_OPENMP use omp_lib , only : omp_get_thread_num #endif implicit none real ( dp ), intent ( in ) :: total_energy_grid (:) !! The total energy grid on which the S-matrix will be evaluated type ( rvector_type ), intent ( out ), allocatable :: prob (:) !! Probability at each pair of channels (n,N,Ka,Kc) ←→ (n',N',Ka',Kc') type ( asymtop_rot_transition_type ), intent ( inout ), allocatable :: transitions (:) !! Array of transitions that will be considered for (de-)excitation integer , intent ( in ) :: nmin , nmax !! Min/max values of N to consider for excitation calculations type ( cmatrix_type ), intent ( in ) :: smat_j ( jmin : jmax ) !! Array of S-matrix sub-blocks for each J integer , intent ( in ) :: jmin , jmax !! Min/max values of J to consider for the S-matrix subblocks type ( asymtop_rot_channel_l_vector_type ), intent ( in ) :: channels_j ( jmin : jmax ) !! Contains the array of channels for each J type ( asymtop_rot_channel_l_type ), intent ( in ) :: channels_tot (:) !! Contains the array of channels ∀ J integer , intent ( in ) :: spin_isomer_kind !! What kinda spin symmetry we need to respect character ( 1 ), intent ( in ) :: symaxis !! The symmetry axis of the target #ifdef USE_FORBEAR integer , parameter :: NDOTS2PRINT = 5 !! Progress bar update percentage integer :: iprogress , iprogress_last real ( dp ) :: rprogress , rprogress_inc type ( progressbar_type ) progressbar #endif logical , allocatable :: keep_transition_mask (:) integer :: ithread integer :: j , ni , nf integer :: neleclo , nlo , kalo , kclo integer :: nelecup , nup , kaup , kcup integer :: ichan , fchan , itrans integer :: ie , ne , nchans_j , nchans_tot , nopen , nclosed real ( dp ) :: etot , elo , eup real ( dp ) :: sum_ll real ( dp ) :: prob_term real ( dp ), allocatable :: beta (:) integer , allocatable :: indices_lo (:), indices_up (:) complex ( dp ), allocatable :: s (:,:) complex ( dp ), allocatable :: q (:) complex ( dp ), allocatable :: sphys (:,:) character ( 22 ) :: prefix_string type ( asymtop_rot_channel_type ) :: lo , up type ( asymtop_rot_transition_type ) :: transition type ( asymtop_rot_channel_l_type ), allocatable :: channels_this_j (:) nchans_tot = size ( channels_tot , 1 ) ! -- build combinations of states (without l), de-excitations will be handled by symmetry do ichan = 1 , nchans_tot Ni = channels_tot ( ichan ) % N if ( Ni . lt . Nmin ) cycle if ( Ni . gt . Nmax ) cycle lo = trim_channel_l ( channels_tot ( ichan )) do fchan = ichan + 1 , nchans_tot Nf = channels_tot ( fchan ) % N if ( Nf . lt . Nmin ) cycle if ( Nf . gt . Nmax ) cycle up = trim_channel_l ( channels_tot ( fchan )) ! -- skip elastic pairs if ( lo . eq . up ) cycle ! -- skip de-excitations for now. These shoud not show up here anyway; they'll be handled symmetrically !    when excitations are considered if ( lo % E . ge . up % E ) cycle !  -- respect ortho/para symmetry if applicable (returns true if theres nothing to respect) if ( is_spin_forbidden ( lo , up , spin_isomer_kind , symaxis )) cycle transition = asymtop_rot_transition_type ( lo = lo , up = up ) ! -- only append transitions uniquely if ( allocated ( transitions ) . eqv . . false .) then call append ( transitions , transition ) cycle endif if ( transition . isin . transitions ) cycle call append ( transitions , transition ) enddo enddo ! -- keep track of which transitions to keep based on the corresponding cross sections allocate ( keep_transition_mask ( size ( transitions , 1 )), source = . true .) call size_check ( channels_J , Jmax - Jmin + 1 , \"CHANNELS_J\" ) ne = size ( total_energy_grid , 1 ) ! -- allocate and initialize the probabilities arrays for each transition allocate ( prob ( size ( transitions , 1 ))) do itrans = 1 , size ( transitions , 1 ) allocate ( prob ( itrans ) % vec ( ne )) prob ( itrans ) % vec (:) = 0 enddo ! -- update user write ( * , * ) write ( stdout , '(A)' ) \"Performing closed-channel elimination on the S-matrix and accumulating cross section probabilities\" ! -- Σ_J write ( stdout , '(2X, 2(A5, \" /\"), A5)' ) \"Jmin\" , \"J\" , \"Jmax\" do J = Jmin , Jmax write ( prefix_string , '(2X, 2(I5,\" /\"),I5,X)' ) Jmin , J , Jmax #ifdef USE_FORBEAR call progressbar % initialize ( & filled_char_string = \"|\" & , empty_char_string = \" \" & , bracket_left_string = \"[\" & , prefix_string = prefix_string & , suffix_string = \"] \" & , add_progress_percent = . true . & ) call progressbar % start call progressbar % update ( current = 0.0_dp ) #else write ( stdout , '(A)' ) prefix_string #endif ! -- get the channels, S-matrix, and f/g normalization coefficients for this J channels_this_J = channels_J ( J ) % channels S = smat_J ( J ) % mtrx nchans_J = size ( channels_this_J , 1 ) call size_check ( S , [ nchans_J , nchans_J ], \"S\" ) #ifdef USE_FORBEAR rprogress = 0.0_dp iprogress_last = 0 rprogress_inc = 1.0_dp / real ( ne , kind = dp ) #endif ! -- loop over the total enrgy grid !$omp parallel default(none) & !$omp& shared(ne, channels_this_J, S, prob, transitions, J, nchans_J, total_energy_grid& #ifdef USE_FORBEAR !$omp&   , progressbar, rprogress, rprogress_inc, iprogress, iprogress_last)& #else !$omp&   )& #endif !$omp& private(ie, Etot, Sphys, beta, nopen, nclosed, lo, up, indices_lo, indices_up, itrans& !$omp&   , q,  neleclo, nelecup, Nlo, Nup, Kalo, Kaup, Kclo, Kcup, Elo, Eup, prob_term & !$omp&   , sum_ll, ithread) #ifdef USE_OPENMP ithread = omp_get_thread_num () #else ithread = 0 #endif !$omp do schedule(static) do ie = 1 , ne ! do concurrent (ie=1:ne) call realloc ( q , nchans_J ) Etot = total_energy_grid ( ie ) q = fg_norm_coeff_q ( channels_this_J , Etot ) nclosed = count ( channels_this_J % E . gt . Etot ) nopen = count ( channels_this_J % E . le . Etot ) if ( nopen + nclosed . ne . nchans_J ) call die ( \"Number of opened and closed channels does not add to the number of channels !\" ) call realloc ( beta , nclosed ) call realloc ( Sphys , nopen , nopen ) beta = 0 Sphys = 0 call CCEP ( S , channels_this_J , q , Etot , Sphys , beta , nopen , nclosed ) #ifdef USE_FORBEAR !$omp atomic rprogress = rprogress + rprogress_inc ! -- update progress update_progress : if ( ithread . eq . 0 ) then iprogress = floor ( rprogress * 100 ) if ( iprogress . eq . iprogress_last ) exit update_progress if ( iprogress . eq . 100 ) exit update_progress iprogress_last = iprogress call progressbar % update ( current = rprogress ) endif update_progress #endif ! -- loop over the pairs of states for excitation, accumulate probabilities in each transition !    for this J do itrans = 1 , size ( transitions , 1 ) lo = transitions ( itrans ) % lo up = transitions ( itrans ) % up ! -- make sure both channels in this transition are actually in this J block if (( lo . isin . channels_this_J ( 1 : nopen )) . eqv . . false .) cycle if (( up . isin . channels_this_J ( 1 : nopen )) . eqv . . false .) cycle neleclo = lo % nelec Nlo = lo % N Kalo = lo % Ka Kclo = lo % Kc nelecup = up % nelec Nup = up % N Kaup = up % Ka Kcup = up % Kc Elo = lo % E Eup = up % E if ( Elo . ge . Etot ) cycle if ( Eup . gt . Etot ) cycle ! -- get the indices of the S-matrix channels (with l) that match indices_lo = pack ([( ichan , ichan = 1 , nopen )], lo . eq . channels_this_J ( 1 : nopen )) ! .AND. channels_this_J % E .lt. Etot) indices_up = pack ([( ichan , ichan = 1 , nopen )], up . eq . channels_this_J ( 1 : nopen )) ! .AND. channels_this_J % E .lt. Etot) ! -- Σ_{ll'} |Sphys_{il,i'l'}|² prob_term = ( 2 * J + 1 ) * sum ( abs ( Sphys ( indices_lo , indices_up )) ** 2 ) prob ( itrans ) % vec ( ie ) = prob ( itrans ) % vec ( ie ) + prob_term if ( prob_term . ge . 0 ) cycle ! -- error write ( stderr , '(A)' ) \"❌\" write ( stderr , '(2X, A, 3E15.6)' ) \"Elo, Eup, Etot: \" , Elo , Eup , Etot write ( stderr , '(2X, A, 4I4)' ) \"Lower state nelec, N, Ka, Kc: \" , neleclo , Nlo , Kalo , Kclo write ( stderr , '(2X, A, 4I4)' ) \"Upper state nelec, N, Ka, Kc: \" , nelecup , Nup , Kaup , Kcup write ( stderr , '(2X, A20, E15.6)' ) \"(2J+1) Σ_{ll'} |S_{ll'}|²\" , sum_ll call die ( \"Negative probability from the S-matrix !\" ) enddo enddo !$omp end do !$omp end parallel #ifdef USE_FORBEAR call progressbar % update ( current = 1.0_dp ) #endif enddo ! ------------------------------------------------------------------------------------------------------------------------------ ! contains ! ------------------------------------------------------------------------------------------------------------------------------ ! ! ---------------------------------------------------------------------------------------------------------------------------- ! pure function fg_norm_coeff_q ( channels , Etot ) result ( res ) !! Given an array of channels, determine the factor B for each channel at a particular total energy E use rotex__system , only : die use rotex__constants , only : pi implicit none type ( asymtop_rot_channel_l_type ), intent ( in ) :: channels (:) !! Array of channels for which we want to get the factor B real ( dp ), intent ( in ) :: Etot !! The total energy complex ( dp ), allocatable :: res (:) integer :: i , l , n , iq real ( dp ) :: EE , Echan n = size ( channels , 1 ) allocate ( res ( n )) res = 1 do i = 1 , n iq = channels ( i ) % iq l = channels ( i ) % l if ( iq . eq . 4 ) cycle if ( iq . ne . 0 ) call die ( \"iq cannot be different from 4 and 0\" ) Echan = channels ( i ) % E EE = Etot - Echan res ( i ) = sqrt ( A_coulomb ( 2 * EE , l )) ! -- extra factor for closed channels only if ( EE . gt . 0 ) cycle res ( i ) = res ( i ) / sqrt ( 1._dp - exp ( - 2 * pi / sqrt ( 2 * EE ))) enddo end function fg_norm_coeff_q ! ---------------------------------------------------------------------------------------------------------------------------- ! pure elemental function A_coulomb ( e , l ) result ( res ) !! Calcualte the factor A for the Coulomb functions (Seaton, 2002, Comp. Phys. Comm.) implicit none real ( dp ), intent ( in ) :: e integer , intent ( in ) :: l real ( dp ) :: res integer :: n res = product ( [( 1 + n * n * e , n = 0 , l )] ) end function A_coulomb end subroutine get_smat_probs ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine CCEP ( S , channels , q , Etot , Sphys , beta , nopen , nclosed ) !! Given the S-matrix, its basis of channels, the total energy E, and the number of open/closed channels, !! carry out the MQDT Closed-Channel Elimination Procedure to obtain the nopen x nopen physical S matrix use rotex__types , only : dp , asymtop_rot_channel_l_type use rotex__system , only : die use rotex__linalg , only : zgesv , right_divide use rotex__arrays , only : size_check use rotex__constants , only : im , pi use rotex__characters , only : i2c => int2char implicit none complex ( dp ), intent ( in ) :: S (:,:) !! The n x n S-matrix before channel elimination type ( asymtop_rot_channel_l_type ), intent ( in ) :: channels (:) !! The rotational channels complex ( dp ), intent ( in ) :: q (:) !! The f/g normalization factors for each channel real ( dp ), intent ( in ) :: Etot !! The total energy complex ( dp ), intent ( inout ) :: Sphys (:,:) !! The nopen x nopen S-matrix after channel elimination real ( dp ), intent ( inout ) :: beta (:) !! The quantum defects for this channel at the given total energy integer , intent ( in ) :: nopen !! The number of open channels integer , intent ( in ) :: nclosed !! The number of closed channels integer :: ichan , iopen , iclosed , nchan real ( dp ) :: Echan complex ( dp ) :: numer , denom complex ( dp ), allocatable :: sinbeta (:), cosbeta (:) complex ( dp ), allocatable :: qmat (:,:), qmatinv (:,:) complex ( dp ), allocatable :: Soo (:,:), Soc (:,:), Sco (:,:), Scc (:,:) complex ( dp ), allocatable :: Sce (:,:) complex ( dp ), allocatable :: A (:,:), B (:,:) ! -- LAPACK specific integer :: info integer , allocatable :: ipiv (:) nchan = nopen + nclosed call size_check ( S , [ nchan , nchan ], \"S\" ) call size_check ( q , nchan , \"Q\" ) call size_check ( beta , nclosed , \"BETA\" ) call size_check ( Sphys , [ nopen , nopen ], \"SPHYS\" ) call size_check ( channels , nchan , \"CHANNELS\" ) ! -- build β do concurrent ( iclosed = 1 : nclosed ) ichan = iclosed + nopen Echan = channels ( ichan ) % E beta ( iclosed ) = pi / sqrt ( 2 * ( Echan - Etot )) enddo ! -- no CCEP if all channels are open if ( nclosed . eq . 0 ) then Sphys = S return endif Soo = S ( 1 : nopen , 1 : nopen ) ; Soc = S ( 1 : nopen , nopen + 1 : nchan ) Sco = S ( nopen + 1 : nchan , 1 : nopen ) ; Scc = S ( nopen + 1 : nchan , nopen + 1 : nchan ) call size_check ( Soo , [ nopen , nopen ], \"SOO\" ) call size_check ( Soc , [ nopen , nclosed ], \"SOC\" ) call size_check ( Sco , [ nclosed , nopen ], \"SCO\" ) call size_check ( Scc , [ nclosed , nclosed ], \"SCC\" ) sinbeta = sin ( beta ) cosbeta = cos ( beta ) do concurrent ( iclosed = 1 : nclosed ) ichan = iclosed + nopen numer = q ( ichan ) * q ( ichan ) * cosbeta ( iclosed ) - im * sinbeta ( iclosed ) denom = q ( ichan ) * q ( ichan ) * cosbeta ( iclosed ) + im * sinbeta ( iclosed ) Scc ( iclosed , iclosed ) = Scc ( iclosed , iclosed ) - numer / denom enddo allocate ( ipiv ( nclosed )) call zgesv ( nclosed , nopen , Scc , nclosed , ipiv , Sco , nclosed , info ) if ( info . ne . 0 ) call die ( \"ZGESV exited with INFO = \" // i2c ( info )) Sce = matmul ( Soc , Sco ) Sce = Soo - Sce deallocate ( Scc , Sco , Soc , Soo ) deallocate ( ipiv ) ! -- leave if there is not extra f/g function norm stuff to deal with if ( all ( q . eq . cmplx ( 1 , kind = dp ))) then Sphys = Sce return endif allocate ( qmat ( nopen , nopen )) allocate ( qmatinv ( nopen , nopen )) qmat = 0 qmatinv = 0 do concurrent ( iopen = 1 : nopen ) ichan = iopen qmat ( iopen , iopen ) = q ( ichan ) qmatinv ( iopen , iopen ) = 1 / q ( ichan ) enddo A = ( qmatinv - qmat ) + matmul ( qmatinv + qmat , Sce ) B = ( qmatinv + qmat ) + matmul ( qmatinv - qmat , Sce ) ! -- S = AB⁻¹ Sphys = right_divide ( A , B ) end subroutine CCEP ! ================================================================================================================================ ! end module rotex__MQDTXS ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__mqdtxs.f.html"},{"title":"rotex__constants.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__constants !! Contains most (but not all) defined constants used throughout the code. use iso_fortran_env , only : IOSTAT_END use rotex__kinds , only : dp implicit none private public :: IOSTAT_END integer , parameter , public :: IOSTAT_OK = 0 integer , parameter , public :: IQ_DEFAULT = 4 ! default Coulomb f,g normalization integer , parameter , public :: DEFAULT_INT = - 409 real ( dp ), parameter , public :: CB_MINT_IMAG_THRESH = 1e-8_dp !! Warn user if CB cross section M integrals have imaginary components !! larger than this value (they should be real). The code will try to skip such values. real ( dp ), parameter , public :: HYPGEO_ABC_THRESHOLD = 16 0._dp !! Threshold for warning the user about large values of a,b,c in !! ₂F₁(a,b;c;z) real ( dp ), parameter , public :: ahalf = 0.5_dp real ( dp ), parameter , public :: zero = 0._dp real ( dp ), parameter , public :: one = 1._dp real ( dp ), parameter , public :: two = 2._dp real ( dp ), parameter , public :: three = 3._dp real ( dp ), parameter , public :: four = 4._dp real ( dp ), parameter , public :: pi = atan ( 1._dp ) * 4._dp !! π real ( dp ), parameter , public :: invc = 1._dp / 13 7.035999177_dp !! 1/c, where c is the speed of light in atomic units. This is equal to the fine structure constant α. real ( dp ), parameter , public :: macheps_dp = epsilon ( one ) real ( dp ), parameter , public :: rho = 0.8_dp real ( dp ), parameter , public :: euler_mascheroni = 0.57721566490153286060651209008240243104215933593992_dp !! the Euler Mascheroni constant. The difference between the harmonic series and the natural logarithm real ( dp ), parameter , public :: au2ryd = 2._dp !! Hartree -> Rydberg real ( dp ), parameter , public :: au2ev = 2 7.2113834e0_dp !! Hartree -> eV real ( dp ), parameter , public :: au2ang = 0.5291772083_dp !! Bohr -> Ångstrom real ( dp ), parameter , public :: au2cm = au2ang * 1e-8_dp !! Bohr -> cm real ( dp ), parameter , public :: au2invcm = 21947 4.6313710e0_dp !! multiplication factor to convert atomic units of energy (hartree) to wavenumbers (inverse centimeters) real ( dp ), parameter , public :: au2sec = 2.4188843e-17_dp !! multiplication factor to convert atomic units of time (hbar / hartree) to seconds real ( dp ), parameter , public :: au2deb = 2.5417462762781615_dp !! atomic units (electric dipole) -> Debye complex ( dp ), parameter , public :: im = ( zero , one ) !! the square root of -1 character ( 1 ), parameter , public :: CHAR_CR = achar ( 13 ) character ( 1 ), parameter , public :: DEFAULT_CHAR1 = \"x\" character ( 7 ), parameter , public :: UKRMOLX = 'ukrmol+' character ( 7 ), parameter , public :: MQDTR2K = 'mqdtr2k' character ( 7 ), parameter , public :: spinmult_names ( 5 ) = & [ 'singlet' , 'doublet' , 'triplet' , 'quartet' , 'quintet' ] ! ================================================================================================================================ ! end module rotex__constants ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__constants.f.html"},{"title":"rotex__linalg.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__linalg !! Linear algebra interfaces to LAPACK routines and other linear algebra stuff use rotex__kinds , only : dp ! #ifdef WITH_STDLIB ! use stdlib_linalg_lapack, only: zgesv  => stdlib_zgesv,  dsyev  => stdlib_dsyev  & !                               , zgetrs => stdlib_zgetrs, zgetrf => stdlib_zgetrf ! #endif implicit none private public :: dsyev public :: zgesv public :: operator (. matmul .) public :: right_divide #ifndef WITH_STDLIB interface subroutine zgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) import dp implicit none integer , intent ( in ) :: lda , ldb , n , nrhs integer , intent ( out ) :: info , ipiv ( * ) complex ( dp ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) end subroutine zgesv end interface interface subroutine dsyev ( jobz , uplo , n , a , lda , w , work , lwork , info ) import dp implicit none character ( 1 ), intent ( in ) :: jobz , uplo real ( dp ), intent ( inout ) :: a ( lda , n ) integer , intent ( in ) :: lda , lwork , n integer , intent ( out ) :: info real ( dp ), intent ( out ) :: w ( * ), work ( * ) end subroutine dsyev end interface interface subroutine zgetrf ( m , n , a , lda , ipiv , info ) import dp implicit none integer , intent ( in ) :: m , n , lda integer , intent ( out ) :: ipiv ( * ), info complex ( dp ), intent ( inout ) :: a ( lda , * ) end subroutine zgetrf end interface interface zgetrs subroutine zgetrs ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) import dp implicit none character ( 1 ), intent ( in ) :: trans integer , intent ( out ) :: info integer , intent ( in ) :: lda , ldb , n , nrhs , ipiv ( * ) complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( inout ) :: b ( ldb , * ) end subroutine zgetrs end interface zgetrs #endif ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! function right_divide ( A , B ) result ( X ) !! Returns X = AB⁻¹ without evaluating B⁻¹ use rotex__system , only : die use rotex__characters , only : i2c => int2char implicit none complex ( dp ), intent ( in ) :: A (:,:), B (:,:) complex ( dp ) :: X ( size ( A , 1 ), size ( A , 2 )) complex ( dp ), allocatable :: BT (:,:), AT (:,:) integer , allocatable :: ipiv (:) integer :: n , m , info n = size ( B , 1 ) m = size ( A , 1 ) if ( size ( B , 2 ) . ne . n ) call die ( \"Trying to invert a nonsquare matrix B !\" ) if ( size ( A , 2 ) . ne . n ) call die ( \"Can't form AB⁻¹ because the dimensions of A are wrong !\" ) AT = transpose ( A ) BT = transpose ( B ) allocate ( ipiv ( n )) call zgetrf ( n , n , BT , n , ipiv , info ) if ( info . ne . 0 ) call die ( \"ZGETRF exited with INFO = \" // i2c ( info )) ! -- solve X = AB⁻¹ is BT XT = AT, which is solved by ZGETRS (AX=B) call zgetrs ( 'T' , n , m , BT , n , ipiv , AT , n , info ) if ( info . ne . 0 ) call die ( \"ZGETRS exited with INFO = \" // i2c ( info )) X = transpose ( AT ) end function right_divide ! ================================================================================================================================ ! end module rotex__linalg ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__linalg.f.html"},{"title":"rotex__rft.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__RFT !! Procedures used to carry out the rotational frame transformation implicit none private ! public :: RFT_linear public :: RFT_nonlinear interface real2complex_ylm ! module procedure :: real2complex_ylm_r module procedure :: real2complex_ylm_c end interface real2complex_ylm ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine RFT_nonlinear ( Kmat & , Jmin , Jmax & , Smat_J & , elec_channels & , N_states & , asymtop_rot_channels_l & , asymtop_rot_channels_l_J & , spin_isomer_kind & , symaxis & , real_spherical_harmonics & , point_group & ) !! Build the electronic S-matrix from the electronic K-matrix, then perform the rotational frame transformation on the S-matrix use rotex__types , only : dp , elec_channel_type , asymtop_rot_channel_l_type , N_states_type , cmatrix_type & , sort_channels_by_energy , asymtop_rot_channel_l_vector_type use rotex__system , only : stdout , die use rotex__symmetry , only : possible_spin_symmetries , spin_symmetry use rotex__constants , only : im use rotex__arrays , only : append , is_unitary implicit none real ( dp ), intent ( inout ), allocatable :: Kmat (:,:) !! The K-matrix, needed as input for the RFT integer , intent ( in ) :: Jmin !!  The lowest value of J = N + l integer , intent ( in ) :: Jmax !!  The largest value of J = N + l type ( cmatrix_type ), intent ( out ) :: Smat_J ( Jmin : Jmax ) !! The rotational S-matrices S&#94;J, produced by the RFT type ( elec_channel_type ), intent ( in ) :: elec_channels (:) !! The array of electronic channels (n, l, ml), needed as input for the RFT type ( N_states_type ), intent ( in ) :: N_states (:) !! The array of rotational states of the target (N, Ka, Kc), needed as input for the RFT type ( asymtop_rot_channel_l_type ), intent ( out ), allocatable :: asymtop_rot_channels_l (:) !! The array of rotational channels (N, Ka, Kc, l) that make up the basis of the S-matrix type ( asymtop_rot_channel_l_vector_type ), intent ( out ) :: asymtop_rot_channels_l_J ( Jmin : Jmax ) !! The array of arrays of rotational channels (N, Ka, Kc, l) that make up the basis of the S-matrix subblocks at each J integer , intent ( in ) :: spin_isomer_kind !! Spin isomer kind character ( 1 ), intent ( in ) :: symaxis !! Symmetry axis for respecting nuclear spin symmetry logical , intent ( in ) :: real_spherical_harmonics !! Whether the input K-matrices are evaluated in a basis of real spherical harmonics !! for the scattering electron. If .true., transform the S-matrix into a basis of !! complex-valued spherical harmonics character ( * ), intent ( in ) :: point_group !! The point group of the calculation integer :: nelec , l integer :: ml integer :: ichan , nchans_rot , nchans_elec complex ( dp ), allocatable :: Smat_elec (:,:) nchans_elec = size ( elec_channels , 1 ) call build_rotational_channels ( n_states & , spin_isomer_kind & , symaxis & , elec_channels & , asymtop_rot_channels_l ) ! -- channels are sorted by contsruction, but we should still sort them by energy here in case !    anything above changes in the future call sort_channels_by_energy ( asymtop_rot_channels_l ) nchans_rot = size ( asymtop_rot_channels_l , 1 ) if ( nchans_rot . lt . 1 ) call die ( \"Number of rotational channels must not be less than 1 !\" ) allocate ( smat_elec ( nchans_elec , nchans_elec )) smat_elec = 0 call K2S ( Kmat , smat_elec , elec_channels , real_spherical_harmonics , point_group ) write ( stdout , '(A)' ) \"Channel-by-channel unitarity of the electronic S-matrix:\" write ( stdout , '(8X, 4A4, A15)' ) \"i\" , \"n\" , \"l\" , \"ml\" , \"||S(:,i)||₂\" do ichan = 1 , nchans_elec nelec = elec_channels ( ichan ) % nelec l = elec_channels ( ichan ) % l ml = elec_channels ( ichan ) % ml write ( stdout , '(8X, 4I4, 2X, F8.4)' ) ichan , nelec , l , ml , sum ( abs ( Smat_elec ( ichan ,:)) ** 2 ) enddo write ( stdout , * ) if ( is_unitary ( Smat_elec ) . eqv . . false .) call die ( \"Electronic S-matrix is not unitary !\" ) ! -- Smat_elec -> Smat (RFT) ! (n) l λ -> N τ(Ka,Kc) l write ( stdout , '(A)' ) \"Frame transformation: S_elec -> S&#94;J\" call do_rft ( & smat_elec & , smat_j & , jmin & , jmax & , n_states & , elec_channels & , asymtop_rot_channels_l & , asymtop_rot_channels_l_j & , point_group & ) end subroutine RFT_nonlinear ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine build_rotational_channels ( n_states , spin_isomer_kind , symaxis , elec_channels , rot_channels ) !! Build rotational+electronic channels channels: (N Ka Kc)+(l λ) = (N Ka Kc l λ) use rotex__kinds , only : dp use rotex__types , only : n_states_type , elec_channel_type , asymtop_rot_channel_l_type use rotex__arrays , only : append use rotex__symmetry , only : spin_symmetry implicit none type ( N_states_type ), intent ( in ) :: n_states (:) integer , intent ( in ) :: spin_isomer_kind character ( 1 ), intent ( in ) :: symaxis type ( elec_channel_type ), intent ( in ) :: elec_channels (:) type ( asymtop_rot_channel_l_type ), intent ( out ), allocatable :: rot_channels (:) integer :: i_N_state , i_tau , i_elec_channel integer :: n , ka , kc , nelec , iq , sym integer :: l , lprev real ( dp ) :: e , e_elec , e_rot type ( asymtop_rot_channel_l_type ) :: channel ! -- build rotational channels from elec_channels and N_states do i_n_state = 1 , size ( n_states , 1 ) n = n_states ( i_n_state ) % n do i_tau = 1 , 2 * n + 1 ka = n_states ( i_n_state ) % ka ( i_tau ) kc = n_states ( i_n_state ) % kc ( i_tau ) lprev = elec_channels ( 1 ) % l do i_elec_channel = 1 , size ( elec_channels , 1 ) nelec = elec_channels ( i_elec_channel ) % nelec l = elec_channels ( i_elec_channel ) % l iq = elec_channels ( i_elec_channel ) % iq ! -- get the channel energy (rotational + electronic) e_elec = elec_channels ( i_elec_channel ) % e e_rot = n_states ( i_n_state ) % eigenh % eigvals ( i_tau ) e = e_rot + e_elec ! -- for now, enforce ground state RE only if ( nelec . ne . 1 ) cycle ! -- don't worry about the different projections of ml for the final channels if ( l . eq . lprev . and . l . ne . 0 ) cycle lprev = l sym = spin_symmetry ( n , ka , kc , spin_isomer_kind , symaxis ) channel = asymtop_rot_channel_l_type ( nelec = nelec , l = l , iq = iq , n = n , ka = ka , kc = kc , e = e , sym = sym ) call append ( rot_channels , channel ) enddo enddo enddo end subroutine build_rotational_channels ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine K2S ( Kmat , Smat , elec_channels , real_spherical_harmonics , point_group ) !! electronic Kmat -> electronic Smat use rotex__kinds , only : dp use rotex__types , only : elec_channel_type use rotex__arrays , only : adjoint , eye use rotex__constants , only : im use rotex__system , only : die use rotex__characters , only : i2c => int2char use rotex__linalg , only : dsyev , zgesv implicit none real ( dp ), intent ( in ) :: Kmat (:,:) complex ( dp ), intent ( out ) :: Smat (:,:) type ( elec_channel_type ), intent ( in ) :: elec_channels (:) logical , intent ( in ) :: real_spherical_harmonics character ( * ), intent ( in ) :: point_group character ( 1 ), parameter :: jobz = \"V\" character ( 1 ), parameter :: uplo = \"U\" integer :: ichan integer :: nchans_elec integer :: nn integer :: lda integer :: ldwork integer :: info real ( dp ), allocatable :: w (:) real ( dp ), allocatable :: work (:) real ( dp ), allocatable :: U (:,:) nchans_elec = size ( elec_channels , 1 ) smat = 0 ! -- ensure the K-matrix is represented in a basis of complex spherical harmonic U = Kmat (:,:) ! if(real_spherical_harmonics .eqv. .true.) call real2complex_ylm(U, elec_channels) nn = size ( U , 1 ) lda = nn ldwork = 3 * nn - 1 allocate ( w ( nn )) allocate ( work ( ldwork )) ! -- diagonalize K = U tan(δ) UT call dsyev ( jobz , uplo , nn , U , lda , w , work , ldwork , info ) if ( info . ne . 0 ) call die ( \"Error in diagonalizaion of the electronic K-matrix ! INFO return as \" // i2c ( info )) ! -- build diagonal e&#94;{2iδ} do concurrent ( ichan = 1 : nn ) smat ( ichan , ichan ) = exp ( 2 * im * atan ( w ( ichan ))) enddo ! -- S = U e&#94;{2iδ} UT smat = matmul ( U , matmul ( smat , adjoint ( U )) ) if ( real_spherical_harmonics . eqv . . false .) return ! -- transform real-valued Ylm basis to complex-valued Ylm call real2complex_ylm ( smat , elec_channels , point_group ) end subroutine K2S ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine do_rft ( Smat_elec , Smat_j , jmin , jmax , n_states & , elec_channels , asymtop_rot_channels_l , asymtop_rot_channels_l_j , point_group ) !! Perform the rotational frame transformation on the electronic S-matrix use rotex__kinds , only : dp use rotex__types , only : cmatrix_type , asymtop_rot_channel_l_type , asymtop_rot_channel_l_vector_type & , elec_channel_type , N_states_type use rotex__wigner , only : clebsch use rotex__system , only : stdout , die use rotex__arrays , only : realloc , is_unitary , uniq use rotex__functions , only : neg use rotex__characters , only : i2c => int2char implicit none complex ( dp ), intent ( in ) :: Smat_elec (:,:) type ( cmatrix_type ), intent ( out ) :: Smat_j ( jmin : jmax ) !! Rotationally resolved S-matrix at each J integer , intent ( in ) :: jmin , jmax !! Min/max values of the total angular momentum J type ( n_states_type ), intent ( in ) :: n_states (:) type ( elec_channel_type ), intent ( in ) :: elec_channels (:) type ( asymtop_rot_channel_l_type ), intent ( in ) :: asymtop_rot_channels_l (:) type ( asymtop_rot_channel_l_vector_type ), intent ( out ) :: asymtop_rot_channels_l_j ( jmin : jmax ) character ( * ), intent ( in ) :: point_group logical :: flag integer :: nsyms , nchans_elec integer :: J integer :: nchans_J integer , allocatable :: idx (:), uniq_syms (:) complex ( dp ), allocatable :: Smat_rot (:,:) real ( dp ), allocatable :: U (:,:) flag = . false . nchans_elec = size ( smat_elec , 1 ) ! -- loop over different values of the agular momentum J jloop : do J = Jmin , Jmax ! -- determine number of rotational channels in this block of total J call collect_J_channels_indices ( j , asymtop_rot_channels_l , idx ) asymtop_rot_channels_l_j ( j ) % channels = asymtop_rot_channels_l ( idx ) nchans_J = size ( asymtop_rot_channels_l_j ( j ) % channels , 1 ) ! -- the total S-matrix for this J call realloc ( U , nchans_J , nchans_elec ) call realloc ( smat_rot , nchans_J , nchans_J ) U = 0 smat_rot = 0 ! -- get the unique symmetry elements. We do one frame transformation per !    symmetry element uniq_syms = asymtop_rot_channels_l_j ( j ) % channels % sym uniq_syms = uniq ( uniq_syms ) nsyms = size ( uniq_syms , 1 ) call do_rft_no_sym ( J , n_states , elec_channels , asymtop_rot_channels_l_j ( j )% channels , smat_elec , smat_rot , U , point_group ) ! ! -- loop over symmetries ! do isym=1, nsyms !   sym = uniq_syms(isym) !   ! -- map all J -> this sym !   mask = asymtop_rot_channels_l_j(j)%channels%sym .eq. sym !   idx = pack([(i,i=1,nchans_j)], mask) !   rot_channels = asymtop_rot_channels_l_j(j) % channels(idx) !   ! -- allocate U, Smat_rot for this sym !   nchans_sym = size(idx, 1) !   call realloc(U,            nchans_sym, nchans_elec) !   call realloc(smat_rot_sym, nchans_sym, nchans_sym) !   U = 0 !   smat_rot_sym = 0 !   call do_rft_this_sym(j, sym, n_states, elec_channels, rot_channels, smat_elec, smat_rot_sym, U) !   ! -- add this contribution back to the total S-matrix for this J !   smat_rot(idx, idx) = smat_rot_sym(:,:) ! enddo ! -- export this S&#94;J smat_j ( j ) % mtrx = smat_rot (:,:) if ( is_unitary ( Smat_rot ) . eqv . . true .) cycle flag = . true . ! -- warn about nonunitarity block use rotex__system , only : stderr use rotex__arrays , only : eye , adjoint , norm_frob , unitary_defect associate ( S => Smat_J ( J )% mtrx ) write ( stderr , '(A, I0, A, F7.5)' ) & \"WARN: The S-matrix for J = \" , J , \" is nonunitary with unitary defect \" , unitary_defect ( S ) end associate end block enddo jloop if ( flag . eqv . . false .) return call die ( \"At least one J-block of the S-matrix is non-unitary. This may cause some issues in the& & ensuing MQDT closed-channel elimination procedure which takes the closed channels into account for each J-block.& & Therefore, each J-block should be unitary, even if they involve states with N< N_min or N > N_max. It is probably& & worth noting that the S-matrix at this point was detected to be non-unitary, but each symmetry sub-block was unitary.\" ) end subroutine do_rft ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! pure subroutine real2complex_ylm_r(M, chans) !   !! Real-valued version of the complex-valued equivalent !   use rotex__types,  only: dp, elec_channel_type !   use rotex__system, only: die !   implicit none !   real(dp), intent(inout) :: M(:,:) !     !! The S/K-matrix !   type(elec_channel_type), intent(in) :: chans(:) !   complex(dp), allocatable :: MC(:,:) !   MC = cmplx(M, 0.0_dp, kind = dp) !   call real2complex_ylm_c(MC, chans) !   if(maxval(abs(MC%im)) .gt. 1e-12) call die(\"Nonzero imaginary values detected in& !     & transformed S/K matrix (complex spherical harmonics basis)\") !   M = MC % re ! end subroutine real2complex_ylm_r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine real2complex_ylm_c ( M , chans , point_group ) !! Take an S/K-matrix that is in a basis of electronic channels for exactly !! one electronic state and a basis of real-valued spherical harmonics, and !! transform it to an S/K-matrix in a basis of the same electronic state but !! complex-valued spherical harmonics for the scattering electron use rotex__types , only : dp , elec_channel_type use rotex__arrays , only : adjoint , size_check , is_unitary use rotex__system , only : die implicit none complex ( dp ), intent ( inout ) :: M (:,:) !! The S/K-matrix type ( elec_channel_type ), intent ( in ) :: chans (:) !! The electronic channels character ( * ), intent ( in ) :: point_group !! Point group of the scattering calculations integer :: n , i , j integer :: eleci , li , lambi , elecj , lj , lambj complex ( dp ), allocatable :: U (:,:) n = size ( chans , 1 ) call size_check ( M , [ n , n ], \"S (or K)\" ) allocate ( U ( n , n )) ; U = 0 ! -- Build the ℛ  → ℭ spherical harmonics transformatices !    (incident electron partial waves) do j = 1 , n elecj = chans ( j ) % nelec lj = chans ( j ) % l lambj = chans ( j ) % ml do i = 1 , n eleci = chans ( i ) % nelec li = chans ( i ) % l lambi = chans ( i ) % ml if ( elecj . ne . eleci ) call die ( \"There are >1 electronic states detected in the S/K-matrix\" ) if ( li . ne . lj ) cycle ! -- transform incident electron partial waves select case ( point_group ) case ( \"c2v\" , \"c2\" , \"d2\" , \"d2h\" ) U ( i , j ) = cmplx_ylm_coeff ( lambi , lambj ) case ( \"cs\" ) U ( i , j ) = cmplx_ylm_coeff_cs ( lambi , lambj ) case default call die ( \"Unsupported point group in REAL2COMPLEX_YLM transformation: \" // point_group ) end select enddo enddo ! -- unitary checks if ( is_unitary ( U ) . eqv . . false .) call die ( \"The transformation matrix for the spherical harmonics is not unitary\" ) ! -- set M for return M = matmul ( adjoint ( U ), matmul ( M , U )) deallocate ( U ) end subroutine real2complex_ylm_c ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function cmplx_ylm_coeff ( mr , mc ) result ( res ) !! Determine the coefficient for the real complex spherical harmonic for expressing the !! complex spherical harmonics in terms of the real spherical harmonics, e.g., !!   Y_l&#94;{m_c} = c_1 Y_{l,|m_r|} + c_2Y_{l,-|m_r|}, !! given mc and one of |mr| or -|mr|. Assumes that the degree (l) of the spherical harmonics !! is the same use rotex__kinds , only : dp implicit none integer , intent ( in ) :: mr !! The order (m) for the complex spherical harmonic integer , intent ( in ) :: mc !! The ordedr (±|m|) for the real spherical harmonic complex ( dp ), parameter :: one = cmplx ( 1 , 0 , kind = dp ) real ( dp ), parameter :: invsq2 = 1.0_dp / sqrt ( real ( 2 , kind = dp )) complex ( dp ), parameter :: im = cmplx ( 0 , 1 , kind = dp ) complex ( dp ) :: coef1 , coef2 complex ( dp ) :: res res = 0 if ( abs ( mc ) . ne . abs ( mr )) return select case ( mc ) case (: - 1 ) coef1 = 1 ! coef = mr .lt. 0 ? one : -i coef2 = merge ( - im , one , mr . lt . 0 ) case ( 1 :) coef1 = merge ( one , - one , mod ( mr , 2 ) . ne . 0 ) coef2 = merge ( im , one , mr . lt . 0 ) case ( 0 ) res = 1 return end select res = coef1 * coef2 * invsq2 end function cmplx_ylm_coeff ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function cmplx_ylm_coeff_cs ( mr , mc ) result ( res ) !! Determine the coefficient for the real complex spherical harmonic for expressing the !! complex spherical harmonics in terms of the real spherical harmonics, similar to !!   Y_l&#94;{m_c} = c_1 Y_{l,|m_r|} + c_2Y_{l,-|m_r|}, !! except that in Cs symmetry, we work with linear combinations that are even or odd under !! mirror plane reflection, so it's actually something like !!   Y_l&#94;{m_c} = c_1 Y_{lm}&#94;\\text{even} + c_2 Y_{lm}&#94;\\text{odd} !! UKRmol+ uses the convention of having the YZ plane be the mirror plane; this affects !! which values of m belong to the irreps A' (even) and A'' (odd). For the YZ plane, !! $x \\to -x$ corresponds to $\\phi \\to \\pi-\\phi$, under which cos is odd (A'') and sin is even (A'). !! However, instead of assuming that cos is odd, this routine will just query some symmetry arrays !! use rotex__kinds , only : dp use rotex__system , only : die use rotex__symmetry , only : m_parity , even implicit none integer , intent ( in ) :: mr !! The order (m) for the complex spherical harmonic integer , intent ( in ) :: mc !! The ordedr (±|m|) for the real spherical harmonic complex ( dp ), parameter :: one = cmplx ( 1 , 0 , kind = dp ) real ( dp ), parameter :: invsq2 = 1.0_dp / sqrt ( real ( 2 , kind = dp )) complex ( dp ), parameter :: im = cmplx ( 0 , 1 , kind = dp ) complex ( dp ) :: coef1 , coef2 complex ( dp ) :: res if ( allocated ( m_parity ) . eqv . . false .) call die ( \"M_PARITY array is not allocated, but is needed\" ) res = 0 if ( abs ( mc ) . ne . abs ( mr )) return select case ( mc ) case (: - 1 ) ! negative m, complex coef1 = 1 coef2 = merge ( - im , one , m_parity ( mr ) . eq . even ) case ( 1 :) !  positive m, complex coef1 = merge ( one , - one , mod ( mr , 2 ) . ne . 0 ) ! (-1)&#94;m coef2 = merge ( im , one , m_parity ( mr ) . eq . even ) case ( 0 ) !  m = 0, complex res = 1 return end select res = coef1 * coef2 * invsq2 end function cmplx_ylm_coeff_cs ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine get_channel_qnums_rot ( channels , irot , nelec , N , Ka , Kc , l , sym ) !! Given an array of channels with quantum numbers, extract the quantum numbers at index irot use rotex__types , only : asymtop_rot_channel_l_type use rotex__system , only : die implicit none type ( asymtop_rot_channel_l_type ), intent ( in ) :: channels (:) integer , intent ( in ) :: irot integer , intent ( out ) :: nelec , N , Ka , Kc , l integer , optional , intent ( out ) :: sym if ( irot . gt . ubound ( channels , 1 )) call die ( \"Targeted channel > channel upper bound\" ) if ( irot . lt . lbound ( channels , 1 )) call die ( \"Targeted channel < channel lower bound\" ) nelec = channels ( irot ) % nelec N = channels ( irot ) % N Ka = channels ( irot ) % Ka Kc = channels ( irot ) % Kc l = channels ( irot ) % l if ( present ( sym ) . eqv . . false .) return sym = channels ( irot ) % sym end subroutine get_channel_qnums_rot ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine collect_j_channels_indices ( j , channels_l , idx ) !! Go through channels_l and add the channels to channels_l_j that !! obey the degenerate triangle inequality for N, l, J use rotex__types , only : asymtop_rot_channel_l_type use rotex__functions , only : istriangle implicit none integer , intent ( in ) :: j !! Total angular momentum J type ( asymtop_rot_channel_l_type ), intent ( in ) :: channels_l (:) !! All rotatinal channels integer , intent ( out ), allocatable :: idx (:) !! Rotational channels for this J will be channels_l(idx) integer :: nchans_rot integer :: n , l integer :: ichan integer :: count nchans_rot = size ( channels_l , 1 ) count = 0 ! -- count number of channels do ichan = 1 , nchans_rot n = channels_l ( ichan ) % n l = channels_l ( ichan ) % l if ( istriangle ( n , l , j ) . eqv . . false .) cycle count = count + 1 enddo allocate ( idx ( count )) if ( count . eq . 0 ) return ! -- fill idx if count > 0 count = 0 do ichan = 1 , nchans_rot n = channels_l ( ichan ) % n l = channels_l ( ichan ) % l if ( istriangle ( n , l , j ) . eqv . . false .) cycle count = count + 1 idx ( count ) = ichan enddo end subroutine collect_j_channels_indices ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine do_rft_no_sym ( j , n_states , elec_channels , rot_channels , Smat_elec , Smat_rot , U , point_group ) !! Do the rotational frame transformation for a specific symmetry use rotex__kinds , only : dp use rotex__types , only : elec_channel_type , asymtop_rot_channel_l_type , n_states_type use rotex__arrays , only : size_check , is_unitary , is_symmetric , adjoint use rotex__wigner , only : clebsch use rotex__system , only : die , stderr , stdout use rotex__functions , only : neg use rotex__characters , only : i2c => int2char implicit none integer , intent ( in ) :: j !! Total angular momentum quantum number J type ( n_states_type ), intent ( in ) :: n_states (:) !! N, Ka, and Kc for each N type ( elec_channel_type ), intent ( in ) :: elec_channels (:) !! Electronic channel basis for Smat_elec type ( asymtop_rot_channel_l_type ), intent ( in ) :: rot_channels (:) !! Rotational channel basis for Smat_rot (this symmetry) complex ( dp ), intent ( in ) :: smat_elec (:,:) !! Electronic S-matrix complex ( dp ), intent ( out ) :: smat_rot (:,:) !! Rotatinal S-matrix real ( dp ), intent ( out ) :: U (:,:) !! Unitary transformation matrix character ( 1 ), intent ( in ) :: point_group !! The point group of the scattering calculations integer :: irot integer :: nchans_elec , nchans_rot integer :: ni , kai , kci , li , lj , ki , lambdaj , symchan integer :: neleci , nelecj integer :: in , itau , iK , jelec integer :: Omega logical , allocatable :: mask (:) real ( dp ), allocatable :: C (:, :) nchans_rot = size ( rot_channels , 1 ) nchans_elec = size ( elec_channels , 1 ) Smat_rot = 0 ! -- build the rectangular transformation matrix U <LF|BF> for each Ω allocate ( C ( nchans_rot , nchans_rot )) C = 0 do Omega = - J , J U = 0 do irot = 1 , nchans_rot call get_channel_qnums_rot ( rot_channels , irot , neleci , ni , kai , kci , li , symchan ) in = findloc ( n_states % n , value = ni , dim = 1 ) mask = ( n_states ( in ) % ka (:) . eq . kai ) . AND . ( n_states ( in ) % kc (:) . eq . kci ) itau = findloc ( mask , value = . true ., dim = 1 ) do jelec = 1 , nchans_elec nelecj = elec_channels ( jelec ) % nelec lj = elec_channels ( jelec ) % l lambdaj = elec_channels ( jelec ) % ml ! -- enforce transformation between the same electronic state n and partial wave l if ( neleci . ne . nelecj ) cycle if ( li . ne . lj ) cycle Ki = Omega - lambdaj if ( abs ( Ki ) . gt . Ni ) cycle ik = Ki + Ni + 1 U ( irot , jelec ) = neg ( lj + lambdaj ) & * N_states ( in ) % eigenH % eigvecs ( ik , itau )& * clebsch ( lj , - lambdaj , J , Omega , Ni , Ki ) enddo enddo ! -- S&#94;J = Σ_Ω USU⁺ (for each Ω) Smat_rot = Smat_rot + matmul ( U , matmul ( Smat_elec , adjoint ( U )) ) ! -- diagnostics if we fail to produce a unitary S C = C + matmul ( U , adjoint ( U )) enddo if ( is_symmetric ( Smat_rot ) . eqv . . false .) & call die ( \"The S-matrix is not symmetric for J = \" // i2c ( j ) // \" ❌\" ) if ( is_unitary ( Smat_rot ) . eqv . . true .) then write ( stdout , '(\"S-matrix is unitary for J = \", I0, \" ✔️\")' ) J return endif err : block use rotex__arrays , only : unitary_defect write ( stderr , '(\"Channels: \", 6(A5,X), A20)' ) \"i\" , \"nelec\" , \"N\" , \"Ka\" , \"Kc\" , \"l\" , \"Σ|S(i,:)|²\" do irot = 1 , nchans_rot call get_channel_qnums_rot ( rot_channels , irot , neleci , ni , kai , kci , li ) write ( stderr , '(10X, 6(I5,X), E20.10)' , advance = \"no\" ) irot , neleci , ni , kai , kci , li & , sum ( abs ( Smat_rot ( irot ,:)) ** 2 ) if ( all ( U ( irot ,:) . eq . 0._dp )) write ( stderr , '(\" <-- \", A)' , advance = \"no\" ) \"Does not couple to any electronic channels !\" write ( stderr , * ) enddo write ( stderr , * ) write ( stderr , '(\"Rank of UU+: \", I0)' ) rank ( C ) write ( stderr , '(\"Unitary defect in UU+:  \", F15.9)' ) unitary_defect ( C ) ! call printmat(Smat_elec, stderr, \"The electronic S-matrix\") ! call printmat(Smat_rot,  stderr, \"The post-RFT S-matrix\") write ( stderr , '(\"Unitary defect in USU+: \", F15.9)' ) unitary_defect ( Smat_rot ) call die ( \"The S-matrix is not unitary for J = \" // i2c ( J ) // \" ❌\" ) end block err end subroutine do_rft_no_sym ! ================================================================================================================================ ! end module rotex__RFT ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__rft.f.html"},{"title":"rotex__functions.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__functions !! Contains various small functions used in the code use rotex__kinds , only : dp private public :: delta public :: factorial public :: log_factorial public :: are_approx_eq public :: expm1 public :: logp1 public :: isnatural public :: isinteger public :: arg public :: inv public :: iseven public :: isodd public :: istriangle public :: logrange public :: logb public :: neg interface are_approx_eq !! Compare two a and b and see if the magnitude of their difference is smaller than a tolerance, !! taking machine epsilon*max(|a|,|b|) for their precision as the default value module procedure :: are_approx_eqz module procedure :: are_approx_eqr end interface are_approx_eq interface factorial !! !n module procedure :: factorial_int module procedure :: factorial_real end interface factorial interface log_factorial !! ln(!n) module procedure :: log_factorial_i module procedure :: log_factorial_r end interface log_factorial interface expm1 module procedure :: expm1r module procedure :: expm1z end interface expm1 interface logp1 module procedure :: logp1r module procedure :: logp1z end interface logp1 interface logb module procedure :: logb_ii module procedure :: logb_rr module procedure :: logb_cc end interface logb interface logrange module procedure :: logrange_ib module procedure :: logrange_rb end interface logrange interface !! Interface to the C functions expm1 for real x function c_expm1 ( x ) bind ( C , name = \"expm1\" ) result ( res ) use , intrinsic :: iso_c_binding , only : c_double implicit none real ( c_double ), value :: x real ( c_double ) :: res end function c_expm1 end interface interface !! Interface to the C functions logp1 for real x function c_logp1 ( x ) bind ( C , name = \"logp1\" ) result ( res ) use , intrinsic :: iso_c_binding , only : c_double implicit none real ( c_double ), value :: x real ( c_double ) :: res end function c_logp1 end interface interface isinteger !! Check if a real/complex number is an integer module procedure :: isintegerr module procedure :: isintegerz end interface isinteger interface isnatural !! Check if a real/complex number is a natrual number module procedure :: isnaturalr module procedure :: isnaturalz end interface isnatural interface arg !! Return the phase of a complex number in (-π,π] module procedure argi module procedure argr module procedure argc end interface arg interface inv !! Compute 1/z module procedure invi module procedure invr module procedure invz end interface inv ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elementaL module function are_approx_eqz ( a , b , tol ) result ( res ) !! Comparre two a and b and see if magnitude of their difference is smaller than a tolerance, !! taking machine epsilon for their precision as the default value use rotex__constants , only : macheps => macheps_dp implicit none complex ( dp ), intent ( in ) :: a , b real ( dp ), intent ( in ), optional :: tol logical :: res real ( dp ) :: tol_local tol_local = macheps * max ( abs ( a ), abs ( b )) ; if ( present ( tol )) tol_local = tol res = . false . if ( abs ( a - b ) . gt . tol_local ) return res = . true . end function are_approx_eqz ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elementaL module function are_approx_eqr ( a , b , tol ) result ( res ) !! Comparre two a and b and see if magnitude of their difference is smaller than a tolerance, !! taking machine epsilon for their precision as the default value use rotex__constants , only : macheps => macheps_dp implicit none real ( dp ), intent ( in ) :: a , b real ( dp ), intent ( in ), optional :: tol logical :: res real ( dp ) :: tol_local tol_local = macheps * max ( abs ( a ), abs ( b )) ; if ( present ( tol )) tol_local = tol res = . false . if ( abs ( a - b ) . gt . tol_local ) return res = . true . end function are_approx_eqr ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function delta ( m , n ) result ( res ) !! Return the Kronecker delta function \\delta_{m,n} use rotex__constants , only : zero , one implicit none integer , intent ( in ) :: m , n real ( dp ) :: res res = zero ; if ( m . eq . n ) res = one end function delta ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function factorial_int ( n ) result ( res ) !! !n implicit none integer , intent ( in ) :: n real ( dp ) :: res res = gamma ( real ( n + 1 , kind = dp )) end function factorial_int ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function factorial_real ( n ) result ( res ) !! !n use rotex__constants , only : one implicit none real ( dp ), intent ( in ) :: n real ( dp ) :: res res = gamma ( n + one ) end function factorial_real ! ------------------------------------------------------------------------------------------------------------------------------ ! module function expm1r ( x ) result ( res ) !! Returns e&#94;x - 1. TODO, replace with a fast and accurate version !! coded natively in fortran ! implicit none real ( dp ), intent ( in ), value :: x real ( dp ) :: res res = c_expm1 ( x ) end function expm1r ! ------------------------------------------------------------------------------------------------------------------------------ ! module function expm1z ( z ) result ( res ) !! Returns e&#94;x - 1. TODO, replace with a fast and accurate version !! coded natively in fortran ! implicit none complex ( dp ), intent ( in ) :: z ! = a + ib complex ( dp ) :: res real ( dp ) :: sin_bover2 sin_bover2 = sin ( z % im / 2 ) res % re = c_expm1 ( z % re ) * cos ( z % im ) - 2 * sin_bover2 * sin_bover2 res % im = exp ( z % re ) * sin ( z % im ) end function expm1z ! ------------------------------------------------------------------------------------------------------------------------------ ! module function logp1r ( x ) result ( res ) !! Returns \\log(x+1) for real z. TODO, replace with a fast and accurate version !! coded natively in fortran ! implicit none real ( dp ), intent ( in ) :: x real ( dp ) :: res res = c_logp1 ( x ) end function logp1r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function logp1z ( z ) result ( res ) !! Returns \\log(z+1) for complex z. TODO, replace with a fast and accurate version ? !! coded natively in fortran ! use rotex__constants , only : one implicit none complex ( dp ), intent ( in ) :: z complex ( dp ) :: res complex ( dp ) :: zp1 zp1 = z + one res = log ( zp1 ) - ( zp1 - one - z ) / zp1 end function logp1z ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isintegerr ( x ) result ( res ) !! Check if x is an integer implicit none real ( dp ), intent ( in ) :: x logical :: res res = . false . if ( x . ne . nint ( x )) return res = . true . end function isintegerr ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isintegerz ( z ) result ( res ) !! Check if z is an integer use rotex__constants , only : zero implicit none complex ( dp ), intent ( in ) :: z logical :: res res = . false . if ( z % im . ne . zero ) return if ( z % re . ne . nint ( z % re )) return res = . true . end function isintegerz ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isnaturalr ( x ) result ( res ) !! Check if x is a natural number (1, 2, 3, ...) use rotex__constants , only : zero implicit none real ( dp ), intent ( in ) :: x logical :: res integer :: nintx res = . false . nintx = nint ( x ) if ( x . ne . nintx ) return if ( nintx . le . 0 ) return res = . true . end function isnaturalr ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isnaturalz ( z ) result ( res ) !! Check if z is a natural number (1, 2, 3, ...) use rotex__constants , only : zero implicit none complex ( dp ), intent ( in ) :: z logical :: res integer :: nintz res = . false . nintz = nint ( z % re ) if ( z % im . ne . zero ) return if ( z % re . ne . nintz ) return if ( nintz . le . 0 ) return res = . true . end function isnaturalz ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function argi ( z ) result ( res ) !! Return the phase of an integer (as a complex number) in (-π,π] use rotex__constants , only : pi implicit none integer , intent ( in ) :: z real ( dp ) :: res res = 0.0_dp if ( z . ge . 0 ) return res = pi end function argi ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function argr ( z ) result ( res ) !! Return the phase of a real number (as a complex number) in (-π,π] use rotex__constants , only : pi implicit none real ( dp ), intent ( in ) :: z real ( dp ) :: res res = 0.0_dp if ( z . ge . 0._dp ) return res = pi end function argr ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function argc ( z ) result ( res ) !! Return the phase of a complex number in (-π,π] use rotex__constants , only : pi , zero implicit none complex ( dp ), intent ( in ) :: z real ( dp ) :: res res = zero if ( res . eq . ( zero , zero )) return res = atan2 ( z % im , z % re ) end function argc ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function invi ( i ) result ( res ) !! Return the real 1/i for integer i implicit none integer , intent ( in ) :: i real ( dp ) :: res res = 1 / real ( i , kind = dp ) end function invi ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function invr ( x ) result ( res ) !! Return 1/x use rotex__constants , only : zero implicit none real ( dp ), intent ( in ) :: x real ( dp ) :: res res = 1 / x end function invr ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function invz ( z ) result ( res ) !! Return 1/z for complex z. If the imaginary part of z is 0, flip its sign use ieee_arithmetic , only : ieee_is_negative , ieee_copy_sign implicit none complex ( dp ), intent ( in ) :: z complex ( dp ) :: res res = 1 / z if ( z % im . ne . 0 ) return if ( ieee_is_negative ( z % im ) . eqv . . true .) return res % im = - res % im end function invz ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function iseven ( n ) result ( res ) integer , intent ( in ) :: n logical :: res res = . false . if ( iand ( n , 1 ) . eq . 1 ) return res = . true . end function iseven ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isodd ( n ) result ( res ) integer , intent ( in ) :: n logical :: res res = . not . iseven ( n ) end function isodd ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function istriangle ( a , b , c ) result ( res ) !! returns whether the arguments satisfy the triangle inequality, !! assuming that they're positive quantities implicit none integer , intent ( in ) :: a integer , intent ( in ) :: b integer , intent ( in ) :: c logical :: res res = . false . if ( c . gt . a + b ) return if ( a . gt . b + c ) return if ( b . gt . a + c ) return res = . true . end function istriangle ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function log_factorial_i ( n ) result ( res ) !! returns ln(n!) for integer n use rotex__system , only : die implicit none integer , intent ( in ) :: n real ( dp ) :: res select case ( n ) case ( 0 ) ; res = 0.0_dp case ( 1 ) ; res = 1.0_dp case ( 2 :) ; res = log_gamma ( n + 1.0_dp ) case default call die ( \"ln(n!) not defined for negative integer n\" ) end select end function log_factorial_i ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function log_factorial_r ( n ) result ( res ) !! returns ln(n!) for real n use rotex__system , only : die implicit none real ( dp ), intent ( in ) :: n real ( dp ) :: res if ( n . lt . 0 ) call die ( \"ln(n!) not defined for negative real n\" ) res = log_gamma ( n + 1 ) end function log_factorial_r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function logb_ii ( b , x ) result ( res ) !! Returns the logarithm of x in the base b implicit none integer , intent ( in ) :: b integer , intent ( in ) :: x real ( dp ) :: res res = log ( real ( x , kind = dp )) / log ( real ( b , kind = dp )) end function logb_ii pure elemental function logb_rr ( b , x ) result ( res ) !! Returns the logarithm of x in the base b implicit none real ( dp ), intent ( in ) :: b real ( dp ), intent ( in ) :: x real ( dp ) :: res res = log ( x ) / log ( b ) end function logb_rr pure elemental function logb_cc ( b , x ) result ( res ) !! Returns the logarithm of x in the base b implicit none complex ( dp ), intent ( in ) :: b complex ( dp ), intent ( in ) :: x complex ( dp ) :: res res = log ( x ) / log ( b ) end function logb_cc ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function logrange_ib ( a , b , n , base , inclast ) result ( res ) !! Returns an array of n log-spaced values from a to b. By default, the base is 10 !! if omitted but can be changed by the user implicit none integer ( dp ), intent ( in ) :: a , b integer , intent ( in ) :: n integer , intent ( in ), optional :: base !! Logarithm base logical , intent ( in ), optional :: inclast !! Whether to include the last value b real ( dp ) :: res ( n ) logical :: inclast_ integer :: base_ inclast_ = . true . ; if ( present ( inclast )) inclast_ = inclast base_ = 10 ; if ( present ( base )) base_ = base res = logrange_rb ( real ( a , kind = dp ), real ( b , kind = dp ), n , real ( base_ , kind = dp ), inclast_ ) end function logrange_ib pure function logrange_rb ( a , b , n , base , inclast ) result ( res ) !! Returns an array of n log-spaced values from a to b. By default, the base is 10 !! if omitted but can be changed by the user implicit none real ( dp ), intent ( in ) :: a , b integer , intent ( in ) :: n real ( dp ), intent ( in ), optional :: base !! Logarithm base logical , intent ( in ), optional :: inclast !! Whether to include the last value b real ( dp ) :: res ( n ) logical :: inclast_ integer :: i , m real ( dp ) :: base_ real ( dp ) :: start , finish real ( dp ) :: dx real ( dp ) :: logx ( n ) base_ = 1 0._dp ; if ( present ( base )) base_ = base inclast_ = . true . ; if ( present ( inclast )) inclast_ = inclast if ( inclast_ ) then m = n else m = n + 1 endif start = logb ( base_ , a ) finish = logb ( base_ , b ) dx = ( finish - start ) / ( m - 1 ) logx = [( start + i * dx , i = 0 , m - 1 )] res = base_ ** logx ( 1 : n ) end function logrange_rb ! -------------------------------------------------------------------------------------------------------------------------------- ! pure elemental module function neg ( i ) result ( res ) !! Returns the integer (-1)&#94;{i)} implicit none integer , intent ( in ) :: i integer :: res res = 1 if ( iand ( i , 1 ) . eq . 0 ) return res = - 1 end function neg ! ================================================================================================================================ ! end module rotex__functions ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__functions.f.html"},{"title":"rotex__characters.f – ROTEX","text":"Source Code ! =================================================================================================================================! module rotex__characters !! Contains procedures related to characters and character arrays, such as converting integers to characters use rotex__kinds , only : dp use rotex__functions , only : iseven implicit none private ! -- procedures public :: ndigits public :: s2hms public :: int2char public :: dJ2char public :: add_trailing public :: to_lower public :: to_upper public :: sup public :: sub integer , parameter :: big_char = 100 interface s2hms !! convert seconds to hours, minutes, seconds module procedure int_s2hms module procedure real_s2hms end interface interface int2char module procedure :: scalar_int2char module procedure :: vector_int2char end interface int2char ! =================================================================================================================================! contains ! =================================================================================================================================! ! ---------------------------------------------------------------------------------------------------------------------------------! pure module function int_s2hms ( s ) result ( time ) !! Given an integer 's' in seconds, convert to the format hh:mm:ss. implicit none integer , intent ( in ) :: s character (:), allocatable :: time character ( big_char / 10 ) :: tmp integer :: hh , mm , ss select case ( s ) case (: - 1 ) ; time = 'negative time' ; return case ( 0 : 59 ) ; hh = 0 ; mm = 0 ; ss = s ; write ( tmp , '(I2,\"h \",I2,\"m \",I2,\"s\")' ) hh , mm , ss case ( 60 : 3599 ) ; hh = 0 ; mm = s / 60 ; ss = s - mm * 60 ; write ( tmp , '(I2,\"h \",I2,\"m \",I2,\"s\")' ) hh , mm , ss case ( 3600 :) ; hh = s / 3600 ; mm = ( s - hh * 3600 ) / 60 ; ss = s - hh * 3600 - mm * 60 ; write ( tmp , '(I0,\"h \",I2,\"m \",I2,\"s\")' ) hh , mm , ss end select time = trim ( tmp ) end function int_s2hms ! ---------------------------------------------------------------------------------------------------------------------------------! pure module function real_s2hms ( s_re ) result ( time ) !! Given an integer in seconds, convert to the format hh:mm:ss. Input is a real, gets converted to int implicit none real ( dp ), intent ( in ) :: s_re character (:), allocatable :: time character ( big_char ) :: tmp integer :: hh , mm , ss integer :: s s = int ( s_re ) select case ( s ) case (: - 1 ) ; time = 'negative time' ; return case ( 0 : 59 ) ; hh = 0 ; mm = 0 ; ss = s case ( 60 : 3599 ) ; hh = 0 ; mm = s / 60 ; ss = s - mm * 60 case ( 3600 :) ; hh = s / 3600 ; mm = ( s - hh * 3600 ) / 60 ; ss = s - hh * 3600 - mm * 60 end select write ( tmp , '(I0,\"h \",I0,\"m \",I0,\"s\")' ) hh , mm , ss time = trim ( tmp ) end function real_s2hms ! ---------------------------------------------------------------------------------------------------------------------------------! pure elemental function ndigits ( n ) result ( num ) !! Returns number of characters an integer will occupy use rotex__constants , only : one implicit none integer , intent ( in ) :: n integer :: num num = 1 if ( n . eq . 0 ) return num = floor ( log10 ( abs ( n ) * one )) + 1 ! -- account for minus sign if ( n . lt . 1 ) num = num + 1 end function ndigits ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function scalar_int2char ( i ) result ( res ) !! Writes the value i to a character as I0 implicit none integer , intent ( in ) :: i character (:), allocatable :: res allocate ( character ( ndigits ( i )) :: res ) write ( res , '(I0)' ) i end function scalar_int2char ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function vector_int2char ( i ) result ( res ) !! Writes the value i to a character as I0 implicit none integer , intent ( in ) :: i (:) character (:), allocatable :: res integer :: n if ( size ( i , 1 ) . eq . 0 ) then res = \"()\" return endif ! -- n-1 commas, and all the digits n = ( size ( i , 1 ) - 1 ) + sum ( ndigits ( i )) allocate ( character ( n ) :: res ) write ( res , '(*(I0,:,\",\"))' ) i res = \"(\" // res // \")\" end function vector_int2char ! ---------------------------------------------------------------------------------------------------------------------------------! pure module subroutine add_trailing ( chr , trail ) !! Add a trailing character `trail` to the character `chr` if it is not already the !! last character implicit none character (:), allocatable , intent ( inout ) :: chr character ( * ), intent ( in ) :: trail integer :: n integer :: m n = len ( chr ) - len ( trail ) + 1 m = len ( chr ) if ( n < 1 ) return if ( chr ( n : m ) . eq . trail ) return chr = chr // trail end subroutine add_trailing ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function dJ2char ( dJ ) result ( res ) !! Takes an integer dJ and results the character representing half of it. !! dJ2char(2) -> \"1\" !! dJ2char(3) -> \"3/2\" implicit none integer , intent ( in ) :: dJ !! Twice the angular momentum character (:), allocatable :: res !! The output character representation if ( iseven ( dJ ) . eqv . . true .) then res = int2char ( dJ / 2 ) else res = int2char ( dJ ) // \"|2\" endif end function dJ2char ! ------------------------------------------------------------------------------------------------------------------------------ ! ! simple elemental subroutine to_lower(chr) pure elemental subroutine to_lower ( chr ) !! converts a character to lower case implicit none character ( * ), intent ( inout ) :: chr integer , parameter :: shift = ichar ( 'a' ) - ichar ( \"A\" ) integer , parameter :: uppercase_a = ichar ( 'A' ) integer , parameter :: uppercase_z = ichar ( 'Z' ) integer :: i , n , ic n = len ( chr ) do i = 1 , n ic = ichar ( chr ( i : i )) ! -- cycle if the character isn't in [A,Z] if ( ic . lt . uppercase_a ) cycle if ( ic . gt . uppercase_z ) cycle chr ( i : i ) = char ( ic + shift ) enddo end subroutine to_lower ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental subroutine to_upper ( chr ) !! converts a character to upper case implicit none character ( * ), intent ( inout ) :: chr integer , parameter :: shift = ichar ( 'a' ) - ichar ( \"A\" ) integer , parameter :: lowercase_a = ichar ( 'a' ) integer , parameter :: lowercase_z = ichar ( 'z' ) integer :: i , n , ic n = len ( chr ) do i = 1 , n ic = ichar ( chr ( i : i )) ! -- cycle if the character isn't in [A,Z] if ( ic . lt . lowercase_a ) cycle if ( ic . gt . lowercase_z ) cycle chr ( i : i ) = char ( ic - shift ) enddo end subroutine to_upper ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function sub ( x ) result ( res ) !! Returns the subscript version of the integer x implicit none integer , intent ( in ) :: x character (:), allocatable :: res integer :: i character (:), allocatable :: xchar allocate ( character ( ndigits ( x )) :: res ) allocate ( character ( ndigits ( x )) :: xchar ) xchar (:) = int2char ( x ) do i = 1 , len ( xchar ) select case ( xchar ( i : i )) case ( \"-\" ) ; res ( i : i ) = \"_\" case ( \"0\" ) ; res ( i : i ) = \"₀\" case ( \"1\" ) ; res ( i : i ) = \"₁\" case ( \"2\" ) ; res ( i : i ) = \"₂\" case ( \"3\" ) ; res ( i : i ) = \"₃\" case ( \"4\" ) ; res ( i : i ) = \"₄\" case ( \"5\" ) ; res ( i : i ) = \"₅\" case ( \"6\" ) ; res ( i : i ) = \"₆\" case ( \"7\" ) ; res ( i : i ) = \"₇\" case ( \"8\" ) ; res ( i : i ) = \"₈\" case ( \"9\" ) ; res ( i : i ) = \"₉\" end select enddo end function sub ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function sup ( x ) result ( res ) !! Returns the superscript version of the integer x implicit none integer , intent ( in ) :: x character (:), allocatable :: res integer :: i character (:), allocatable :: xchar allocate ( character ( ndigits ( x )) :: res ) allocate ( character ( ndigits ( x )) :: xchar ) xchar (:) = int2char ( x ) do i = 1 , len ( xchar ) select case ( xchar ( i : i )) case ( \"-\" ) ; res ( i : i ) = \"⁻\" case ( \"0\" ) ; res ( i : i ) = \"⁰\" case ( \"1\" ) ; res ( i : i ) = \"¹\" case ( \"2\" ) ; res ( i : i ) = \"²\" case ( \"3\" ) ; res ( i : i ) = \"³\" case ( \"4\" ) ; res ( i : i ) = \"⁴\" case ( \"5\" ) ; res ( i : i ) = \"⁵\" case ( \"6\" ) ; res ( i : i ) = \"⁶\" case ( \"7\" ) ; res ( i : i ) = \"⁷\" case ( \"8\" ) ; res ( i : i ) = \"⁸\" case ( \"9\" ) ; res ( i : i ) = \"⁹\" end select enddo end function sup ! =================================================================================================================================! end module rotex__characters ! =================================================================================================================================!","tags":"","url":"sourcefile/rotex__characters.f.html"},{"title":"rotex__hamilton.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__hamilton !! Module containing procedures to construct and diagonalize rotational Hamiltonians use rotex__types , only : dp , eigenH_type , N_states_type implicit none private ! public :: H_linear public :: H_asym public :: assign_projections ! public :: get_different_K_projections ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine H_asym ( N , eigenH , Bx , By , Bz , cd4 , cd6 ) !! Construct the 2N + 1 \\times 2N + 1 symmetric top rigid-rotor Hamiltonian !!   H = Bx N_x&#94;2 + By N_y&#94;2 + Bz N_z&#94;2 use rotex__utils , only : assert use rotex__arrays , only : realloc , is_symmetric use rotex__types , only : cd4_type , cd6_type use rotex__system , only : die , stderr use rotex__arrays , only : eye use rotex__constants , only : zero , two , four implicit none integer , intent ( in ) :: N !! The rotational quantum number N type ( eigenH_type ), intent ( out ) :: eigenH !! The eigenvectors and eigenvalues of H !! The angular momentum number N real ( dp ), intent ( in ) :: Bx , By , Bz !! Rotational constants type ( cd4_type ), intent ( in ), optional :: cd4 !! The quartic centrifugal distortion parameters type ( cd6_type ), intent ( in ), optional :: cd6 !! The sextic centrifugal distortion parameters integer :: num_K integer :: k1 , k2 integer :: i1 , i2 integer , allocatable :: basis (:) real ( dp ) :: k real ( dp ), allocatable :: H (:,:) num_K = 2 * N + 1 allocate ( H ( num_K , num_K )) basis = [( k1 , k1 =- N , N )] ! -- check allocation on eigen energies and vectors, avoid reallocation call realloc ( eigenH % eigvals , num_K ) call realloc ( eigenH % eigvecs , num_K , num_K ) ! -- fill the H, loop over projections k, k + 2, k - 2. See the matrix elements of, e.g., !    \"Molecular Symmetry and Spectroscopy\", 2nd edition, by P.R. Bunker and P. Jensen, 11.2.4 do concurrent ( k2 = - N : N , k1 = - N : N ) k = k2 i1 = ( k1 + N ) + 1 i2 = ( k2 + N ) + 1 if ( k1 . eq . k2 ) then H ( i1 , i2 ) = ( Bx + By ) / 2 * N * ( N + 1 ) + ( Bz - ( Bx + By ) / 2 ) * k * k ! 11-55: 11-56, 11-57 elseif ( k1 . eq . k2 + 2 ) then H ( i1 , i2 ) = ( Bx - By ) / 4 * sqrt ( ( N * ( N + 1 ) - ( k + 1 ) * ( k + 2 ) ) * ( N * ( N + 1 ) - k * ( k + 1 ) ) ) ! 11-55: 11-59 elseif ( k1 . eq . k2 - 2 ) then H ( i1 , i2 ) = ( Bx - By ) / 4 * sqrt ( ( N * ( N + 1 ) - ( k - 1 ) * ( k - 2 ) ) * ( N * ( N + 1 ) - k * ( k - 1 ) ) ) ! 11-55: 11-58 else H ( i1 , i2 ) = zero endif enddo ! -- centrifugal distortion if supplied to the subroutine if ( present ( cd4 )) call add_cd4 ( H , cd4 , basis ) if ( present ( cd6 )) call add_cd6 ( H , cd6 , basis ) call assert ( is_symmetric ( H ), \"The rotational Hamiltonian is not symmetric\" ) ! -- diagonalize H diag : block use rotex__linalg , only : dsyev use rotex__characters , only : int2char integer :: lda integer :: lwork integer :: info character :: jobz character :: uplo real ( dp ), allocatable :: work (:) jobz = \"V\" ! -- return eigenvectors uplo = \"U\" ! -- use upper triangle \"ads\" lda = max ( 1 , num_K ) lwork = max ( 1 , 3 * num_K - 1 ) eigenH % eigvecs = H allocate ( work ( lwork )) call dsyev ( jobz , uplo , num_K , eigenH % eigvecs , lda , eigenH % eigvals , work , lwork , info ) if ( info . ne . 0 ) call die ( \"Procedure DSYEV returned with INFO = \" // int2char ( info )) end block diag end subroutine H_asym ! ------------------------------------------------------------------------------------------------------------------------------ ! impure subroutine add_cd4 ( H , cd4 , basis ) !! Add the quartic centrifugal distortion effects to the Hamiltonian use rotex__types , only : cd4_type use rotex__utils , only : assert use rotex__arrays , only : size_check use rotex__functions , only : isodd implicit none real ( dp ), intent ( inout ) :: H (:,:) !! Hamiltonian (already filled with A, B, C parameters) type ( cd4_type ), intent ( in ) :: cd4 !! ΔN, ΔNK, ΔK, δN, δK integer , intent ( in ) :: basis (:) !! Array of projections K of N that define the basis integer :: i1 , i2 , k1 , k2 integer :: n , nn , numk , k , kk , kp , km real ( dp ) :: dn , dnk , dk , deltan , deltak , s numk = size ( basis , 1 ) call size_check ( h , [ numk , numk ], \"H in ADD_CD4\" ) call assert ( isodd ( numk ), \"2N+1 must be odd\" ) ! -- N and the eigenvalues of N² → N(N+1) n = ( numk - 1 ) / 2 nn = n * ( n + 1 ) dn = cd4 % dn dnk = cd4 % dnk dk = cd4 % dk deltan = cd4 % deltan deltak = cd4 % deltak ! n2p1 = real(n*(n+1), kind=dp) do concurrent ( i2 = 1 : numk , i1 = 1 : numk ) k1 = basis ( i1 ) k2 = basis ( i2 ) k = k2 kk = k * k select case ( k1 - k2 ) case ( 0 ) ! -- <k|h|k> h ( i1 , i2 ) = h ( i1 , i2 ) & - dn * ( nn * nn ) & ! ΔN  N⁴ - dnk * ( nn * kk ) & ! ΔNK N²Nz² - dk * ( kk * kk ) ! ΔK  Nz⁴ case ( 2 ) ! -- <k-2|h|k> s = sqrt ( real ( ( nn - ( k + 1 ) * ( k + 2 )) * ( nn - k * ( k + 1 )), kind = dp )) ! <N,K+2|(N⁺)²|N,K> kp = k + 2 ! k1 h ( i1 , i2 ) = h ( i1 , i2 ) & - deltan * nn * s & ! ½ δN < k+2 | [N²,  (N⁺)²]₊ |k > → δN N(N+1) <k+2|(N⁺)²|k> - 0.5_dp * deltak * ( kk + kp * kp ) * s ! ½ δK < k+2 | [Nz², (N⁺)²]₊ |k > → ½ δK [ k² + (k+2)² ] <k+2|(N⁺)²|k> case ( - 2 ) ! -- <k+2|h|k> s = sqrt ( real ( ( nn - ( k - 1 ) * ( k - 2 )) * ( nn - k * ( k - 1 )), kind = dp )) ! <N,K-2|(N⁺)²|N,K> km = k - 2 ! k1 h ( i1 , i2 ) = h ( i1 , i2 ) & - deltan * nn * s & ! ½ δN [N²,  (N⁻)²]₊ → δN N(N+1) <k-2|(N⁻)²|k> - 0.5_dp * deltak * ( kk + km * km ) * s ! ½ δK [Nz², (N⁻)²]₊ → ½ δK [ k² + (k-2)² ] <k-2|(N⁻)²|k> end select enddo end subroutine add_cd4 ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine add_cd6 ( H , cd6 , basis ) !! Add the quartic centrifugal distortion effects to the Hamiltonian use rotex__types , only : cd6_type use rotex__utils , only : assert use rotex__arrays , only : size_check use rotex__functions , only : isodd implicit none real ( dp ), intent ( inout ) :: H (:,:) !! Hamiltonian (already filled with A, B, C parameters) type ( cd6_type ), intent ( in ) :: cd6 !! HN, HNK, HKN, HK, ηN, ηNK, ηK integer , intent ( in ) :: basis (:) !! Array of projections K of N that define the basis integer :: i1 , i2 , k1 , k2 integer :: n , nn , nn2 , nn3 , numk integer :: k , kk , kk2 , kk3 integer :: km , km2 , km4 , kp , kp2 , kp4 real ( dp ) :: hn , hnk , hkn , hk , etan , etank , etak , s numk = size ( basis , 1 ) call size_check ( h , [ numk , numk ], \"H in ADD_CD6\" ) call assert ( isodd ( numk ), \"2N+1 must be odd\" ) ! -- N and the eigenvalues of N² → N(N+1) n = ( numk - 1 ) / 2 nn = n * ( n + 1 ) nn2 = nn * nn nn3 = nn2 * nn hn = cd6 % hn hnk = cd6 % hnk hkn = cd6 % hkn hk = cd6 % hk etan = cd6 % etan etank = cd6 % etank etak = cd6 % etak ! n2p1 = real(n*(n+1), kind=dp) do concurrent ( i2 = 1 : numk , i1 = 1 : numk ) k1 = basis ( i1 ) k2 = basis ( i2 ) k = k2 kk = k * k kk2 = kk * kk kk3 = kk2 * kk select case ( k1 - k2 ) case ( 0 ) ! -- <k|h|k> h ( i1 , i2 ) = h ( i1 , i2 ) & - hn * nn3 & ! <-------- HN  (N²)³ - hnk * nn2 * kk & ! <-- HNK (N²)² Nz² - hkn * nn * kk2 & ! <-- HNK  N²   Nz⁴ - hk * kk3 ! <---- HK        Nz⁶ case ( 2 ) ! -- <k-2|h|k> s = sqrt ( real ( ( nn - ( k + 1 ) * ( k + 2 )) * ( nn - k * ( k + 1 )), kind = dp )) ! <N,K+2|(N⁺)²|N,K> kp = k + 2 ! k1 kp2 = kp * kp kp4 = kp2 * kp2 h ( i1 , i2 ) = h ( i1 , i2 ) & - etan * nn2 * s & ! <-- ½ ηN  [(N²)²,  (N₊)²]₊ - 0.5_dp * etank * nn * ( kk + kp2 ) * s & ! <-- ½ ηNK [ N²Nz², (N₊)²]₊ - 0.5_dp * etak * ( kk2 + kp4 ) * s ! <---- ½ ηNK [   Nz⁴, (N₊)²]₊ case ( - 2 ) ! -- <k+2|h|k> s = sqrt ( real ( ( nn - ( k - 1 ) * ( k - 2 )) * ( nn - k * ( k - 1 )), kind = dp )) ! <N,K-2|(N⁺)²|N,K> km = k - 2 ! k1 km2 = km * km km4 = km2 * km2 h ( i1 , i2 ) = h ( i1 , i2 ) & - etan * nn2 * s & ! <-- ½ ηN  [(N²)²,  (N₋)²]₊ - 0.5_dp * etank * nn * ( kk + km2 ) * s & ! <-- ½ ηNK [ N²Nz², (N₋)²]₊ - 0.5_dp * etak * ( kk2 + km4 ) * s ! <---- ½ ηNK [   Nz⁴, (N₋)²]₊ end select enddo end subroutine add_cd6 ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine assign_projections ( N , eigenH , absKvals , sort_eigvecs ) use rotex__arrays , only : realloc !! Using the eigenvectors and energies from a diagonalized rotational Hamiltonian, !! determine which projection is maximal. The eigenvectors can be in the Ka or Kc basis. !! This routine will return the array Kvals which indicats the absolute value of the projection that !! contributes the most to a particular eigenvector implicit none integer , intent ( in ) :: N !! The rotational quantum number N integer , intent ( out ), allocatable :: absKvals (:) !! Array of the absolte value of |K| that contributes the most to a particular eigenvector type ( eigenH_type ), intent ( in ) :: eigenH !! Contains the eigenvalues and eigenvectors of the rotational Hamiltonian for the given value of N, digaonalized in !! the Ka or the Kc symmetric top basis logical , intent ( in ), optional :: sort_eigvecs !! Sort the eigenvectors ? logical :: sort_eigvecs_local integer :: i integer :: num_K integer :: K integer , allocatable :: Kvals (:) num_K = 2 * N + 1 Kvals = [( K , K = - N , N )] sort_eigvecs_local = . true . ; if ( present ( sort_eigvecs )) sort_eigvecs_local = sort_eigvecs call realloc ( absKvals , num_k ) ! -- determine the projections do concurrent ( i = 1 : num_K ) absKvals ( i ) = abs ( Kvals ( maxloc ( abs ( eigenH % eigvecs (:, i )) ** 2 , 1 ) ) ) enddo end subroutine assign_projections ! ! ------------------------------------------------------------------------------------------------------------------------------ ! ! subroutine sort_eigenvectors(eigenH) !   !! Sort the eigenvectors and energies so that the energies are in increasing order !   use rotex__arrays, only: sort_index !   implicit none !   type(eigenH_type), intent(inout) :: eigenH !   integer :: n !   integer, allocatable :: indices(:) !   n = size(eigenH % eigvals, 1) !   allocate(indices(n)) !   ! -- sort energies, lowest first !   call sort_index(eigenH % eigvals, indices) !   ! -- swap columns based on sorted energies !   eigenH % eigvals = eigenH % eigvals(indices) !   eigenH % eigvecs(:,:) = eigenH % eigvecs(:, indices) ! end subroutine sort_eigenvectors ! ================================================================================================================================ ! end module rotex__hamilton ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__hamilton.f.html"},{"title":"rotex__arrays.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__arrays !! Various routines for arrays use rotex__types , only : dp implicit none private public :: append public :: append_uniq public :: uniq public :: remove_value public :: eye public :: adjoint public :: size_check public :: is_unitary public :: is_symmetric public :: norm_frob public :: realloc public :: unitary_defect public :: sort_index ! public :: vec2diag interface append_uniq module procedure :: append_uniq_i module procedure :: append_uniq_transition end interface append_uniq interface append module procedure :: append_i module procedure :: append_r module procedure :: append_rvector module procedure :: append_asymtop_transition module procedure :: append_elec_channel module procedure :: append_elec_channels module procedure :: append_asymtop_rot_channel module procedure :: append_asymtop_rot_channel_l end interface append interface adjoint module procedure :: adjoint_i module procedure :: adjoint_r module procedure :: adjoint_c end interface adjoint interface size_check module procedure :: size_check_1d module procedure :: size_check_2d end interface size_check interface norm_frob module procedure :: norm_frob_i module procedure :: norm_frob_r module procedure :: norm_frob_c end interface norm_frob interface realloc module procedure :: realloc_1d_int module procedure :: realloc_1d_real module procedure :: realloc_1d_cmplx module procedure :: realloc_1d_elec_channel module procedure :: realloc_2d_real module procedure :: realloc_2d_cmplx end interface realloc ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine realloc_1d_int ( arr , n ) implicit none integer , intent ( inout ), allocatable :: arr (:) integer , intent ( in ) :: n if ( allocated ( arr )) then if ( size ( arr , 1 ) . eq . n ) return deallocate ( arr ) allocate ( arr ( n )) return endif allocate ( arr ( n )) end subroutine realloc_1d_int ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine realloc_1d_real ( arr , n ) implicit none real ( dp ), intent ( inout ), allocatable :: arr (:) integer , intent ( in ) :: n if ( allocated ( arr )) then if ( size ( arr , 1 ) . eq . n ) return deallocate ( arr ) allocate ( arr ( n )) return endif allocate ( arr ( n )) end subroutine realloc_1d_real ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine realloc_1d_cmplx ( arr , n ) implicit none complex ( dp ), intent ( inout ), allocatable :: arr (:) integer , intent ( in ) :: n if ( allocated ( arr )) then if ( size ( arr , 1 ) . eq . n ) return deallocate ( arr ) allocate ( arr ( n )) return endif allocate ( arr ( n )) end subroutine realloc_1d_cmplx ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine realloc_1d_elec_channel ( arr , n ) use rotex__types , only : elec_channel_type implicit none type ( elec_channel_type ), intent ( inout ), allocatable :: arr (:) integer , intent ( in ) :: n if ( allocated ( arr )) then if ( size ( arr , 1 ) . eq . n ) return deallocate ( arr ) allocate ( arr ( n )) return endif allocate ( arr ( n )) end subroutine realloc_1d_elec_channel ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine realloc_2d_real ( arr , n , m ) implicit none real ( dp ), intent ( inout ), allocatable :: arr (:,:) integer , intent ( in ) :: n , m if ( allocated ( arr )) then if ( all ( shape ( arr ) . eq . [ n , m ])) return deallocate ( arr ) allocate ( arr ( n , m )) return endif allocate ( arr ( n , m )) end subroutine realloc_2d_real ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine realloc_2d_cmplx ( arr , n , m ) implicit none complex ( dp ), intent ( inout ), allocatable :: arr (:,:) integer , intent ( in ) :: n , m if ( allocated ( arr )) then if ( all ( shape ( arr ) . eq . [ n , m ])) return deallocate ( arr ) allocate ( arr ( n , m )) return endif allocate ( arr ( n , m )) end subroutine realloc_2d_cmplx ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function norm_frob_i ( A ) result ( res ) !! Returns the Frobenius norm for a matrix A implicit none integer , intent ( in ) :: A (:,:) real ( dp ) :: res res = sqrt ( real ( sum ( A * A ), kind = dp )) end function norm_frob_i ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function norm_frob_r ( A ) result ( res ) !! Returns the Frobenius norm for a matrix A implicit none real ( dp ), intent ( in ) :: A (:,:) real ( dp ) :: res res = sqrt ( sum ( A * A )) end function norm_frob_r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function norm_frob_c ( A ) result ( res ) !! Returns the Frobenius norm for a matrix A implicit none complex ( dp ), intent ( in ) :: A (:,:) real ( dp ) :: res res = sqrt ( sum ( abs ( A ) ** 2 )) end function norm_frob_c ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function adjoint_i ( A ) result ( res ) !! Returns the adjoint of an integer-valued matrix implicit none integer , intent ( in ) :: A (:,:) integer :: res ( size ( A , 2 ), size ( A , 1 )) res = transpose ( A ) end function adjoint_i ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function adjoint_r ( A ) result ( res ) !! Returns the adjoint of a real-valued matrix implicit none real ( dp ), intent ( in ) :: A (:,:) real ( dp ) :: res ( size ( A , 2 ), size ( A , 1 )) res = transpose ( A ) end function adjoint_r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function adjoint_c ( A ) result ( res ) !! Returns the adjoint of a complex-valued matrix implicit none complex ( dp ), intent ( in ) :: A (:,:) complex ( dp ) :: res ( size ( A , 2 ), size ( A , 1 )) res = conjg ( transpose ( A )) end function adjoint_c ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function unitary_defect ( A ) result ( rF ) !! Return the unitary defect with respect to the Frobenius norm !! rF = ||A&#94;{\\dagger}A-I||_F / sqrt{n} use rotex__system , only : die implicit none class ( * ), intent ( in ) :: A (:,:) real ( dp ) :: rF integer :: n , m integer :: i , j real ( dp ) :: err2 n = size ( A , 1 ) m = size ( A , 2 ) if ( n . ne . m ) call die ( \"Cannot determine the unitarity of a nonsquare matrix\" ) err2 = 0 select type ( A ) type is ( real ( dp )) realmat : block real ( dp ), allocatable :: G (:,:) real ( dp ) :: d allocate ( G ( n , m )) ! -- Gram matrix G = matmul ( adjoint ( A ), A ) do j = 1 , n do i = 1 , n ! -- subtract identity if i==j d = G ( i , j ) - merge ( 1 , 0 , i . eq . j ) ! -- accumulate norm squared err2 = err2 + d * d enddo enddo end block realmat type is ( complex ( dp )) cmplxmat : block complex ( dp ), allocatable :: G (:,:) complex ( dp ) :: d allocate ( G ( n , m )) ! -- Gram matrix G = matmul ( adjoint ( A ), A ) do j = 1 , n do i = 1 , n ! -- subtract identity if i==j d = G ( i , j ) - merge ( 1 , 0 , i . eq . j ) ! -- accumulate norm squared err2 = err2 + abs ( d ) ** 2 enddo enddo end block cmplxmat class default call die ( \"Trying to determine the unitary of a matrix that is neither real nor complex\" ) end select ! -- relative size-aware defect rF = sqrt ( err2 ) / sqrt ( real ( n , kind = dp )) end function unitary_defect ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function is_unitary ( A , rtol ) result ( res ) !! Determine whether a matrix is unitary w.r.t the Frobenius norm use rotex__constants , only : macheps => macheps_dp class ( * ), intent ( in ) :: A (:,:) !! The matrix real ( dp ), intent ( in ), optional :: rtol !! The optional relative tolerance, default 1e-10 logical :: res integer :: n , m real ( dp ) :: rF , tol tol = 1e-10_dp ; if ( present ( rtol )) tol = rtol res = . false . n = size ( A , 1 ) m = size ( A , 2 ) if ( n . ne . m ) return rF = unitary_defect ( A ) tol = max ( tol , 100 * macheps * sqrt ( real ( n , kind = dp ))) res = rF . lt . tol end function is_unitary ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function is_symmetric ( A , rtol ) result ( res ) !! Determine whether a matrix is symmetric use rotex__constants , only : macheps => macheps_dp class ( * ), intent ( in ) :: A (:,:) !! The matrix real ( dp ), intent ( in ), optional :: rtol !! The optional relative tolerance, default 1e-10 logical :: res integer :: n , m real ( dp ) :: tol , diff , denom tol = 1e-10_dp ; if ( present ( rtol )) tol = rtol res = . false . n = size ( A , 1 ) m = size ( A , 2 ) if ( n . ne . m ) return select type ( AA => A ) type is ( integer ) diff = norm_frob ( AA - transpose ( AA )) denom = max ( 1._dp , norm_frob ( AA )) type is ( real ( dp )) diff = norm_frob ( AA - transpose ( AA )) denom = max ( 1._dp , norm_frob ( AA )) type is ( complex ( dp )) diff = norm_frob ( AA - transpose ( AA )) denom = max ( 1._dp , norm_frob ( AA )) end select res = diff . le . tol * denom + sqrt ( macheps ) end function is_symmetric ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function eye ( n ) result ( res ) !! Return an n x n identity matrix use rotex__system , only : die integer , intent ( in ) :: n integer :: res ( n , n ) integer :: i if ( n . lt . 1 ) call die ( \"Attempt to make an identity matrix with dims < 1\" ) res = 0 do concurrent ( i = 1 : n ) res ( i , i ) = 1 enddo end function eye ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine remove_value ( arr , val ) !! Remove all instances of the value val from the array arr implicit none integer , intent ( inout ), allocatable :: arr (:) integer , intent ( in ) :: val integer , allocatable :: tmp (:) integer :: i , n if (. not . allocated ( arr )) return n = size ( arr , 1 ) do i = 1 , n if ( val . ne . arr ( i )) call append ( tmp , arr ( i )) enddo if (. not . allocated ( tmp )) then deallocate ( arr ) return endif call move_alloc ( tmp , arr ) end subroutine remove_value ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine append_uniq_i ( arr , new ) !! Append unique element \"new\" to array \"arr\" implicit none integer , intent ( in ) :: new integer , intent ( inout ), allocatable :: arr (:) select case ( allocated ( arr )) case (. true .) if ( any ( arr . eq . new )) return arr = [ arr , new ] case (. false .) arr = [ new ] end select end subroutine append_uniq_i ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine append_uniq_transition ( old , new ) !! Append unique element \"new\" to array \"old\" use rotex__types , only : asymtop_rot_transition_type , operator (. ne .), operator (. isin .) implicit none type ( asymtop_rot_transition_type ), intent ( in ) :: new (:) type ( asymtop_rot_transition_type ), intent ( inout ), allocatable :: old (:) logical , allocatable :: mask (:) integer :: itrans , nold , num_new_uniq , nnew type ( asymtop_rot_transition_type ), allocatable :: tmp (:) select case ( allocated ( old )) case (. false .) old = new case (. true .) ! -- count number of uniq elements nnew = size ( new , 1 ) nold = size ( old , 1 ) allocate ( mask ( nnew ), source = . false .) if (( new ( 1 ) . isin . old (:)) . eqv . . false .) mask ( 1 ) = . true . ! check first element ! get uniq elemnt indices do itrans = 2 , nnew if ( new ( itrans ) . isin . new (: itrans - 1 )) cycle ! skip dupicate elements in new if ( new ( itrans ) . isin . old (:)) cycle mask ( itrans ) = . true . enddo num_new_uniq = count ( mask ) ! -- return if nothing to append if ( num_new_uniq . eq . 0 ) return allocate ( tmp ( nold + num_new_uniq )) tmp ( 1 : nold ) = old (:) tmp ( nold + 1 :) = pack ( new , mask ) call move_alloc ( tmp , old ) end select end subroutine append_uniq_transition ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine append_i ( arr , val ) !! Append the value val to the array arr implicit none integer , intent ( inout ), allocatable :: arr (:) integer , intent ( in ) :: val select case ( allocated ( arr )) case (. true .) arr = [ arr , val ] case (. false .) arr = [ val ] end select end subroutine append_i ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine append_r ( arr , val ) !! Append the value val to the array arr implicit none real ( dp ), intent ( inout ), allocatable :: arr (:) real ( dp ), intent ( in ) :: val select case ( allocated ( arr )) case (. true .) arr = [ arr , val ] case (. false .) arr = [ val ] end select end subroutine append_r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine append_rvector ( arr , val ) !! Append the value val to the array arr use rotex__types , only : rvector_type implicit none type ( rvector_type ), intent ( inout ), allocatable :: arr (:) real ( dp ), intent ( in ) :: val (:) type ( rvector_type ) :: elem allocate ( elem % vec ( size ( val , 1 ))) elem % vec = val select case ( allocated ( arr )) case (. true .) arr = [ arr , elem ] case (. false .) arr = [ elem ] end select end subroutine append_rvector ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine append_asymtop_transition ( arr , val ) !! Append the value val to the array arr use rotex__types , only : asymtop_rot_transition_type implicit none type ( asymtop_rot_transition_type ), intent ( inout ), allocatable :: arr (:) type ( asymtop_rot_transition_type ), intent ( in ) :: val select case ( allocated ( arr )) case (. true .) arr = [ arr , val ] case (. false .) arr = [ val ] end select end subroutine append_asymtop_transition ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module subroutine append_elec_channel ( channels , channel ) !! Append elec_channel to the array elec_channels use rotex__types , only : elec_channel_type implicit none type ( elec_channel_type ), intent ( inout ), allocatable :: channels (:) type ( elec_channel_type ), intent ( in ) :: channel select case ( allocated ( channels )) case (. true .) ; channels = [ channels , channel ] case (. false .) ; channels = [ channel ] end select end subroutine append_elec_channel ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module subroutine append_elec_channels ( channels , channels2 ) !! Append channels2 to the array channels use rotex__types , only : elec_channel_type implicit none type ( elec_channel_type ), intent ( inout ), allocatable :: channels (:) type ( elec_channel_type ), intent ( in ) :: channels2 (:) select case ( allocated ( channels )) case (. true .) ; channels = [ channels , channels2 ] case (. false .) ; channels = [ channels2 ] end select end subroutine append_elec_channels ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module subroutine append_asymtop_rot_channel ( channels , channel ) !! Append asymtop_rot_channel to the array asymtop_rot_channels use rotex__types , only : asymtop_rot_channel_type implicit none type ( asymtop_rot_channel_type ), intent ( inout ), allocatable :: channels (:) type ( asymtop_rot_channel_type ), intent ( in ) :: channel select case ( allocated ( channels )) case (. true .) ; channels = [ channels , channel ] case (. false .) ; channels = [ channel ] end select end subroutine append_asymtop_rot_channel ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module subroutine append_asymtop_rot_channel_l ( channels , channel ) !! Append asymtop_rot_channel to the array asymtop_rot_channels use rotex__types , only : asymtop_rot_channel_l_type implicit none type ( asymtop_rot_channel_l_type ), intent ( inout ), allocatable :: channels (:) type ( asymtop_rot_channel_l_type ), intent ( in ) :: channel select case ( allocated ( channels )) case (. true .) ; channels = [ channels , channel ] case (. false .) ; channels = [ channel ] end select end subroutine append_asymtop_rot_channel_l ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine size_check_1d ( arr , larr , name ) !! Check that the size of the array arr is of length larr use rotex__system , only : die use rotex__characters , only : i2c => int2char implicit none class ( * ), intent ( in ) :: arr (:) integer , intent ( in ) :: larr character ( * ), intent ( in ) :: name if ( size ( arr , 1 ) . ne . larr ) & call die ( \"Array \" // name // \"(:) \" // i2c ( shape ( arr )) // \" must have the shape \" // i2c ([ larr ])) end subroutine size_check_1d ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine size_check_2d ( arr , larr , name ) !! Check that the size of the array arr is of length larr use rotex__system , only : die use rotex__characters , only : i2c => int2char implicit none class ( * ), intent ( in ) :: arr (:,:) integer , intent ( in ) :: larr (:) character ( * ), intent ( in ) :: name if ( any ( shape ( arr ) . ne . larr )) & call die ( \"Array \" // name // \"(:,:) \" // i2c ( shape ( arr )) // \" must have the shape \" // i2c ( larr )) end subroutine size_check_2d ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function uniq ( arr ) result ( res ) !! Returns the unique elements of arr implicit none integer , intent ( in ) :: arr (:) integer , allocatable :: res (:) integer :: n , i , k n = size ( arr , 1 ) k = 0 allocate ( res ( n )) do i = 1 , n if ( any ( res ( 1 : k ) . eq . arr ( i ))) cycle k = k + 1 res ( k ) = arr ( i ) enddo if ( k . eq . 0 ) then call realloc ( res , 0 ) return endif res = res ( 1 : k ) end function uniq ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine sort_index ( vals , idx ) !! Sort the array vals and return the permutation indices implicit none real ( dp ), intent ( in ) :: vals (:) integer , intent ( out ) :: idx (:) integer :: i , j , n integer :: key real ( dp ) :: targ n = size ( vals , 1 ) call size_check ( idx , n , \"IDX\" ) do concurrent ( i = 1 : n ) ; idx ( i ) = i ; enddo if ( n . le . 1 ) return do i = 2 , n key = idx ( i ) j = i - 1 targ = vals ( key ) do if ( j . lt . 1 ) exit if ( vals ( idx ( j )) . le . targ ) exit idx ( j + 1 ) = idx ( j ) j = j - 1 enddo idx ( j + 1 ) = key enddo end subroutine sort_index ! ================================================================================================================================ ! end module rotex__arrays ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__arrays.f.html"},{"title":"rotex__system.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__system !! Contains the definitions of stdout, stdin, stderr, and procedures to interact with the program/system !! such as producing warnings and stopping the execution of the code while producing error messages use , intrinsic :: iso_fortran_env , only : input_unit , output_unit , error_unit , iostat_end implicit none private save ! -- procedures public :: die public :: warn public :: error public :: determine_system_properties public :: mkdir public :: OS_NAME integer , parameter , public :: OS_ALL = - 1 ! \"all\" flag for profile support integer , parameter , public :: OS_UNKNOWN = 0 integer , parameter , public :: OS_LINUX = 1 integer , parameter , public :: OS_MACOS = 2 integer , parameter , public :: OS_WINDOWS = 3 integer , parameter , public :: OS_CYGWIN = 4 integer , parameter , public :: OS_SOLARIS = 5 integer , parameter , public :: OS_FREEBSD = 6 integer , parameter , public :: OS_OPENBSD = 7 logical , public :: OS_is_windows !! Is the current operating system Windows ? integer , parameter , public :: STDIN = input_unit !! The file unit associated with standard input integer , parameter , public :: STDOUT = output_unit !! The file unit associated with standard output integer , parameter , public :: STDERR = error_unit !! The file unit associated with standard error integer , parameter , public :: IOSTAT_OK = 0 !! The expected iostat result from a successful call to read() integer , public :: shell_ok !! The expected return value for the current environment and shell. Used in system calls. character ( 5 ), parameter , public :: PROGNAME = \"ROTEX\" !! The program name character ( 1 ), public :: DIRECTORY_SEPARATOR !! The OS-dependent directory separator character (:), allocatable :: mkdir_command !! The OS-dependent command used to make directories interface die module procedure :: die_1 ! module procedure :: die_2 end interface die interface warn module procedure :: warn_1 ! module procedure :: warn_2 end interface warn ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine error ( message ) !! Print error messages to the screen without the WARNING prompt. This will typically precede a call to DIE character ( * ), intent ( in ) :: message write ( stderr , * ) write ( stderr , '(\"ERROR :: \", A)' ) message write ( stderr , * ) end subroutine error ! ------------------------------------------------------------------------------------------------------------------------------ ! pure subroutine die_1 ( message ) !! Stop program execution with a message implicit none character ( * ), intent ( in ), optional :: message if (. not . present ( message )) error stop ; error stop message end subroutine die_1 ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine warn_1 ( message ) !! Print a warning message, but don't stop the program's execution implicit none character ( * ), intent ( in ) :: message write ( stderr , * ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , * ) write ( stderr , '(\"WARN\",X,\"::\",X,A)' ) message write ( stderr , * ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , * ) end subroutine warn_1 ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine determine_system_properties () !! Detects the type of the operating system. As far as system calls and directory structure go, !! this basically resolved to Windows or not Windows. implicit none integer :: OS OS = get_os_type () select case ( OS ) case ( OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD , OS_OPENBSD ) OS_is_windows = . false . case ( OS_UNKNOWN ) OS_is_windows = . false . call warn ( \"Operating system unknown. Assuming it is of type unix.\" ) case ( OS_WINDOWS ) OS_is_windows = . true . case default OS_is_windows = . false . call warn ( \"Unable to detect the fact that the operating system is unknown. Assuming it is of type unix.\" ) end select call system ( \"\" , status = shell_ok ) write ( stdout , '(A)' ) \"Detected operating system type :: \" // OS_NAME ( OS ) write ( stdout , * ) if ( OS_is_windows ) then directory_separator = \"\\\" mkdir_command = \" md \" else directory_separator = \" / \" mkdir_command = \" mkdir - p \" endif end subroutine determine_system_properties ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine mkdir(directory) !! Makes the directory \" directory \" and checks that it exists and is writeable implicit none character(*) :: directory integer :: stat character(:), allocatable :: cstat call execute_command_Line(mkdir_command // directory, exitstat = stat) cstat = \" \" write(cstat, '(I0)') stat cstat = trim(cstat) if(stat .eq. shell_ok) return call die(\" Trying to make directory '\" // directory // \"' returned status code \" // cstat ) end subroutine mkdir ! ---------------------------------------------------------------------------------------------- ! !  MIT License ! !  Copyright (c) 2020 fpm contributors ! !  Permission is hereby granted, free of charge, to any person obtaining a copy !  of this software and associated documentation files (the \" Software \"), to deal !  in the Software without restriction, including without limitation the rights !  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell !  copies of the Software, and to permit persons to whom the Software is !  furnished to do so, subject to the following conditions: ! !  The above copyright notice and this permission notice shall be included in all !  copies or substantial portions of the Software. ! !  THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR !  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, !  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE !  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER !  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, !  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE !  SOFTWARE. ! ---------------------------------------------------------------------------------------------- ! integer function get_os_type() result(r) !! Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN, !! OS_SOLARIS, OS_FREEBSD, OS_OPENBSD. !! !! At first, the environment variable `OS` is checked, which is usually !! found on Windows. Then, `OSTYPE` is read in and compared with common !! names. If this fails too, check the existence of files that can be !! found on specific system types only. !! !! Returns OS_UNKNOWN if the operating system cannot be determined. character(len=255) :: val integer            :: length, rc logical            :: file_exists logical, save      :: first_run = .true. integer, save      :: ret = OS_UNKNOWN if (.not. first_run) then r = ret return end if first_run = .false. r = OS_UNKNOWN ! Check environment variable `OSTYPE`. call get_environment_variable('OSTYPE', val, length, rc) if (rc == 0 .and. length > 0) then ! Linux if (index(val, 'linux') > 0) then r = OS_LINUX ret = r return end if ! macOS if (index(val, 'darwin') > 0) then r = OS_MACOS ret = r return end if ! Windows, MSYS, MinGW, Git Bash if (index(val, 'win') > 0 .or. index(val, 'msys') > 0) then r = OS_WINDOWS ret = r return end if ! Cygwin if (index(val, 'cygwin') > 0) then r = OS_CYGWIN ret = r return end if ! Solaris, OpenIndiana, ... if (index(val, 'SunOS') > 0 .or. index(val, 'solaris') > 0) then r = OS_SOLARIS ret = r return end if ! FreeBSD if (index(val, 'FreeBSD') > 0 .or. index(val, 'freebsd') > 0) then r = OS_FREEBSD ret = r return end if ! OpenBSD if (index(val, 'OpenBSD') > 0 .or. index(val, 'openbsd') > 0) then r = OS_OPENBSD ret = r return end if end if ! Check environment variable `OS`. call get_environment_variable('OS', val, length, rc) if (rc == 0 .and. length > 0 .and. index(val, 'Windows_NT') > 0) then r = OS_WINDOWS ret = r return end if ! Linux inquire (file='/etc/os-release', exist=file_exists) if (file_exists) then r = OS_LINUX ret = r return end if ! macOS inquire (file='/usr/bin/sw_vers', exist=file_exists) if (file_exists) then r = OS_MACOS ret = r return end if ! FreeBSD inquire (file='/bin/freebsd-version', exist=file_exists) if (file_exists) then r = OS_FREEBSD ret = r return end if end function get_os_type ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function OS_NAME(os) integer, intent(in) :: os character(len=:), allocatable :: OS_NAME select case (os) case (OS_LINUX);   OS_NAME =  \" Linux \" case (OS_MACOS);   OS_NAME =  \" macOS \" case (OS_WINDOWS); OS_NAME =  \" Windows \" case (OS_CYGWIN);  OS_NAME =  \" Cygwin \" case (OS_SOLARIS); OS_NAME =  \" Solaris \" case (OS_FREEBSD); OS_NAME =  \" FreeBSD \" case (OS_OPENBSD); OS_NAME =  \" OpenBSD \" case (OS_UNKNOWN); OS_NAME =  \" Unknown \" case (OS_ALL)    ; OS_NAME =  \" all \" case default     ; OS_NAME =  \" UNKNOWN \" end select end function OS_NAME ! ================================================================================================================================ ! end module rotex__system ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__system.f.html"},{"title":"rotex__utils.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__utils !! Some small utilities use rotex__kinds , only : dp , qp implicit none private public :: read_blank public :: assert public :: isint public :: kbn_sum public :: upcast public :: downcast public :: printmat public :: isin interface isint module procedure :: isint_r module procedure :: isint_c end interface isint interface kbn_sum module procedure :: kbn_sum_rqp module procedure :: kbn_sum_cdp module procedure :: kbn_sum_cqp end interface kbn_sum interface downcast module procedure :: downcast_r module procedure :: downcast_c end interface downcast interface upcast module procedure :: upcast_r module procedure :: upcast_c end interface upcast interface printmat module procedure :: printmat_i module procedure :: printmat_r module procedure :: printmat_c end interface printmat ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental subroutine assert ( test , message ) use rotex__system , only : die implicit none logical , intent ( in ) :: test character ( * ), intent ( in ) :: message if ( test . eqv . . true .) return call die ( message ) end subroutine assert ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine read_blank ( read_unit , num_read ) !! Reads num_read lines from unit read_unit, not storing any information. If num_read is not supplied, read one line. implicit none integer , intent ( in ) :: read_unit integer , intent ( in ), optional :: num_read integer :: k , n n = 1 ; if ( present ( num_read )) n = num_read do k = 1 , n ; read ( read_unit , * ) ; enddo end subroutine read_blank ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isint_r ( x ) result ( res ) implicit none real ( dp ), intent ( in ) :: x logical :: res real ( dp ) :: tol tol = 8 * spacing ( x ) res = . false . if ( abs ( x - anint ( x )) . gt . tol ) return res = . true . end function isint_r ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isint_c ( z ) result ( res ) implicit none complex ( dp ), intent ( in ) :: z logical :: res real ( dp ) :: tol real ( dp ) :: a a = z % re tol = 8 * spacing ( a ) res = . false . if ( abs ( z % im ) . gt . tol ) return if ( abs ( a - anint ( a )) . gt . tol ) return res = . true . end function isint_c ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental subroutine kbn_sum_rqp ( summation , c , input ) !! Improved Kahan-Babuška algorithm accumulation for summations implicit none real ( qp ), intent ( inout ) :: summation , c real ( qp ), intent ( in ) :: input real ( qp ) :: t t = summation + input if ( abs ( summation ) . ge . abs ( input )) then c = c + ( summation - t ) + input else c = c + ( input - t ) + summation endif summation = t end subroutine kbn_sum_rqp ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental subroutine kbn_sum_cdp ( summation , c , input ) !! Improved Kahan-Babuška algorithm accumulation for summations implicit none complex ( dp ), intent ( inout ) :: summation , c complex ( dp ), intent ( in ) :: input complex ( dp ) :: t t = summation + input if ( abs ( summation ) . ge . abs ( input )) then c = c + ( summation - t ) + input else c = c + ( input - t ) + summation endif summation = t end subroutine kbn_sum_cdp ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental subroutine kbn_sum_cqp ( summation , c , input ) !! Improved Kahan-Babuška algorithm accumulation for summations implicit none complex ( qp ), intent ( inout ) :: summation , c complex ( qp ), intent ( in ) :: input complex ( qp ) :: t t = summation + input if ( abs ( summation ) . ge . abs ( input )) then c = c + ( summation - t ) + input else c = c + ( input - t ) + summation endif summation = t end subroutine kbn_sum_cqp ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module subroutine downcast_r ( hi , lo ) !! Send the value of hi to lo, respecting the kind of the types use rotex__types , only : dp , qp implicit none real ( qp ), intent ( in ) :: hi real ( dp ), intent ( out ) :: lo lo = real ( hi , kind = dp ) end subroutine downcast_r pure elemental module subroutine downcast_c ( hi , lo ) !! Send the value of hi to lo, respecting the kind of the types use rotex__types , only : dp , qp implicit none complex ( qp ), intent ( in ) :: hi complex ( dp ), intent ( out ) :: lo lo = cmplx ( hi % re , hi % im , kind = dp ) end subroutine downcast_c ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module subroutine upcast_r ( lo , hi ) !! Send the value of lo to hi, respecting the kind of the types use rotex__types , only : dp , qp implicit none real ( dp ), intent ( in ) :: lo real ( qp ), intent ( out ) :: hi hi = real ( lo , kind = qp ) end subroutine upcast_r pure elemental module subroutine upcast_c ( lo , hi ) !! Send the value of lo to hi, respecting the kind of the types use rotex__types , only : dp , qp implicit none complex ( dp ), intent ( in ) :: lo complex ( qp ), intent ( out ) :: hi hi = cmplx ( lo % re , lo % im , kind = qp ) end subroutine upcast_c ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine printmat_i ( M , funit , header ) !! Prints a matrix to the supplied funit, otherwise print to stdout use rotex__kinds , only : dp use rotex__system , only : stdout integer , intent ( in ) :: M (:,:) integer , intent ( in ), optional :: funit character ( * ), intent ( in ), optional :: header character ( 9 ), parameter :: fmt = '(X,I7)' integer :: nr , nc , i , j , funit_local funit_local = stdout ; if ( present ( funit )) funit_local = funit nr = size ( M , 1 ) nc = size ( M , 2 ) write ( funit_local , * ) if ( present ( header )) write ( funit_local , '(A)' ) header do i = 1 , nr do j = 1 , nc write ( funit_local , fmt , advance = \"no\" ) M ( i , j ) enddo write ( funit_local , * ) enddo end subroutine printmat_i ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine printmat_r ( M , funit , header ) !! Prints a matrix to the supplied funit, otherwise print to stdout use rotex__kinds , only : dp use rotex__system , only : stdout real ( dp ), intent ( in ) :: M (:,:) integer , intent ( in ), optional :: funit character ( * ), intent ( in ), optional :: header real ( dp ), parameter :: absmin = 1e-5_dp real ( dp ), parameter :: absmax = 1e2_dp character ( 9 ) :: exp_fmt = '(X,E11.4)' character ( 9 ) :: flt_fmt = '(X,F11.8)' integer :: nr , nc , i , j , funit_local real ( dp ) :: absm character (:), allocatable :: fmt funit_local = stdout ; if ( present ( funit )) funit_local = funit nr = size ( M , 1 ) nc = size ( M , 2 ) write ( funit_local , * ) if ( present ( header )) write ( funit_local , '(A)' ) header do i = 1 , nr do j = 1 , nc absm = M ( i , j ) if ( ( absm . le . absmin . AND . absm . ne . 0.0_dp ) . OR . absm . ge . absmax ) then fmt = exp_fmt else fmt = flt_fmt endif write ( funit_local , fmt , advance = \"no\" ) M ( i , j ) enddo write ( funit_local , * ) enddo end subroutine printmat_r ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine printmat_c ( M , funit , header ) !! Prints a matrix to the supplied funit, otherwise print to stdout use rotex__kinds , only : dp use rotex__system , only : stdout use ieee_arithmetic , only : copysign => ieee_copy_sign complex ( dp ), intent ( in ) :: M (:,:) integer , intent ( in ), optional :: funit character ( * ), intent ( in ), optional :: header real ( dp ), parameter :: absmin = 1e-5_dp real ( dp ), parameter :: absmax = 1e2_dp character ( 9 ) :: exp_fmt = '(X,E11.4)' character ( 9 ) :: flt_fmt = '(X,F11.8)' integer :: nr , nc , i , j , funit_local integer :: signc real ( dp ) :: absmr , absmc character (:), allocatable :: fmtr , fmtc funit_local = stdout ; if ( present ( funit )) funit_local = funit nr = size ( M , 1 ) nc = size ( M , 2 ) write ( funit_local , * ) if ( present ( header )) write ( funit_local , '(A)' ) header do i = 1 , nr do j = 1 , nc absmr = abs ( M ( i , j )% re ) absmc = abs ( M ( i , j )% im ) if ( ( absmr . le . absmin . AND . absmr . ne . 0._dp ) . OR . absmr . ge . absmax ) then fmtr = exp_fmt else fmtr = flt_fmt endif if ( ( absmc . le . absmin . AND . absmc . ne . 0._dp ) . OR . absmc . ge . absmax ) then fmtc = exp_fmt else fmtc = flt_fmt endif signc = nint ( copysign ( 1._dp , M ( i , j )% re )) write ( funit_local , fmtr , advance = \"no\" ) M ( i , j )% re write ( funit_local , '(A)' , advance = \"no\" ) \" +\" write ( funit_local , fmtc , advance = \"no\" ) absmc write ( funit_local , '(A)' , advance = \"no\" ) \" im,\" enddo write ( funit_local , * ) enddo end subroutine printmat_c ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function isin ( x , xl , xr , lclosed , rclosed ) result ( res ) !! Test whether x is in the interval spanned by x1,x2 !! l/rclosed if true include xl and xr, respectively. They are true by default implicit none real ( dp ), intent ( in ) :: x , xl , xr logical , intent ( in ), optional :: lclosed , rclosed logical :: res logical :: lclosed_ , rclosed_ lclosed_ = . true . ; if ( present ( lclosed )) lclosed_ = lclosed rclosed_ = . true . ; if ( present ( rclosed )) rclosed_ = rclosed res = . false . if ( x . lt . xl ) return if ( x . gt . xr ) return if ( lclosed_ . eqv . . false .) then if ( x . eq . xl ) return endif if ( rclosed_ . eqv . . false .) then if ( x . eq . xr ) return endif res = . true . end function isin ! ================================================================================================================================ ! end module rotex__utils ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__utils.f.html"},{"title":"rotex__splines.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__splines !! Wrapper routines for the spline fitting procedures implicit none private public :: interpolate_replace integer , parameter :: SPLINE_ORDER_KX = 3 integer , parameter :: DB1INK_IKNOT = 0 integer , parameter :: DB1VAL_IDX = 0 ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! impure module subroutine interpolate_replace ( xold , xnew , fx , idxx ) !! Interpolate f(xold) -> f(xnew). Only consider xnew values that are contained within xold for now. !! Xnew returns untouched, but fx is overwritten with interpolated values on the !! grid xnew(idxx) use rotex__kinds , only : dp use rotex__arrays , only : size_check use bspline_module , only : db1ink , db1val implicit none real ( dp ), intent ( in ) :: xold (:) !! The grid of values on which our function has been evaluated real ( dp ), intent ( in ) :: xnew (:) !! The new grid of values that we want our function to be evaluated on. real ( dp ), intent ( inout ), allocatable :: fx (:) !! On input:  evaluated function f(xold) !! On output: the evaluated function f(xnew) integer , intent ( out ), allocatable , optional :: idxx (:) !! The indices of values of xnew that are used to evaluate fx logical , allocatable :: mask (:) integer :: nxold , nxnew_chopped , iflag , inbvx , ix real ( dp ), allocatable :: tx (:), bcoef (:), w0 (:), fx_copy (:), xnew_chopped (:) nxold = size ( xold , 1 ) call size_check ( fx , nxold , \"FX\" ) mask = xnew . ge . xold ( 1 ) . AND . xnew . le . xold ( nxold ) ! -- get x-subgrid xnew_chopped = pack ( xnew , mask ) nxnew_chopped = size ( xnew_chopped , 1 ) if ( present ( idxx )) then idxx = [( ix , ix = 1 , size ( xnew , 1 ))] idxx = pack ( idxx , mask ) endif allocate ( tx ( nxold + SPLINE_ORDER_KX ), source = 0.0_dp ) allocate ( bcoef ( nxold ), source = 0.0_dp ) allocate ( fx_copy ( nxnew_chopped ), source = 0.0_dp ) allocate ( w0 ( 3 * SPLINE_ORDER_KX ), source = 0.0_dp ) ! -- interpolate call db1ink ( xold , nxold , fx , SPLINE_ORDER_KX , DB1INK_IKNOT , tx , bcoef , iflag ) ! -- evaluate inbvx = 1 do ix = 1 , nxnew_chopped call db1val ( & xnew_chopped ( ix ) & , DB1VAL_IDX & , tx & , nxold & , SPLINE_ORDER_KX & , bcoef & , fx_copy ( ix ) & , iflag & , inbvx & , w0 & , extrap = . false . & ) enddo call move_alloc ( fx_copy , fx ) end subroutine interpolate_replace ! ================================================================================================================================ ! end module rotex__splines ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__splines.f.html"},{"title":"rotex.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! program rotex !! The main program use rotex__drivers , only : make_grid , diagonalize_rotational_hamiltonian & , make_output_directories , do_coulomb_born_approx , do_kmat_xs , combine_cb_smat_xs use rotex__reading , only : read_namelists use rotex__types , only : dp , eigenh_type , n_states_type , config_type , asymtop_rot_channel_l_type & , asymtop_rot_channel_l_vector_type , cmatrix_type , rvector_type , asymtop_rot_transition_type use rotex__rft , only : rft_nonlinear use rotex__system , only : mkdir , die , stdout use rotex__hamilton , only : h_asym , assign_projections implicit none integer :: jmin , jmax !! The min/max values of J = N + l to consider integer :: nmin_ft , nmax_ft !! The min/max values of N to consider for the frame transformation. integer :: i_n , num_n integer , allocatable :: N_values (:) !! Contains the values of N to consider real ( dp ) :: start , finish , Eground real ( dp ), allocatable :: egrid_tot_smat (:) !! The total energy grid for the S-matrix calculations character (:), allocatable :: pcb_output_directory , tcb_output_directory , smat_output_directory type ( n_states_type ), allocatable :: n_states (:) !! The states of the system for a given N type ( asymtop_rot_transition_type ), allocatable :: transitions_cb (:), transitions_smat (:) type ( rvector_type ), allocatable :: Eel_grid_cb (:) !! Array of arrays of electron/collision energies for each transition type ( rvector_type ), allocatable :: xs_xcite_tcb (:), xs_xcite_pcb (:) !! Array of arrays of the Total and Partial Coulomb-Born cross sections for each transition type ( rvector_type ), allocatable :: xs_xcite_smat (:), xs_dxcite_smat (:) type ( config_type ) :: cfg ! GO start = time () call print_header () call read_namelists ( cfg ) call make_output_directories ( cfg % output_directory , cfg % use_CB , cfg % spinmults , cfg % use_kmat & , pcb_output_directory , tcb_output_directory , smat_output_directory ) ! -- determine the (number of) N values if ( cfg % use_kmat . eqv . . true .) then ! -- if we  use the K-matrix, then the S-matrix will be block !    diagonal in J = [ max(0, Nmin - lmax_kmat), Nmax + lmax_kmat ], but for !    each J-block of S to be unitary, we must calculate extra rotational wavefunctions !    N = [ max(0, Jmin - lmax_kmat), Jmax + lmax  ] jmin = max ( 0 , cfg % nmin - cfg % lmax_kmat ) jmax = cfg % nmax + cfg % lmax_kmat nmin_ft = max ( 0 , jmin - cfg % lmax_kmat ) nmax_ft = jmax + cfg % lmax_kmat num_n = nmax_ft - nmin_ft + 1 n_values = [( nmin_ft + i_n , i_n = 0 , nmax_ft - nmin_ft , 1 )] write ( stdout , '(a)' ) \"using a K-matrix to get cross sections, so we need to calculate more states & & so that each J-block of the S-matrix will be unitary.\" write ( stdout , '(a, i0, \"/\", i0)' ) \"smallest/largest value for n considered: \" , nmin_ft , nmax_ft write ( stdout , * ) else ! -- when not using a K-matrix (i.e. just getting Coulomb-Born !    cross sections) we only need the N values that we want for !    (de-)excitation num_n = cfg % nmax - cfg % nmin + 1 n_values = [( cfg % nmin + i_n , i_n = 0 , cfg % nmax - cfg % nmin , 1 )] write ( stdout , '(a, i0, \"/\", i0)' ) \"not using a k-matrix to get cross sections, so we only need the user-supplied& & values for nmin/nmax: \" & , cfg % nmin , cfg % nmax write ( stdout , * ) endif ! -- this array holds the information on the rotational states of the target allocate ( N_states ( num_N )) ! -- diagonalize the hamiltonian and assign state labels for the rotational states that !    will be involved in the transitions/collisions select case ( cfg % zaxis ) case ( \"a\" ) ; call print_dipoles ( cfg % cartesian_dipole_moments , x = \"B\" , y = \"C\" , z = \"A\" ) case ( \"b\" ) ; call print_dipoles ( cfg % cartesian_dipole_moments , x = \"C\" , y = \"A\" , z = \"B\" ) case ( \"c\" ) ; call print_dipoles ( cfg % cartesian_dipole_moments , x = \"A\" , y = \"B\" , z = \"C\" ) end select call diagonalize_rotational_hamiltonian ( cfg , num_N , N_values , N_states ) if ( cfg % use_CB . eqv . . true .) then call do_coulomb_born_approx ( & cfg & , n_states & , Eel_grid_cb & , transitions_cb & , xs_xcite_pcb & , xs_xcite_tcb & , pcb_output_directory & , tcb_output_directory ) endif ! -- do this only AFTER we have called DO_COULOMB_BORN_APPROX because it may use !    CDMS energies which will change the energies of our rotational levels (but not the eigenvectors) call print_rot_targ_states ( n_states ) usingkmat : if ( cfg % use_kmat ) then write ( stdout , * ) write ( stdout , '(A)' ) \"--------------------------\" write ( stdout , '(A)' ) \"Switching to K-matrix data\" write ( stdout , '(A)' ) \"--------------------------\" write ( stdout , * ) ! -- make the total energy grid for the K/S-matrix cross sections eground = n_states ( 1 ) % eigenh % eigvals ( 1 ) call make_grid ( egrid_tot_smat , eground , cfg % num_egrid_segs , cfg % egrid_segs , cfg % num_egrid , cfg % egrid_spacing ) call do_kmat_xs ( & cfg & , n_states & , egrid_tot_smat & , smat_output_directory & , transitions_smat & , xs_xcite_smat & , xs_dxcite_smat ) if ( cfg % use_cb . eqv . . false .) exit usingkmat ! -- now we combine the S-matrix cross sections (which are spin-averaged) with the !    Coulom-Born correcion (σTCB - σPCB) which are spin-independent. Each CB σ has its own !    energy grid, while the σSmat cross sections were all calculated on the same grid of total !    energies. The CB cross sections are resonance free, so we'll have to interpolate these !    to match the σSmat energy grid before we can do σTot = σSmat + σTCB - σPCB write ( stdout , * ) write ( stdout , '(\"Combining Coulomb-Born and S-matrix cross sections.\")' ) write ( stdout , '(\"⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻\")' ) call combine_cb_smat_xs ( & cfg & , Eel_grid_cb & , egrid_tot_smat & , transitions_cb & , xs_xcite_pcb & , xs_xcite_tcb & , transitions_smat & , xs_xcite_smat & , xs_dxcite_smat & ) endif usingkmat finish = time () call print_footer ( start , finish ) ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine print_header () use rotex__system , only : stdout , determine_system_properties use iso_fortran_env , only : compiler_version , compiler_options implicit none write ( stdout , * ) write ( stdout , * ) write ( stdout , '(A)' ) \"        ___           ___           ___           ___     e⁻    ___\" write ( stdout , '(A)' ) \"       /\\  \\         /\\  \\         /\\  \\         /\\  \\         |\\__\\\" write(stdout, '(A)') \" / :: \\ \\ / :: \\ \\ \\ : \\ \\ / :: \\ \\ | : | | \" write(stdout, '(A)') \" / : / \\ : \\ \\ / : / \\ : \\ \\ e ⁻ \\ : \\ \\ / : / \\ : \\ \\ | : | | e ⁻ \" write(stdout, '(A)') \" / :: \\~\\ : \\ \\ / : / \\ : \\ \\ / :: \\ \\ / :: \\~\\ : \\ \\ | : |__|__ \" write(stdout, '(A)') \" / : / \\ : \\ \\ : \\__\\ / : / __ / \\ : \\__\\ / : / \\ : \\__\\ / : / \\ : \\ \\ : \\__\\ ____ / :::: \\__\\ \" write(stdout, '(A)') \" \\ / _| :: \\ / : / / \\ : \\ \\ / : / / / : / \\ / __ / \\ : \\~\\ : \\ \\ / __ / \\ :::: / ~~ / ~ \" write(stdout, '(A)') \" | : | :: / / \\ : \\ / : / / / : / / \\ : \\ \\ : \\__\\ ~~| : |~~| \" write(stdout, '(A)') \" | : |\\ / __ / \\ : \\ / : / / / : / / \\ : \\ \\ / __ / | : | | \" write(stdout, '(A)') \" e ⁻ | : | | \\ :: / / \\ / __ / e ⁻ \\ : \\__\\ | : | | \" write(stdout, '(A)') \" \\|__| \\ / __ / \\ / __ / \\|__| \" write(stdout, *) write(stdout, *) write(stdout, '(A)') \" ROTational ( de - ) EXcitation by electron impact \" write(stdout, *) write(stdout, *) ! -- determine system / environment properies for system interaction later on call determine_system_properties write(stdout, \" ( 2 A ) \") \" Fortran compiler and version :: \", compiler_version() write(stdout, *) write(stdout, \" ( 2 A ) \") \" Fortran compiler options :: \", compiler_options() write(stdout, *) end subroutine print_header ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine print_footer(time_start, time_end) use rotex__types,      only: dp use rotex__system,     only: stdout use rotex__characters, only: s2hms implicit none real(dp) :: time_start real(dp) :: time_end write(stdout, *) write(stdout, '(A)') \" ======================================================================================================== \" write(stdout,'(A)') \" Program complete ( &#94; : \" write(stdout, *) write(stdout,'(\" Elapsed time : \",A)') s2hms(time_end - time_start) write(stdout, '(A)') \" ======================================================================================================== \" end subroutine print_footer ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine print_rot_targ_states(n_states) use rotex__types,     only: N_states_type use rotex__system,    only: stdout use rotex__constants, only: au2ev implicit none type(N_states_type), intent(in) :: n_states(:) integer  :: i,j,n,ka,kc real(dp) :: e character(:), allocatable :: fmt write(stdout,*) write(stdout, '(A)') \" Rotational target states \" write(stdout, '(A)') \" ⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻ \" write(stdout, '(4X, 3A5, A14)') \" N \", \" Ka \", \" Kc \", \" E ( meV ) \" do i=1, size(N_states, 1) n = n_states(i)%n do j=1,2*n+1 ka = n_states(i)%ka(j) kc = n_states(i)%kc(j) e  = n_states(i)%eigenh%eigvals(j)*au2ev*1000 ! sym = n_states(i)%eigenh%sym(j) if(abs(e) .lt. 0.001_dp) then fmt =  '(4X, 3I5, E14.5)' else fmt =  '(4X, 3I5, F14.5)' endif write(stdout, fmt) n, ka, kc, e enddo enddo write(stdout, *) end subroutine print_rot_targ_states ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine print_dipoles(dipole_xyz, x, y, z) !! Print the dipole components in the determined ABC frame use rotex__system,    only: stdout use rotex__constants, only: au2deb implicit none real(dp),     intent(in) :: dipole_xyz(3) character(1), intent(in) :: x, y, z write(stdout, '(\" Cartesian dipole moments in the inertial frame ABC : \")') write(stdout, '(\" μ ( \", A1, \" ): \", F7.4, \" Debye \")') x, dipole_xyz(1)*au2deb write(stdout, '(\" μ ( \", A1, \" ): \", F7.4, \" Debye \")') y, dipole_xyz(2)*au2deb write(stdout, '(\" μ ( \", A1, \" ): \", F7.4, \" Debye \" ) ' ) z , dipole_xyz ( 3 ) * au2deb end subroutine print_dipoles ! ================================================================================================================================ ! end program rotex ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex.f.html"},{"title":"rotex__polygamma.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__polygamma !! Routines for calculating Γ(z) and ln(Γ(z)). use rotex__kinds , only : dp , qp ! #ifdef WITH_STDLIB !   use stdlib_specialfunctions_gamma, only: gamma, log_gamma ! #endif implicit none private public :: gamma public :: log_gamma real ( dp ), parameter :: tol_dp = epsilon ( 1.0_dp ) #ifndef WITH_STDLIB interface gamma module procedure :: gamma_cdp end interface gamma interface log_gamma module procedure :: l_gamma_cdp end interface log_gamma ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental function gamma_cdp ( z ) result ( res ) !! MIT License !! !! Copyright (c) 2019-2021 stdlib contributors !! !! Permission is hereby granted, free of charge, to any person obtaining a copy !! of this software and associated documentation files (the \"Software\"), to deal !! in the Software without restriction, including without limitation the rights !! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell !! copies of the Software, and to permit persons to whom the Software is !! furnished to do so, subject to the following conditions: !! !! The above copyright notice and this permission notice shall be included in all !! copies or substantial portions of the Software. !! !! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR !! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, !! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE !! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER !! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, !! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE !! SOFTWARE. use rotex__utils , only : downcast implicit none complex ( dp ), intent ( in ) :: z complex ( dp ) :: res integer :: i real ( dp ), parameter :: zero_k1 = 0.0_dp real ( qp ), parameter :: half = 0.5_qp , & one = 1.0_qp , pi = acos ( - one ), sqpi = sqrt ( pi ) complex ( qp ) :: y , x , sum integer , parameter :: n = 24 real ( qp ), parameter :: r = 2 5.617904_qp real ( qp ), parameter :: d ( 0 : n ) = & [ 1.0087261714899910504854136977047144166e-11_qp , & 1.6339627701280724777912729825256860624_qp , & - 1.4205787702221583745972794018472259342e+1_qp , & 5.6689501646428786119793943350900908698e+1_qp , & - 1.3766376824252176069406853670529834070e+2_qp , & 2.2739972766608392140035874845640820558e+2_qp , & - 2.7058382145757164380300118233258834430e+2_qp , & 2.39614374587263042692333711131832094166e+2_qp , & - 1.6090450559507517723393498276315290189e+2_qp , & 8.27378183187161305711485619113605553100e+1_qp , & - 3.2678977082742592701862249152153110206e+1_qp , & 9.89018079175824824537131521501652931756_qp , & - 2.2762136356329318377213053650799013041_qp , & 3.93265017303573867227590563182750070164e-1_qp , & - 5.0051054352146209116457193223422284239e-2_qp , & 4.57142601898244576789629257292603538238e-3_qp , & - 2.8922592124650765614787233510990416584e-4_qp , & 1.20833375377219592849746118012697473202e-5_qp , & - 3.1220812187551248389268359432609135033e-7_qp , & 4.55117045361638520378367871355819524460e-9_qp , & - 3.2757632817493581828033170342853173968e-11_qp , & 9.49784279240135747819870224486376897253e-14_qp , & - 7.9480594917454410117072562195702526836e-17_qp , & 1.04692819439870077791406760109955648941e-20_qp , & - 5.8990280044857540075384586350723191533e-26_qp ] ! parameters from above referenced source. if ( abs ( z % im ) < tol_dp ) then res = cmplx ( gamma ( z % re ), kind = dp ) return end if if ( z % re < zero_k1 ) then x = cmplx ( abs ( z % re ), - z % im , kind = dp ) y = x - one else y = z - one end if sum = cmplx ( d ( 0 ), kind = qp ) do i = 1 , n sum = sum + d ( i ) / ( y + i ) end do y = exp (( y + half ) * log ( y + half + r ) - y ) * sum y = y * 2 / sqpi !Re(z) > 0 return if ( z % re < zero_k1 ) then y = - pi / ( sin ( pi * x ) * x * y ) !Re(z) < 0 return end if ! -- y -> res call downcast ( y , res ) end function gamma_cdp ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental function l_gamma_cdp ( z ) result ( res ) ! ! log_gamma function for any complex number, excluding negative whole number ! \"Computation of special functions\", Shanjie Zhang & Jianmin Jin, 1996, p.48 ! \"Computing the principal branch of log-gamma\", D.E.G. Hare, ! J. of Algorithms, 25(2), 1997 p. 221–236 ! ! Fortran 90 program by Jim-215-Fisher ! complex ( dp ), intent ( in ) :: z complex ( dp ) :: res , z1 , z2 real ( dp ) :: d integer :: m , i complex ( qp ) :: zr , zr2 , sum , s real ( dp ), parameter :: z_limit = 1 0.0_dp , zero_k1 = 0.0_dp integer , parameter :: n = 20 real ( qp ), parameter :: zero = 0.0_qp , one = 1.0_qp , & pi = acos ( - one ), ln2pi = log ( 2 * pi ) real ( qp ), parameter :: a ( n ) = [ & . 833333333333333333333333333333333333333 3E-1_qp ,& - . 277777777777777777777777777777777777777 8E-2_qp ,& . 793650793650793650793650793650793650793 7E-3_qp ,& - . 595238095238095238095238095238095238095 2E-3_qp ,& . 841750841750841750841750841750841750841 8E-3_qp ,& - . 191752691752691752691752691752691752691 8E-2_qp ,& . 641025641025641025641025641025641025641 0E-2_qp ,& - . 295506535947712418300653594771241830065 4E-1_qp ,& . 179644372368830573164938490015889396694 4E+0_qp ,& - . 139243221690590111642743221690590111642 7E+1_qp ,& . 134028640441683919944789510006901311249 1E+2_qp ,& - . 156848284626002017306365132452088973828 1E+3_qp ,& . 219310333333333333333333333333333333333 3E+4_qp ,& - . 361087712537249893571732652192422307364 8E+5_qp ,& . 691472268851313067108395250775673467553 3E+6_qp ,& - . 152382215394074161922833649588867805186 6E+8_qp ,& . 382900751391414141414141414141414141414 1E+9_qp ,& - . 108822660357843910890151491655251053747 3E+11_qp ,& . 347320283765002252252252252252252252252 3E+12_qp ,& - . 123696021422692744542517103492713248810 8E+14_qp ] ! parameters from above reference z2 = z if ( z % re < zero_k1 ) then z2 = cmplx ( abs ( z % re ), - z % im , kind = dp ) + 1 end if d = hypot ( z2 % re , z2 % im ) z1 = z2 m = 0 if ( d <= z_limit ) then !for small |z| m = ceiling ( z_limit - d ) z1 = z2 + m end if zr = one / z1 zr2 = zr * zr sum = ((( a ( 20 ) * zr2 + a ( 19 )) * zr2 + a ( 18 )) * zr2 + a ( 17 )) * zr2 sum = ((( sum + a ( 16 )) * zr2 + a ( 15 )) * zr2 + a ( 14 )) * zr2 sum = ((( sum + a ( 13 )) * zr2 + a ( 12 )) * zr2 + a ( 11 )) * zr2 sum = ((( sum + a ( 10 )) * zr2 + a ( 9 )) * zr2 + a ( 8 )) * zr2 sum = ((( sum + a ( 7 )) * zr2 + a ( 6 )) * zr2 + a ( 5 )) * zr2 sum = ((( sum + a ( 4 )) * zr2 + a ( 3 )) * zr2 + a ( 2 )) * zr2 sum = ( sum + a ( 1 )) * zr + ln2pi / 2 - z1 + ( z1 - 0.5_qp ) * log ( z1 ) if ( m /= 0 ) then s = cmplx ( zero , zero , kind = qp ) do i = 1 , m s = s + log ( cmplx ( z1 , kind = qp ) - i ) end do sum = sum - s end if if ( z % re < zero_k1 ) then sum = log ( pi ) - log ( sin ( pi * z )) - sum m = ceiling (( 2 * z % re - 3 ) / 4 ) sum % im = sum % im + 2 * pi * m * sign ( 1.0_dp , z % im ) end if res = cmplx ( sum , kind = dp ) end function l_gamma_cdp #endif ! ================================================================================================================================ ! end module rotex__polygamma ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__polygamma.f.html"},{"title":"rotex__reading.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__reading !! Contains procedures used in reading data (K-matrices and namelist data) use rotex__constants , only : UKRMOLX , MQDTR2K implicit none private public :: read_kmats public :: read_namelists ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine read_kmats ( kmat_dir & , channels_dir & , point_group & , spinmult & , kmat_lmax & , Kmat & , elec_channels & , channel_E_units & , kmat_eval_E_units & , kmat_output_type & , kmat_e_closest ) !! Reads in a K-matrix from a file with a very particular file format given by kmat_output_type use rotex__types , only : dp , elec_channel_type , permsort_channels , rvector_type , ivector_type use rotex__utils , only : read_blank use rotex__arrays , only : append , is_symmetric , realloc use rotex__system , only : die , stdout , stderr use rotex__symmetry , only : group_size , irrep_name use rotex__constants , only : au2ev , IOSTAT_END , IOSTAT_OK , spinmult_names , DEFAULT_INT use rotex__characters , only : int2char implicit none character ( * ), intent ( in ) :: kmat_dir !! Directory in which the files containing the K-matrices character ( * ), intent ( in ) :: channels_dir !! Directory in which the channel data are located character ( * ), intent ( in ) :: point_group !! The point group of the calculations integer , intent ( in ) :: spinmult !! The spin multiplicity (2S+1) of the system (target + e⁻) integer , intent ( in ) :: kmat_lmax !! The max value of l in the electronic partial wave basis real ( dp ), intent ( out ), allocatable :: Kmat (:,:) !! K(i, j) type ( elec_channel_type ), intent ( out ), allocatable :: elec_channels (:) !! The channel basis of the K-matrix: n,l,λ (the code calls λ m_l) character ( 1 ), intent ( in ) :: channel_E_units !! The units of the channel energies in the Kmat file. Options are : !!  - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV character ( 1 ), intent ( in ) :: kmat_eval_E_units !! The units of the energy at which the K-matrix was evaluated in the Kmat file. Options are : !!  - \"h\" for hartree !!  - \"e\" for eV !!  - \"r\" for Rydberg real ( dp ), intent ( in ) :: kmat_e_closest !! Evaluate the K-matrix that is closest to this energy character ( * ), intent ( in ) :: kmat_output_type !! The kind of K-matrix output to read logical :: skip_this_irrep integer :: i , j , ichan , iflat , i1 , i2 integer :: irrep integer :: nirreps integer :: nchans_total integer , allocatable :: nchans_irrep (:), idx (:) character (:), allocatable :: kmat_filename , channels_filename , filename , irrepname real ( dp ), allocatable :: channel_e_convert , kmat_e_convert type ( elec_channel_type ), allocatable :: elec_channels_this_irrep (:) type ( ivector_type ), allocatable :: index_map (:) type ( rvector_type ), allocatable :: kmat_flat (:) nirreps = group_size ( point_group ) allocate ( nchans_irrep ( nirreps )) write ( stdout , '(A)' ) \"----------------------------------------\" write ( stdout , '(A, I0)' ) \"Spin multiplicity: \" , spinmult write ( stdout , '(A)' ) \"⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻\" ! -- set the energy conversion scheme select case ( channel_E_units ) case ( \"h\" ) ; channel_e_convert = 1._dp case ( \"e\" ) ; channel_e_convert = 1._dp / au2ev case ( \"r\" ) ; channel_e_convert = 1._dp / 2._dp case default call die ( \"Unable to determine the K-matrix channel energy units. Current value : \" // channel_E_units // \". Supported& & values are 'r'ydberg, 'e'lectron-volt, and 'h'artree.\" ) end select select case ( Kmat_eval_E_units ) case ( \"h\" ) ; kmat_e_convert = 1._dp case ( \"e\" ) ; kmat_e_convert = 1._dp / au2ev case ( \"r\" ) ; kmat_e_convert = 1._dp / 2._dp case default call die ( \"Unable to determine the K-matrix evaluation energy units. Current value : \" // kmat_eval_E_units // \". Supported& & values are 'r'ydberg, 'e'lectron-volt, and 'h'artree.\" ) end select allocate ( index_map ( nirreps )) allocate ( kmat_flat ( nirreps )) nchans_total = 0 write ( stdout , '(\"Point group: \", A)' ) point_group ! -- read the K-matrices and electronic channels irrep_loop_kmats : do irrep = 1 , nirreps irrepname = irrep_name ( irrep , point_group ) write ( stdout , '(2X, \"Irrep: \", A)' ) irrepname filename = kmat_dir // int2char ( spinmult ) // irrepname // \".kmat\" select case ( kmat_output_type ) case ( UKRMOLX ) channels_filename = channels_dir // \"channels.geom1.\" // spinmult_names ( spinmult ) // \".\" // irrepname kmat_filename = kmat_dir // \"K-matrix.geom1.\" // spinmult_names ( spinmult ) // \".\" // irrepname call get_flat_kmat_and_channels_ukrmolx ( & channels_filename & , kmat_filename & , kmat_flat ( irrep )% vec & , channel_E_convert & , kmat_e_convert & , kmat_e_closest & , elec_channels_this_irrep & , nchans_irrep ( irrep ) & , skip_this_irrep ) case ( MQDTR2K ) ! -- the kmat file is expected to have the channels kmat_filename = kmat_dir // int2char ( spinmult ) // irrep_name ( irrep , point_group ) // \".kmat\" call get_flat_kmat_and_channels_mqdtr2k ( & kmat_filename & , kmat_flat ( irrep )% vec & , channel_E_convert & , kmat_e_convert & , kmat_e_closest & , elec_channels_this_irrep & , nchans_irrep ( irrep ) & , skip_this_irrep & ) case default call die ( \"KMAT_OUTPUT_TYPE must be \" // UKRMOLX // \" or \" // MQDTR2K ) end select ! -- if we need to focus on channel parity if ( point_group . eq . \"cs\" ) call fill_parity_array_this_irrep ( kmat_lmax , elec_channels_this_irrep , irrep , point_group ) call append ( elec_channels , elec_channels_this_irrep ) if ( skip_this_irrep . eqv . . true .) cycle irrep_loop_kmats ! -- total number of channels across all irreps nchans_total = nchans_total + nchans_irrep ( irrep ) ! -- index map: this irrep → full basis of channels allocate ( index_map ( irrep )% vec ( nchans_irrep ( irrep ))) do concurrent ( ichan = 1 : nchans_irrep ( irrep ) ) index_map ( irrep )% vec ( ichan ) = find_global_channel_index ( elec_channels_this_irrep ( ichan ), elec_channels ) enddo enddo irrep_loop_kmats deallocate ( elec_channels_this_irrep ) allocate ( Kmat ( nchans_total , nchans_total )) Kmat = 0 ! -- flattened K-matrices -> K-matrix for all irreps do irrep = 1 , nirreps ! -- flattened K-matrix for this irrep -> full symmetric K-matrix for all irreps iflat = 0 do i = 1 , nchans_irrep ( irrep ) i1 = index_map ( irrep )% vec ( i ) do j = i , nchans_irrep ( irrep ) iflat = iflat + 1 i2 = index_map ( irrep )% vec ( j ) Kmat ( i1 , i2 ) = kmat_flat ( irrep )% vec ( iflat ) Kmat ( i2 , i1 ) = kmat_flat ( irrep )% vec ( iflat ) enddo enddo enddo deallocate ( index_map , kmat_flat ) ! -- at this point the K-matrix is block-diagonal w.r.t. irrep, as it should be. !    Sort the channels by quantum number, and permute the elements of K accordingly call permsort_channels ( elec_channels , idx ) Kmat = Kmat ( idx , idx ) call print_channels ( elec_channels , stdout ) if ( is_symmetric ( Kmat ) . eqv . . true .) return write ( stderr , '(\"maxval(abs(Kmat - transpose(Kmat))): \", E20.10)' ) maxval ( abs ( Kmat - transpose ( Kmat ))) call die ( \"The K-matrix is not symmeric !\" ) end subroutine read_kmats ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine fill_parity_array_this_irrep ( lmax_kmat , elec_channels , irrep , point_group ) !! Fill the array M_PARITY, stored in the module ROTEX__SYMMETRY, that will later be accessed !! by the rotational frame transformation to determine which values of m from -lmax_kmat to lmax_kmat !! correspond to even and odd combinations of partial waves use rotex__types , only : elec_channel_type use rotex__system , only : die use rotex__symmetry , only : Ap , App , m_parity , even , odd use rotex__characters , only : i2c => int2char implicit none integer , intent ( in ) :: lmax_kmat !! Max value of l for the electronic channels type ( elec_channel_type ), intent ( in ) :: elec_channels (:) !! The electronic channels for the current irrep integer , intent ( in ) :: irrep !! The current irrep index character ( * ), intent ( in ) :: point_group !! The point group for the scattering calculations integer :: ichan , m if ( point_group . ne . \"cs\" ) call die ( \"Attempting to fill m_parity array for a point group& & other than Cs: \" // point_group ) if ( allocated ( m_parity ) . eqv . . false .) allocate ( m_parity ( - lmax_kmat : lmax_kmat ), source = 0 ) do ichan = 1 , size ( elec_channels , 1 ) m = elec_channels ( ichan ) % ml if ( m_parity ( m ) . ne . 0 ) cycle ! skip if set, but this probably should not happen select case ( irrep ) case ( Ap ) m_parity ( m ) = even case ( App ) m_parity ( m ) = odd case default call die ( \"Somehow, irrep (\" // i2c ( irrep ) // \") is not one of the valid values for the point group \" // point_group ) end select enddo end subroutine fill_parity_array_this_irrep ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine get_flat_kmat_and_channels_ukrmolx ( & channels_filename & , kmat_filename & , kmat_flat & , channel_e_convert & , kmat_e_convert & , kmat_e_closest & , elec_channels_this_irrep & , nchans_this_irrep & , skip_this_irrep ) !! Return the flattened (1D) K-matrix that is closest to the desired evaluation energy !! given by kmat_e_closest use rotex__constants , only : IOSTAT_END , IOSTAT_OK , au2ev use rotex__kinds , only : dp use rotex__arrays , only : realloc , size_check , append use rotex__types , only : elec_channel_type use rotex__utils , only : read_blank use rotex__system , only : stdout , stderr , die implicit none character ( * ), intent ( in ) :: channels_filename character ( * ), intent ( in ) :: kmat_filename real ( dp ), intent ( inout ), allocatable :: kmat_flat (:) real ( dp ), intent ( in ) :: channel_e_convert real ( dp ), intent ( in ) :: kmat_e_convert real ( dp ), intent ( in ) :: kmat_e_closest type ( elec_channel_type ), intent ( out ), allocatable :: elec_channels_this_irrep (:) integer , intent ( out ) :: nchans_this_irrep logical , intent ( out ) :: skip_this_irrep integer , parameter :: UKRMOL_KMAT_ELEMENTS_PER_LINE = 4 character ( 8 ), parameter :: UKRMOL_KMAT_ELEMENTS_FMT = '(D20.13)' integer :: iostat , ne , i , ichan , ie , ie_closest , l , ml , nelec , nchans , iflat integer :: funit , nchans_max , nskip , nskip_header , iline , icol , nlines , nchans_flat real ( dp ) :: E real ( dp ), allocatable :: kmat_energies (:) type ( elec_channel_type ) :: chan skip_this_irrep = . false . ! -- check file existence inquire ( file = kmat_filename , iostat = iostat ) if ( iostat . ne . IOSTAT_OK ) then skip_this_irrep = . true . return endif inquire ( file = channels_filename , iostat = iostat ) if ( iostat . ne . IOSTAT_OK ) call die ( \"K-matrix is here for this irrep, but the channel file is not !\" ) ! -- note that the K-matrices are expressed in the basis of OPEN channels, so the !    included channels changes when thresholds are crossed. This changes the number !    of channels and obviously the size of the resulting K-matrix. ! -- Count the number of energies/K-matrices open ( newunit = funit , file = kmat_filename ) ne = 0 call read_blank ( funit , 3 ) read ( funit , * ) i , i , i , nchans_max , nskip_header call read_blank ( funit , nskip_header ) nskip_header = nskip_header + 4 ! for the next re-reads do read ( funit , * , iostat = iostat ) nchans , i , nchans_flat , E if ( iostat . eq . IOSTAT_END ) exit ne = ne + 1 nskip = ceiling ( nchans_flat / real ( UKRMOL_KMAT_ELEMENTS_PER_LINE , kind = dp )) call read_blank ( funit , nskip ) enddo call realloc ( kmat_flat , nchans_flat ) kmat_flat = 0._dp ! -- read in the K-matrix energies rewind ( funit ) call realloc ( kmat_energies , ne ) call read_blank ( funit , nskip_header ) ie = 0 do read ( funit , * , iostat = iostat ) nchans , i , nchans_flat , E if ( iostat . eq . IOSTAT_END ) exit ie = ie + 1 kmat_energies ( ie ) = E * kmat_e_convert nskip = ceiling ( nchans_flat / real ( UKRMOL_KMAT_ELEMENTS_PER_LINE , kind = dp )) call read_blank ( funit , nskip ) enddo ! -- find the lowest energy ie_closest = minloc ( abs ( kmat_energies - kmat_e_closest ), 1 ) if ( ie_closest . lt . 1 ) call die ( \"Somehow, IE_CLOSEST returned a non-positive integer !\" ) write ( stdout , '(4X, \"User requested K-matrix at \", E20.10, \" eV\")' ) kmat_e_closest * au2ev write ( stdout , '(7X, \"Found Kmatrix at energy \",    E20.10, \" eV\")' ) kmat_energies ( ie_closest ) * au2ev ! -- Now, actually go and read that K-matrix rewind ( funit ) call read_blank ( funit , nskip_header ) ie = 0 kmat_read_loop : do read ( funit , * , iostat = iostat ) nchans , i , nchans_flat , E if ( iostat . eq . IOSTAT_END ) then call die ( \"Reach end of \" ) write ( stderr , '(\"Number of K-matrices/energies: \", I0)' ) ne write ( stderr , '(\"Target K-matrix energy: \", E20.10)' ) kmat_e_closest * au2ev write ( stderr , '(\"Closest available K-matrix is number \", I0)' ) ie_closest call die ( \"Could not find the K-matrix that is closest to the given target energy before EOF\" ) endif ie = ie + 1 if ( ie . ne . ie_closest ) then nskip = ceiling ( nchans_flat / real ( UKRMOL_KMAT_ELEMENTS_PER_LINE , kind = dp )) call read_blank ( funit , nskip ) else nlines = ceiling ( nchans_flat / real ( UKRMOL_KMAT_ELEMENTS_PER_LINE , kind = dp )) iflat = 0 ! -- iterate through the lines and columns of the flattened K-matrix !    in the file do iline = 1 , nlines do icol = 1 , UKRMOL_KMAT_ELEMENTS_PER_LINE iflat = iflat + 1 read ( funit , UKRMOL_KMAT_ELEMENTS_FMT , advance = 'no' ) kmat_flat ( iflat ) if ( iflat . eq . nchans_flat ) exit kmat_read_loop enddo read ( funit , * ) enddo write ( stderr , '(\"NLINES: \", I0)' ) nlines write ( stderr , '(\"UKRMOL_KMAT_ELEMENTS_PER_LINE: \", I0)' ) UKRMOL_KMAT_ELEMENTS_PER_LINE write ( stderr , '(\"NCHANS: \", I0)' ) nchans write ( stderr , '(\"NCHANS_FLAT: \", I0)' ) nchans_flat call die ( \"Improper K-matrix read loop exit. \" ) endif enddo kmat_read_loop close ( funit ) nchans_this_irrep = nchans if ( nchans . lt . 1 ) then write ( stderr , '(\"NCHANS: \", I0)' ) nchans call die ( \"The K-matrix cannot have less than one channel !\" ) endif call realloc ( elec_channels_this_irrep , nchans_this_irrep ) ! -- time to read the channels open ( newunit = funit , file = channels_filename ) write ( stdout , '(A)' ) \"Reading channels file at \" // channels_filename call read_blank ( funit , 2 ) ! -- read number of electronic states and number of electronic channels read ( funit , * ) nelec , i , i , nchans_max if ( nchans_max . lt . 1 ) then write ( stderr , '(\"NCHANS_MAX: \")' ) nchans_max call die ( \"Total number of channels computed for this irrep is < 1 !\" ) endif ! -- skip electronic state lines call read_blank ( funit , nelec + 1 ) ! -- channel read !    There is no iq from UKRmol+. Coulomb f and g have the default normalization q=1 do ichan = 1 , nchans_this_irrep read ( funit , * ) i , nelec , l , ml , E ! -- convert channel energy to atomic units E = E * channel_E_convert chan = elec_channel_type ( nelec = nelec , l = l , ml = ml , E = E ) elec_channels_this_irrep ( ichan ) = chan enddo close ( funit ) end subroutine get_flat_kmat_and_channels_ukrmolx ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine get_flat_kmat_and_channels_mqdtr2k ( & kmat_filename & , kmat_flat & , channel_e_convert & , kmat_e_convert & , kmat_e_closest & , elec_channels_this_irrep & , nchans_this_irrep & , skip_this_irrep ) !! Return the flattened (1D) K-matrix that is closest to the desired evaluation energy !! given by kmat_e_closest, where the K-matrix channels format is that of MQDTR2K use rotex__constants , only : IOSTAT_END , IOSTAT_OK , au2ev use rotex__kinds , only : dp use rotex__arrays , only : realloc , size_check use rotex__types , only : elec_channel_type use rotex__utils , only : read_blank use rotex__system , only : stdout , die implicit none character ( * ), intent ( in ) :: kmat_filename real ( dp ), intent ( inout ), allocatable :: kmat_flat (:) real ( dp ), intent ( in ) :: channel_e_convert real ( dp ), intent ( in ) :: kmat_e_convert real ( dp ), intent ( in ) :: kmat_e_closest type ( elec_channel_type ), intent ( out ), allocatable :: elec_channels_this_irrep (:) integer , intent ( out ) :: nchans_this_irrep logical , intent ( out ) :: skip_this_irrep integer :: iostat , ne , funit , ne_skip , i , ichan , ie , ie_closest , l , ml , iq , nelec integer :: nchans_irrep_flat real ( dp ) :: E real ( dp ), allocatable :: kmat_energies (:) skip_this_irrep = . false . inquire ( file = kmat_filename , iostat = iostat ) if ( iostat . ne . IOSTAT_OK ) then skip_this_irrep = . true . return endif open ( newunit = funit , file = kmat_filename ) ! -- get number of channels, skip to K-matrices, determine number of energies/K-matrices to read ne = 0 call read_blank ( funit ) read ( funit , * ) nchans_this_irrep nchans_irrep_flat = nchans_this_irrep * ( nchans_this_irrep + 1 ) / 2 call read_blank ( funit , nchans_this_irrep ) do ! -- energies are the first number, ignore the rest read ( funit , * , iostat = iostat ) E if ( iostat . eq . IOSTAT_END ) exit ne = ne + 1 enddo rewind ( funit ) ! -- skip header and channels; read K-matrix evaluation energies call realloc ( kmat_energies , ne ) call read_blank ( funit , 2 + nchans_this_irrep ) ie = 0 do ! -- energies are the first number, ignore the rest read ( funit , * , iostat = iostat ) E if ( iostat . eq . IOSTAT_END ) exit ie = ie + 1 kmat_energies ( ie ) = E * kmat_e_convert enddo ! -- find the lowest energy ie_closest = minloc ( abs ( kmat_energies - kmat_e_closest ), 1 ) if ( ie_closest . lt . 1 ) call die ( \"Somehow, IE_CLOSEST returned a non-positive integer !\" ) ne_skip = ie_closest - 1 write ( stdout , '(4X, \"User requested K-matrix at \", E20.10, \" eV\")' ) kmat_e_closest * au2ev write ( stdout , '(7X, \"Found Kmatrix at energy \",    E20.10, \" eV\")' ) kmat_energies ( ie_closest ) * au2ev ! -- skip header, read channels for this irrep rewind ( funit ) call read_blank ( funit , 2 ) call realloc ( elec_channels_this_irrep , nchans_this_irrep ) do ichan = 1 , nchans_this_irrep read ( funit , * ) i , nelec , l , ml , E , iq ! -- convert channel energy to atomic units E = E * channel_E_convert elec_channels_this_irrep ( ichan ) = elec_channel_type ( nelec = nelec , l = l , ml = ml , iq = iq , E = E ) enddo ! -- skip to the desired K-matrix call read_blank ( funit , ne_skip ) ! -- read the evaluation energy and the flattened K-matrix. We're only interested in the !    K-matrix now that we've identified the evaluation energy call realloc ( kmat_flat , nchans_irrep_flat ) kmat_flat = 0.0_dp read ( funit , * ) E , ( kmat_flat ( i ), i = 1 , nchans_irrep_flat ) close ( funit ) end subroutine get_flat_kmat_and_channels_mqdtr2k ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine print_channels ( channels , funit ) use rotex__kinds , only : dp use rotex__types , only : elec_channel_type use rotex__system , only : stdout implicit none type ( elec_channel_type ), intent ( in ) :: channels (:) integer , intent ( in ), optional :: funit integer :: nelec , l , ml , iq , funit_ , ichan , nchans real ( dp ) :: E funit_ = stdout ; if ( present ( funit )) funit_ = funit nchans = size ( channels , 1 ) write ( funit_ , * ) write ( funit_ , * ) write ( funit_ , '(A)' ) \"Electronic channels:\" write ( funit_ , '(A)' ) \"⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻⁻\" write ( funit_ , '(8X, 4A4, A15)' ) \"n\" , \"l\" , \"ml\" , \"iq\" , \"E (eV)\" do ichan = 1 , nchans nelec = channels ( ichan ) % nelec l = channels ( ichan ) % l ml = channels ( ichan ) % ml iq = channels ( ichan ) % iq E = channels ( ichan ) % E write ( funit_ , '(4X, 5I4, E15.7)' ) ichan , nelec , l , ml , iq , E enddo write ( funit_ , * ) end subroutine print_channels ! ------------------------------------------------------------------------------------------------------------------------------ ! pure function find_global_channel_index ( channel , channels ) result ( i ) use rotex__types , only : operator (. ne .), elec_channel_type use rotex__system , only : die implicit none type ( elec_channel_type ), intent ( in ) :: channel type ( elec_channel_type ), intent ( in ) :: channels (:) integer :: i , n n = size ( channels , 1 ) do i = 1 , n if ( channel . ne . channels ( i )) cycle return enddo call die ( \"Failed to find the given channel !\" ) end function find_global_channel_index ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine read_namelists ( cfg ) !! Reads user parameters and puts them into the config derived type use rotex__types , only : dp , config_type , cd4_type , cd6_type use rotex__arrays , only : append , remove_value use rotex__system , only : stdin , stdout , ds => directory_separator , die use rotex__constants , only : au2invcm , au2ev , macheps => macheps_dp , au2cm , au2deb , DEFAULT_CHAR1 & , UKRMOLX , MQDTR2K use rotex__characters , only : add_trailing , to_lower implicit none type ( config_type ), intent ( out ) :: cfg integer , parameter :: DEFAULT_INT = huge ( 1 ) ! -- namelist: control integer :: Nmin integer :: Nmax logical :: use_kmat logical :: use_CB integer :: spin_isomer_kind = 0 character (:), allocatable :: output_directory character ( 1 ) :: rotor_kind = DEFAULT_CHAR1 character ( 1 ) :: zaxis real ( dp ) :: abc ( 3 ) = 0.0_dp integer :: target_charge = DEFAULT_INT logical :: add_cd4 = . false . logical :: add_cd6 = . false . ! -- cd4 real ( dp ) :: dn = 0.0_dp real ( dp ) :: dnk = 0.0_dp real ( dp ) :: dk = 0.0_dp real ( dp ) :: deltan = 0.0_dp real ( dp ) :: deltak = 0.0_dp ! -- cd6 real ( dp ) :: hn = 0.0_dp real ( dp ) :: hnk = 0.0_dp real ( dp ) :: hkn = 0.0_dp real ( dp ) :: hk = 0.0_dp real ( dp ) :: etan = 0.0_dp real ( dp ) :: etank = 0.0_dp real ( dp ) :: etak = 0.0_dp ! -- namelist: kmat logical :: real_spherical_harmonics = . true . integer :: lmax_kmat = DEFAULT_INT integer :: num_egrid_segs integer , allocatable :: num_egrid (:) integer , allocatable :: spinmults (:) real ( dp ), allocatable :: egrid_segs (:) character ( 1 ) :: channel_energy_units_override = DEFAULT_CHAR1 character ( 1 ) :: kmat_energy_units_override = DEFAULT_CHAR1 character ( 3 ) :: egrid_spacing character ( 7 ) :: kmat_output_type = \"=======\" character (:), allocatable :: point_group character (:), allocatable :: kmat_dir character (:), allocatable :: channels_dir ! -- namelist: coulomb logical :: use_CDMS_einstA = . false . logical :: only_einsta = . false . logical :: do_xtrap = . false . logical :: do_dipole = . true . logical :: do_quadrupole = . false . logical :: analytic_total_cb ( 2 ) integer :: nE = DEFAULT_INT integer :: nE_xtrap = DEFAULT_INT integer :: lmax_partial = DEFAULT_INT integer :: lmax_total = DEFAULT_INT real ( dp ) :: Ei = 0.0_dp real ( dp ) :: Ef = 0.0_dp real ( dp ) :: Ei_xtrap = 0.0_dp real ( dp ) :: cartesian_dipole_moments ( 3 ) ! real(dp) :: cartesian_quadrupole_moments(6) real ( dp ) :: xs_zero_threshold = 0.0_dp ! include all cross sections by default real ( dp ) :: kmat_energy_closest = 0.0_dp ! just take the first one character (:), allocatable :: CDMS_file namelist / control_namelist / & !! Contains parameters and values that are necessary to run the program output_directory & , spin_isomer_kind & , nmin & , nmax & , use_kmat & , use_cb & , zaxis & , rotor_kind & , target_charge & , abc & , add_cd4 & , add_cd6 & , dn , dnk , dk , deltan , deltak & , hn , hnk , hkn , hk , etan , etank , etak & , xs_zero_threshold namelist / kmat_namelist / & !! Parameters regarding the K-matrces used for (de-excitation) kmat_dir & , channels_dir & , lmax_kmat & , point_group & , num_egrid_segs & , num_egrid & , egrid_segs & , egrid_spacing & , spinmults & , kmat_output_type & , kmat_energy_closest & , real_spherical_harmonics & , channel_energy_units_override & , kmat_energy_units_override namelist / coulomb_namelist / & !! Parameters regarding the Coulomb-Born approximation !! used for (de-)excitation use_CDMS_einstA & , only_einsta & , cdms_file & , ei & , ef & , ne & , ne_xtrap & , do_xtrap & , ei_xtrap & , cartesian_dipole_moments & ! , cartesian_quadrupole_moments & , do_dipole & , do_quadrupole & , analytic_total_cb & , lmax_partial & , lmax_total !!!!!!!!!!!!!!!!!!!!!! CONTROL_NAMELIST !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! allocate ( character ( 1000 ) :: output_directory ) ! -- read read ( stdin , control_namelist ) ! -- check defaults if ( Nmin . eq . DEFAULT_INT ) call die ( \"Must specify NMIN in CONTROL_NAMELIST\" ) if ( Nmax . eq . DEFAULT_INT ) call die ( \"Must specify NMAX in CONTROL_NAMELIST\" ) if ( rotor_kind . eq . DEFAULT_CHAR1 ) call die ( \"Must specify ROTOR_KIND in CONTROL_NAMELIST\" ) if ( target_charge . eq . DEFAULT_INT ) call die ( \"Must specify TARGET_CHARGE in CONTROL_NAMELIST\" ) if ( ZAXIS . eq . DEFAULT_CHAR1 ) call die ( \"Must specify ZAXIS in CONTROL_NAMELIST\" ) if ( any ( ABC . eq . 0.0_dp )) call die ( \"Must specify nonzero rotational constants ABC in CONTROL_NAMELIST\" ) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!! KMAT_NAMELIST !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( use_kmat . eqv . . true .) then ! -- prepare for reading rewind ( stdin ) allocate ( character ( 1000 ) :: kmat_dir ) allocate ( character ( 1000 ) :: channels_dir ) allocate ( num_egrid ( 100 )) allocate ( egrid_segs ( 101 )) allocate ( character ( 10 ) :: point_group ) allocate ( spinmults ( 10 )) spinmults = DEFAULT_INT kmat_dir ( 1 : 1 ) = DEFAULT_CHAR1 channels_dir ( 1 : 1 ) = DEFAULT_CHAR1 kmat_output_type ( 1 : 1 ) = DEFAULT_CHAR1 ! -- read read ( stdin , kmat_namelist ) ! -- trim arrays num_egrid = num_egrid ( 1 : num_egrid_segs ) egrid_segs = egrid_segs ( 1 : num_egrid_segs + 1 ) / au2ev ! -- normalize characters call to_lower ( egrid_spacing ) call to_lower ( kmat_output_type ) select case ( kmat_output_type ) case ( UKRMOLX , MQDTR2K ) continue case default call die ( \"KMAT_OUTPUT_TYPE in KMAT_NAMELIST must be one of \" // UKRMOLX // \" or \" // MQDTR2K ) end select select case ( egrid_spacing ) case ( \"lin\" , \"log\" ) ; continue case default ; call die ( \"EGRID_SPACING (\" // egrid_spacing // \") must be LIN or LOG in KMAT_NAMELIST\" ) end select ! -- check defaults if ( kmat_dir ( 1 : 1 ) . eq . DEFAULT_CHAR1 ) call die ( \"Must specify KMAT_DIR in KMAT_NAMELIST\" ) if ( lmax_kmat . eq . DEFAULT_INT . OR . lmax_kmat . lt . 0 ) & call die ( \"LMAX_KMAT in KMAT_NAMELIST must be defined and be non-negative\" ) call remove_value ( spinmults , DEFAULT_INT ) if ( any ( spinmults . lt . 1 )) call die ( \"SPINMULTS in KMAT_NAMELIST cannot have values that are < 1\" ) if ( channels_dir ( 1 : 1 ) . eq . DEFAULT_CHAR1 & . AND . kmat_output_type . eq . UKRMOLX ) call die ( \"Must specify CHANNELS_DIR in KMAT_NAMELIST with& & KMAT_OUPUT_TYPE = \" // UKRMOLX ) endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!! COULOMB_NAMELIST !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( use_CB . eqv . . true .) then allocate ( character ( 1000 ) :: cdms_file ) ! -- prepare for reading cdms_file ( 1 : 1 ) = DEFAULT_CHAR1 rewind ( stdin ) ! -- read read ( stdin , coulomb_namelist ) ! -- check values if ( use_CDMS_einstA ) then if ( CDMS_file ( 1 : 1 ) . eq . DEFAULT_CHAR1 ) call die ( \"Must define CDMS_FILE in COULOMB_NAMELIST& & when USE_CDMS_EINSTA is .TRUE.\" ) endif if ( do_dipole . eqv . . false .) call die ( \"DO_DIPOLE in COULOMB_NAMELIST should not be set to .FALSE.; nothing would be done\" ) if ( do_quadrupole ) call die ( \"DO_QUADRUPOLE in COULOMB_NAMELIST should not be set to true; it is not implemented\" ) if ( Ei . eq . 0.0_dp ) call die ( \"EI in COULOMB_NAMELIST must be defined and be positive\" ) if ( Ef . eq . 0.0_dp ) call die ( \"EF in COULOMB_NAMELIST must be defined and be positive\" ) if ( Ef . le . Ei ) call die ( \"EF ≤ EI in COULOMB_NAMELIST is not allowed\" ) if ( nE . eq . DEFAULT_INT . OR . ne . le . 0 ) call die ( \"NE in COULOMB_NAMELIST must be defined and positive\" ) if ( lmax_partial . eq . DEFAULT_INT ) call die ( \"LMAX_PARTIAL in COULOMB_NAMELIST must be defined and nonnegative\" ) if ( lmax_total . eq . DEFAULT_INT . AND . ( analytic_total_cb ( 1 ) . eqv . . false .)) & call die ( \"LMAX_TOTAL in COULOMB_NAMELIST must be defined and nonnegative if ANALYTIC_TOTAL_CB(1) is .false.\" ) if ( do_xtrap ) then if ( ne_xtrap . eq . DEFAULT_INT . OR . ne_xtrap . le . 0 ) then call die ( \"NE_XTRAP in COULOMB_NAMELIST must be defined and positive if DO_XTRAP is .TRUE.\" ) endif if ( Ei_xtrap . eq . 0.0_dp . OR . Ei_xtrap . gt . Ei ) then call die ( \"EI_XTRAP in COULOMB_NAMELIST must be defined, nonzero, and less than EI if DO_XTRAP is .TRUE.\" ) endif endif endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call to_lower ( zaxis ) ! -- convert to atomic units Ei = Ei / au2ev Ef = Ef / au2ev Ei_xtrap = Ei_xtrap / au2ev ABC (:) = ABC (:) / au2invcm xs_zero_threshold = xs_zero_threshold / ( au2cm * au2cm ) ! -- convert to lower case call to_lower ( rotor_kind ) call to_lower ( point_group ) call to_lower ( kmat_energy_units_override ) call to_lower ( channel_energy_units_override ) ! -- remove spaces point_group = trim ( point_group ) kmat_dir = trim ( kmat_dir ) channels_dir = trim ( channels_dir ) output_directory = trim ( output_directory ) ! -- add trailing directory separator to directories if needed, make directories as needed call add_trailing ( output_directory , ds ) call add_trailing ( kmat_dir , ds ) call add_trailing ( channels_dir , ds ) write ( stdout , '(A)' ) \"--------------------------------------------------------------------------------------------------------\" write ( stdout , * ) write ( stdout , control_namelist ) write ( stdout , * ) if ( use_kmat . eqv . . true .) then write ( stdout , kmat_namelist ) write ( stdout , * ) endif if ( use_CB . eqv . . true .) then write ( stdout , coulomb_namelist ) write ( stdout , * ) endif write ( stdout , '(A)' ) \"--------------------------------------------------------------------------------------------------------\" write ( stdout , * ) ! -- checks if ( Nmin . gt . Nmax ) call die ( \"Nmin > Nmax not allowed\" ) if ( target_charge . eq . DEFAULT_INT ) call die ( \"Must set the charge of the target in namelist CONTROL !\" ) if ( target_charge . eq . 0 ) call die ( \"Neutral targets not programmed yet !\" ) ! -- namelist: control cfg % nmin = nmin cfg % nmax = nmax cfg % use_kmat = use_kmat cfg % use_cb = use_cb cfg % spin_isomer_kind = spin_isomer_kind cfg % output_directory = output_directory cfg % rotor_kind = rotor_kind cfg % zaxis = zaxis cfg % abc = abc (:) cfg % target_charge = target_charge cfg % add_cd4 = add_cd4 cfg % add_cd6 = add_cd6 cfg % xs_zero_threshold = xs_zero_threshold if ( add_cd4 . eqv . . true .) then if ( any ([ dn , dnk , dk , deltan , deltak ] . eq . 0.0_dp )) & call die ( \"Please specify all 4th-order centrifugal distortion parameters !\" ) dn = dn / au2invcm dnk = dnk / au2invcm dk = dk / au2invcm deltan = deltan / au2invcm deltak = deltak / au2invcm cfg % cd4 = cd4_type ( dn = dn , dnk = dnk , dk = dk , deltan = deltan , deltak = deltak ) endif if ( add_cd6 . eqv . . true .) then if ( add_cd4 . eqv . . false .) call die ( \"Don't add the sextic correction while omitting the quartic correction !\" ) if ( any ([ hn , hnk , hkn , hk , etan , etank , etak ] . eq . 0.0_dp )) & call die ( \"Please specify all 6th-order centrifugal distortion parameters !\" ) hn = hn / au2invcm hnk = hnk / au2invcm hkn = hkn / au2invcm hk = hk / au2invcm etan = etan / au2invcm etank = etank / au2invcm etak = etak / au2invcm cfg % cd6 = cd6_type ( hn = hn , hnk = hnk , hkn = hkn , hk = hk , etan = etan , etank = etank , etak = etak ) endif ! -- namelist: kmat if ( use_kmat . eqv . . true .) then if ( kmat_output_type . eq . \"=======\" ) then call die ( \"Must speficy KMAT_OUTPUT_TYPE. It should be one of \" // UKRMOLX // \" or \" // MQDTR2K ) elseif ( all ( kmat_output_type . ne . [ UKRMOLX , MQDTR2K ])) then call die ( \"Poorly specified KMAT_OUTPUT_TYPE. It should be one of \" // UKRMOLX // \" or \" // MQDTR2K ) endif cfg % kmat_dir = kmat_dir cfg % channels_dir = channels_dir cfg % lmax_kmat = lmax_kmat cfg % point_group = point_group cfg % spinmults = spinmults (:) cfg % num_egrid_segs = num_egrid_segs cfg % num_egrid = num_egrid (:) cfg % egrid_segs = egrid_segs (:) cfg % egrid_spacing = egrid_spacing cfg % real_spherical_harmonics = real_spherical_harmonics cfg % kmat_energy_closest = kmat_energy_closest / au2ev cfg % kmat_output_type = kmat_output_type cfg % kmat_energy_units_override = kmat_energy_units_override cfg % channel_energy_units_override = channel_energy_units_override endif ! -- namelist: coulomb if ( use_CB . eqv . . true .) then if ( do_quadrupole ) call die ( \"DO_QUADRUPOLE exists as an option, but I'm yet confident in its& & implementation. Remove this call if you want and see what happens.\" ) #ifndef USE_CDMSREADER if ( use_cdms_einsta . eqv . . true .) call die ( \"User requested use of CDMS data, but the code is& & not compiled with that capability. Build with 'USE_CDMSREADER=1' to change this.\" ) #endif cfg % use_cdms_einsta = use_cdms_einsta cfg % analytic_total_cb = analytic_total_cb (:) cfg % ei = ei cfg % ef = ef cfg % ne = ne cfg % ne_xtrap = ne_xtrap cfg % ei_xtrap = ei_xtrap cfg % do_xtrap = do_xtrap cfg % do_dipole = do_dipole cfg % do_quadrupole = do_quadrupole cfg % lmax_partial = lmax_partial cfg % lmax_total = lmax_total cfg % cartesian_dipole_moments = cartesian_dipole_moments (:) / au2deb ! cfg%cartesian_quadrupole_moments = cartesian_quadrupole_moments(:) !/ au2deb cfg % cdms_file = cdms_file cfg % only_einsta = only_einsta endif end subroutine read_namelists ! ================================================================================================================================ ! end module rotex__reading ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__reading.f.html"},{"title":"rotex__symmetry.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__symmetry !! All things related to symmetry implicit none private public :: irrep_name public :: get_group_irreps public :: group_size public :: spin_symmetry public :: possible_spin_symmetries public :: is_spin_allowed public :: is_spin_forbidden interface is_spin_allowed module procedure :: is_spin_allowed_chan module procedure :: is_spin_allowed_qnums end interface is_spin_allowed interface is_spin_forbidden module procedure :: is_spin_forbidden_chan module procedure :: is_spin_forbidden_qnums end interface is_spin_forbidden integer , allocatable , public , save :: m_parity (:) !! Array containing the parity (1/even or -1/odd) of an electronic channel !! based on its label m. This array is indexed by m directly. This is only !! for calculation in the Cs point group character ( 33 ), parameter :: abelian_point_groups = \"C1, Cs, C2, Ci, C2v, C2h, D2, D2h\" ! ---------------------------------------- ! ! The integer labels of the various irreps ! ! ---------------------------------------- ! ! -- Cs integer , parameter , public :: Ap = 1 integer , parameter , public :: App = 2 ! -- Ci, C2h integer , parameter , public :: Ag = 1 integer , parameter , public :: Au = 2 integer , parameter , public :: Bg = 3 integer , parameter , public :: Bu = 4 ! -- C1, C2, C2v, D2, D2h integer , parameter , public :: A = 1 integer , parameter , public :: A1 = 1 integer , parameter , public :: A2 = 4 integer , parameter , public :: B = 2 integer , parameter , public :: B1 = 2 integer , parameter , public :: B2 = 3 integer , parameter , public :: B3 = 4 integer , parameter , public :: B1g = 3 integer , parameter , public :: B1u = 4 integer , parameter , public :: B2g = 5 integer , parameter , public :: B2u = 6 integer , parameter , public :: B3g = 7 integer , parameter , public :: B3u = 8 integer , parameter , public :: even = 1 integer , parameter , public :: odd =- 1 ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function group_size ( point_group ) result ( n ) !! Return the number of elements in point_group use rotex__system , only : die use rotex__characters , only : to_upper implicit none character ( * ), intent ( in ) :: point_group integer :: n character (:), allocatable :: pg pg = trim ( point_group ) call to_upper ( pg ) select case ( pg ) case ( \"C1\" ) n = 1 case ( \"CS\" , \"C2\" , \"CI\" ) n = 2 case ( \"C2V\" , \"C2H\" , \"D2\" ) n = 4 case ( \"D2H\" ) n = 8 case default call die ( \"Bad point group (\" // pg // \") supplied. Please choose one of \" // abelian_point_groups ) end select end function group_size ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine get_group_irreps ( point_group , irreps ) !! Given the point group, output an array containing the names of the irreps in the supplied point_group. !! Only Abelian point groups are considered. Irreps in the code will be referred to by their indicies use rotex__system , only : die use rotex__characters , only : to_upper implicit none character ( * ), intent ( in ) :: point_group character (:), intent ( out ), allocatable :: irreps (:) integer :: nirreps character (:), allocatable :: pg pg = trim ( point_group ) call to_upper ( pg ) nirreps = group_size ( pg ) select case ( pg ) case ( \"C1\" ) allocate ( character ( 1 ) :: irreps ( nirreps )) irreps ( A ) = \"A\" case ( \"CS\" ) allocate ( character ( 3 ) :: irreps ( nirreps )) irreps ( Ap ) = \"Ap\" irreps ( App ) = \"App\" case ( \"C2\" ) allocate ( character ( 1 ) :: irreps ( nirreps )) irreps ( A ) = \"A\" irreps ( B ) = \"B\" case ( \"CI\" ) allocate ( character ( 2 ) :: irreps ( nirreps )) irreps ( Ag ) = \"Ag\" irreps ( Au ) = \"Au\" case ( \"C2V\" ) allocate ( character ( 2 ) :: irreps ( nirreps )) irreps ( A1 ) = \"A1\" irreps ( B1 ) = \"B1\" irreps ( B2 ) = \"B2\" irreps ( A2 ) = \"A2\" case ( \"C2H\" ) allocate ( character ( 2 ) :: irreps ( nirreps )) irreps ( A ) = \"Ag\" irreps ( B1 ) = \"Au\" irreps ( B2 ) = \"Bg\" irreps ( B3 ) = \"Bu\" case ( \"D2\" ) allocate ( character ( 2 ) :: irreps ( nirreps )) irreps ( A ) = \"A\" irreps ( B1 ) = \"B1\" irreps ( B2 ) = \"B2\" irreps ( B3 ) = \"B3\" case ( \"D2H\" ) allocate ( character ( 3 ) :: irreps ( nirreps )) irreps ( Ag ) = \"Ag\" irreps ( Au ) = \"Au\" irreps ( B1g ) = \"B1g\" irreps ( B1u ) = \"B1u\" irreps ( B2g ) = \"B2g\" irreps ( B2u ) = \"B2u\" irreps ( B3g ) = \"B3g\" irreps ( B3u ) = \"B3u\" case default call die ( \"Unacceptable point group '\" // point_group // \"' given. Please choose one of \" // abelian_point_groups // \".\" ) end select end subroutine get_group_irreps ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function irrep_name ( irrep , point_group ) result ( output ) !! Given an irrep index in point_group, return the name of the corresponding irrep use rotex__system , only : die use rotex__characters , only : to_upper implicit none integer , intent ( in ) :: irrep character ( * ), intent ( in ) :: point_group character (:), allocatable :: output character (:), allocatable :: pg character (:), allocatable :: irreps (:) pg = trim ( point_group ) call to_upper ( pg ) call get_group_irreps ( pg , irreps ) ! irreps = group_irreps(pg) output = trim ( irreps ( irrep )) end function irrep_name ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module function possible_spin_symmetries ( kind ) result ( res ) !! Returns an array of possible spin symmetry values use rotex__system , only : die implicit none integer , intent ( in ) :: kind integer , allocatable :: res (:) select case ( kind ) case ( 0 ) ; res = [ 0 ] ! case(1,2) ; res = [0,1] case ( 2 ) ; res = [ 0 , 1 ] ! case(3)   ; res = [0,1] case default ! call die(\"Symmetry kind not supported. Must be one of 0,1,2,3\") call die ( \"Symmetry kind not supported. Must be one of 0,2\" ) end select end function possible_spin_symmetries ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function spin_symmetry ( n , ka , kc , kind , symaxis ) result ( res ) !! Returns the spin symmetry of the current N, Ka, Kc state use rotex__system , only : die implicit none integer , intent ( in ) :: n , ka , kc , kind character ( 1 ), intent ( in ) :: symaxis integer :: ksym integer :: res select case ( kind ) case ( 0 ) ! -- no restriction res = 0 case ( 1 ) ! -- linear: N-parity res = iand ( n , 1 ) case ( 2 ) ! -- Ka+Kc parity !    Ortho: Ka+Kc odd !    Para:  Ka+Kc even res = iand ( Ka + Kc , 1 ) case ( 3 ) ! -- must preserve Ks partity (mod 3) (s=a,c) !    Ortho: Ks (mod 3) = 0 !    Para:  Ks (mod 3) ≠ 0 select case ( symaxis ) case ( \"a\" , \"A\" ) ksym = abs ( ka ) call die ( \"Symaxis is B for symmetry rule 3. Are you sure ?\" ) case ( \"b\" , \"B\" ) call die ( \"Symaxis is B for symmetry rule 3. Are you sure ?\" ) case ( \"c\" , \"C\" ) ksym = abs ( kc ) case default call die ( \"Undetermined SYMAXIS: \" // symaxis ) end select res = merge ( 0 , 1 , mod ( ksym , 3 ) . eq . 0 ) case default ! call die(\"Illegal symmetry rule. Must be 0,1,2,3.\") call die ( \"Illegal symmetry rule. Must be 0,2.\" ) end select end function spin_symmetry ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function is_spin_allowed_qnums ( nlo , kalo , kclo , nup , kaup , kcup , kind , symaxis ) result ( res ) !! Determine if the transition Nlo,Kalo,Kclo -> Nup,Kaup,Kcup is allowed by nuclear spin symmetry !! selection rules implicit none integer , intent ( in ) :: nlo , kalo , kclo , nup , kaup , kcup , kind character ( 1 ), intent ( in ) :: symaxis logical :: res res = spin_symmetry ( nlo , kalo , kclo , kind , symaxis ) . eq . spin_symmetry ( nup , kaup , kcup , kind , symaxis ) end function is_spin_allowed_qnums ! ------------------------------------------------------------------------------------------------------------------------------- ! pure elemental module function is_spin_allowed_chan ( channel1 , channel2 , spin_isomer_kind , symaxis ) result ( res ) !! Test if two rotational channels respect ortho/para symmetry use rotex__types , only : asymtop_rot_channel_type implicit none type ( asymtop_rot_channel_type ), intent ( in ) :: channel1 , channel2 integer , intent ( in ) :: spin_isomer_kind character ( 1 ), intent ( in ) :: symaxis logical :: res integer :: n1 , ka1 , kc1 integer :: n2 , ka2 , kc2 n1 = channel1 % n ; ka1 = channel1 % ka ; kc1 = channel1 % kc n2 = channel2 % n ; ka2 = channel2 % ka ; kc2 = channel2 % kc res = is_spin_allowed_qnums ( n1 , ka1 , kc1 , n2 , ka2 , kc2 , spin_isomer_kind , symaxis ) end function is_spin_allowed_chan ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function is_spin_forbidden_qnums ( nlo , kalo , kclo , nup , kaup , kcup , kind , symaxis ) result ( res ) !! Determine if the transition Nlo,Kalo,Kclo -> Nup,Kaup,Kcup is forbidden by nuclear spin symmetry !! selection rules implicit none integer , intent ( in ) :: nlo , kalo , kclo , nup , kaup , kcup , kind character ( 1 ), intent ( in ) :: symaxis logical :: res res = . not . is_spin_allowed_qnums ( nlo , kalo , kclo , nup , kaup , kcup , kind , symaxis ) end function is_spin_forbidden_qnums ! ------------------------------------------------------------------------------------------------------------------------------- ! pure elemental module function is_spin_forbidden_chan ( channel1 , channel2 , spin_isomer_kind , symaxis ) result ( res ) !! Test if two rotational channels respect ortho/para symmetry use rotex__types , only : asymtop_rot_channel_type implicit none type ( asymtop_rot_channel_type ), intent ( in ) :: channel1 , channel2 integer , intent ( in ) :: spin_isomer_kind character ( 1 ), intent ( in ) :: symaxis logical :: res integer :: n1 , ka1 , kc1 integer :: n2 , ka2 , kc2 n1 = channel1 % n ; ka1 = channel1 % ka ; kc1 = channel1 % kc n2 = channel2 % n ; ka2 = channel2 % ka ; kc2 = channel2 % kc res = . not . is_spin_allowed_qnums ( n1 , ka1 , kc1 , n2 , ka2 , kc2 , spin_isomer_kind , symaxis ) end function is_spin_forbidden_chan ! ================================================================================================================================ ! end module rotex__symmetry ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__symmetry.f.html"},{"title":"rotex__progress.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__progress !! Interface to [forbear](https://github.com/szaghi/forbear), the Fortran (progress) B(e)ar environment #ifdef USE_FORBEAR use forbear , only : progressbar_type => bar_object #endif implicit none public ! ================================================================================================================================ ! end module rotex__progress ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__progress.f.html"},{"title":"rotex__types.f – ROTEX","text":"Source Code ! ================================================================================================================================ ! module rotex__types !! Contains type definitions and procedures for those types used throughout the program use rotex__kinds , only : dp , xdp , qp use rotex__constants , only : IQ_DEFAULT implicit none private ! -- kinds public :: dp , xdp , qp ! -- types public :: eigenH_type public :: N_states_type public :: channel_type public :: elec_channel_type public :: asymtop_rot_channel_type public :: asymtop_rot_channel_l_type public :: asymtop_rot_channel_l_vector_type public :: ivector_type public :: rvector_type public :: rmatrix_type public :: cmatrix_type public :: asymtop_rot_transition_type public :: config_type public :: cd4_type public :: cd6_type ! -- procedures public :: sort_channels public :: permsort_channels public :: sort_channels_by_energy public :: operator (. eq .) public :: operator (. ne .) public :: operator (. isin .) public :: assignment ( = ) public :: trim_channel_l public :: get_channel_index public :: findloc_transitions ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ ! -- ↓↓↓↓↓↓↓↓ type definitions ↓↓↓↓↓↓↓↓ ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ type eigenH_type !! Contains the eigenvectors and eigenvalues of a hamiltonian real ( dp ), allocatable :: eigvals (:) real ( dp ), allocatable :: eigvecs (:,:) end type eigenH_type type N_states_type !! The rotational state of the system described by its eigenvectors, eigenvalues, !! and state labels integer :: N type ( eigenH_type ) :: eigenH !! The decomposed Hamiltonian for this rotational level integer , allocatable :: Ka (:) !! The projections Ka integer , allocatable :: Kc (:) !! The projections Kc real ( dp ), allocatable :: EinstA (:) !! The Einstein coefficients for transitions to all lower states (0 if none) end type N_states_type type , abstract :: channel_type !! |nelec> (E) integer :: nelec !! Electronic state real ( dp ) :: E !! The channel energy end type channel_type type , extends ( channel_type ) :: elec_channel_type !! Describes the electronic channel basis of the (optional) K and S-matrices by adding l and its projection ml !! |nelec,l,ml> (iq, E) integer :: l !! Partial wave degree integer :: ml !! Partial wave order (projection on body-frame ẑ-axis) integer :: iq = IQ_DEFAULT !! The kind of normalization for the Coulomb f/g functions: !!   4: usual normalization !!   0: f₀/g₀ normalization end type elec_channel_type type , extends ( channel_type ) :: asymtop_rot_channel_type !! Describes the rotational and electronic channel basis of the (optional) S-matrix !! after the rotational frame transformation by adding the and rotational quantum numbers to the channel type !! |nelec,N,Ka,Kc> (E) integer :: N !! The rotatinal quantum number of the target integer :: Ka !! The projection Ka of N integer :: Kc !! The projection Kc of N integer :: sym !! The nuclear spin symmetry end type asymtop_rot_channel_type type , extends ( asymtop_rot_channel_type ) :: asymtop_rot_channel_l_type !! Describes the rotational and electronic channel basis of the (optional) S-matrix !! after the rotational frame transformation by adding the partial wave degree !! to the rotational quantum numbers !! |nelec,l,N,Ka,Kc> (iq, E) integer :: l !! Partial wave degree integer :: iq !! The kind of normalization for the Coulomb f/g functions: !!   4: usual normalization !!   0: f₀/g₀ normalization end type asymtop_rot_channel_l_type type asymtop_rot_channel_l_vector_type !! Contains a vector of channels. The idea is that this type is indexed at !! each value of the angular momentum quantum number J, for which a different !! combination of channels exists than for other Js type ( asymtop_rot_channel_l_type ), allocatable :: channels (:) end type asymtop_rot_channel_l_vector_type type asymtop_rot_transition_type !! The a type containing the indices for a pair of initial and final rotational states type ( asymtop_rot_channel_type ) :: lo type ( asymtop_rot_channel_type ) :: up end type asymtop_rot_transition_type type ivector_type !! The type of an integer vector integer , allocatable :: vec (:) end type ivector_type type rvector_type !! The type of a real vector real ( dp ), allocatable :: vec (:) end type rvector_type type rmatrix_type !! The type of a real matrix real ( dp ), allocatable :: mtrx (:,:) end type rmatrix_type type cmatrix_type !! The type of a complex matrix complex ( dp ), allocatable :: mtrx (:,:) end type cmatrix_type type cd4_type !! Centrifugal Distortion parameters for quartric (4) order real ( dp ) :: dn !! ΔN  (AKA ΔJ) real ( dp ) :: dnk !! ΔNK (AKA ΔJK) real ( dp ) :: dk !! ΔK real ( dp ) :: deltan !! δn  (AKA δJ) real ( dp ) :: deltak !! δK end type cd4_type type cd6_type !! Centrifugal Distortion parameters for sextic (6) order real ( dp ) :: hn !! HN   (N²)³ real ( dp ) :: hnk !! HNK [(N²)² Nz²] real ( dp ) :: hkn !! HKN [ N²   Nz⁴] real ( dp ) :: hk !! HK         Nz⁶ real ( dp ) :: etan !! ηN  [N⁴,    (J₊)²+(J₋)²]₊ / 2 real ( dp ) :: etank !! ηNK [N²Nz², (J₊)²+(J₋)²]₊ / 2 real ( dp ) :: etak !! ηK  [Nz⁴,   (J₊)²+(J₋)²]₊ / 2 end type cd6_type ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓ namelist variables declarations ↓↓↓↓↓↓↓↓↓↓↓↓↓ ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ type config_type !! Derived type containing data from the namelist variables logical :: add_cd4 = . true . !! Add centrifugal distortion for fourth order ? logical :: add_cd6 = . true . !! Add centrifugal distortion for sixth order ? logical :: only_einsta !! Whether to only calculate the Einstein A coefficients in the Coulomb-Born !! cross section routine logical :: use_CDMS_einstA !! Whether to use Einstein A coefficients obtained from the CDMS or calculate them ourselves !! Path for the file containing the CDMS data to be read (if use_CDMS_einstA is .true.) logical :: analytic_total_cb ( 2 ) !! Array of logicals that has the size 2. Choose whether to use the analytic equation !! describing the multipole expansions for the dipole (element 1) and the quadrupole (element 2, not yet available) logical :: do_xtrap !! Do the extrapolation of (de-)excitation cross sections as 1/E to the excitation threshold ? logical :: do_dipole !! Choose whether to use the dipole term of the potential expansion logical :: do_quadrupole !! Choose whether to use the quadrupole term of the potential expansion logical :: use_kmat !! Calculate (de-)excitation cross sections using precomputed K-matrices ? logical :: use_cb !! Calculate (de-)excitation cross sections using the Coulomb-Born approxiation ? logical :: real_spherical_harmonics !! Whether the input K-matrices are evaluated in a basis of real spherical harmonics !! for the scattering electron. If .true., it will be transformed to a basis of !! complex-valued spherical harmonics integer :: spin_isomer_kind !! Whether and how to enforce ortho/para symmetry for molecules with identical nuclei. !!   0: don't !!   2: C2v rotor (H₂X-like): preserve Ka+Kc parity !! Note that this just disables certain transitions from bein calculated !! in the CB approx as well as from the S-matrix. This does not affect !! the RFT because higher J-blocks of the S-matrix are more affected !! by K-mixing (Ka and Kc are not exact quantum numbers) integer :: nE !! The number of scattering energies to consider. This does not need to be very high; the CB !! cross sections are very smooth and can easily be interpolated. integer :: nE_xtrap !! Number of extrapolation energies. Excitation cross sections are extrapolated as 1/E to the excitation threshold, !! de-excitation cross sections are extrapolated as 1/E to Ei_xtrap. If this is 0, no exptrapolation will be performed. integer :: lmax_partial !! The maximum value of l to consider in the contribution of the partial CB cross section !! from the dipole and the quadrupole. If you're replacing the low-l CB cross sections !! with other cross sections, set this to the max l that you have available. integer :: lmax_total !! The maximum value of l to consider in the contribution of the total CB cross section !! in the even that you're not using the analytic expression, !! from the dipole  and the quadrupole integer :: Nmin !! The minimum value of the rotational quantum number (N) to consider integer :: Nmax !! The maximum value of the rotational quantum number (N) to consider integer :: target_charge !! The electric charge of the target integer :: lmax_kmat !! The max partial wave to be included in the K-matrix basis. Cannot exceed the available !! basis in the calculation, but can be smaller than the largest available partial wave integer :: num_egrid_segs !! Number of energy grid segments (evaluation energy for the cross sections) integer , allocatable :: num_egrid (:) !! Array of number of energies per grid segment (length num_egrid_segs) integer , allocatable :: spinmults (:) !! Array of spin multiplicities (2S+1) for which the system's (target + e⁻) K-matrices were calculated real ( dp ) :: xs_zero_threshold !! Any cross section with value only smaller than this (cm²) will !! be ignore and will not be printed real ( dp ) :: Ei !! The first electron energy for excitation to consider relative to the initial state's energy real ( dp ) :: Ef !! The last  electron energy for excitation to consider relative to the initial state's energy real ( dp ) :: Ei_xtrap !! The lowest electron energy for de-excitation relative to the initial state's energy. !! The results will be extrapolated from Ei down to this assuming a 1/E dependence for the !! cross section, i.e., constant excitation probablility. If this .le. 0, no extrapolation will not be performed. !! Units: (eV) real ( dp ) :: kmat_energy_closest !! Input K-matrices are evaluated at a specific energy. If this code is run energy-independently !! (most likely the case unless I add energy dependence in the future) The K-matrix that is !! selected will be the FIRST ONE whose evaluation energy is CLOSEST to this energy in (eV). !! NOTE: UKRMOL+ outputs K-matrix energies in the .kmat files in Rydberg. real ( dp ) :: abc ( 3 ) !! Array of reals of length 3 !! The rotational constants A, B, and C of the target molecule (cm⁻¹). real ( dp ) :: cartesian_dipole_moments ( 3 ) !! Array of cartesian dipole moments (Debye) !! in the order dx, dy, dz real ( dp ) :: cartesian_quadrupole_moments ( 6 ) !! Array of cartesian quadrupole moments (Debye) !! in the order Qxx, Qxy, Qxz, Qyy, Qyz, Qzz real ( dp ), allocatable :: egrid_segs (:) !! Array of the bounds (non-degenerate) of the energy grid segments (length num_egrid_segs + 1) character ( 1 ) :: rotor_kind !! The kind of rotor that describes the targer. Character(1). !! Choice of : !!  \"l\"inear !!  \"a\"symmetric top !!  \"s\"ymmetric  top character ( 1 ) :: zaxis !! The molecular axis (a, b, or c) along which the z-axis is oriented !! **This should also be the symmetry axis** character ( 1 ) :: channel_energy_units_override !! The units of the channel energies in the file that holds channels. Options are : !!  - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV !! By default, this is not set and will allow the code to determine !! channel energies on its own based on KMAT_OUTPUT_TYPE, but can !! be forcibly overridden with this character ( 1 ) :: kmat_energy_units_override !! The units of the K-matrix evaluation energies in the kmat file. Options are : !!  - \"r\" for Rydberg, \"h\" for hartree, \"e\" for eV !! By default, this is not set and will allow the code to determine !! channel energies on its own based on KMAT_OUTPUT_TYPE, but can !! be forcibly overridden with this character ( 3 ) :: egrid_spacing !! The kind of spacing for the energy grid segments. \"lin\" for linear and \"log\" for logarithmic character (:), allocatable :: point_group !! The point group in which the K-matrices were calculated character (:), allocatable :: kmat_dir !! Path for the file containing the K-matrix to be read. Absolute or relative character (:), allocatable :: channels_dir !! Path for the file containing the channels for the K-matrix to be read. Absolute or relative !! This is only used if kmat_output_type is ukrmol+ because the channel and K-matrix files are separate character (:), allocatable :: output_directory !! The directory in which to write the output data !! This directory must already exist character (:), allocatable :: CDMS_file !! The file containing CDMS transitions character ( 7 ) :: kmat_output_type !! Determines what kind of K-matrices we're reading. Two possible values: !!   'UKRMOL+': default UKRmol+ .kmat file !!   'MQDTR2K': a specific format given in the writeup. K-matrices are generated !!     directly from the R-matrix, possibly with channel elimination and differently !!     normalized Coulomb wavefunctions type ( cd4_type ) :: cd4 !! Centrifugal distortion parameters (4th order) for the rigid rotor Hamiltonian correction type ( cd6_type ) :: cd6 !! Centrifugal distortion parameters (6th order) for the rigid rotor Hamiltonian correction end type config_type ! -- ↑↑↑↑↑↑↑↑↑↑↑↑↑ namelist variable declarations ↑↑↑↑↑↑↑↑↑↑↑↑↑ ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ interfaces ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ ! -- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ interface sort_channels module procedure :: sort_elec_channels end interface sort_channels interface permsort_channels module procedure :: permsort_elec_channels end interface permsort_channels interface operator (. eq .) module procedure :: channel_iseq module procedure :: transition_iseq end interface operator (. eq .) interface operator (. ne .) module procedure :: channel_isne end interface operator (. ne .) interface operator (. isin .) module procedure channel_isin module procedure transition_isin end interface operator (. isin .) interface assignment ( = ) module procedure :: channel_set_eq end interface assignment ( = ) ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module function get_channel_index ( channels , channel , reverse ) result ( i ) !! Return the first index i where channel .eq. channels(i) is .true., or !! the last index is reverse is .true. use rotex__system , only : die implicit none class ( channel_type ), intent ( in ) :: channel , channels (:) logical , intent ( in ), optional :: reverse integer :: i , istart , iend , istep logical :: reverse_local reverse_local = . false . ; if ( present ( reverse )) reverse_local = reverse if ( reverse_local . eqv . . true .) then istart = lbound ( channels , 1 ) iend = ubound ( channels , 1 ) istep = 1 else istart = ubound ( channels , 1 ) iend = lbound ( channels , 1 ) istep = - 1 endif do i = istart , iend , istep if ( channel . ne . channels ( i )) cycle return enddo call die ( \"Failed finding a channel in the channel array\" ) end function get_channel_index ! ------------------------------------------------------------------------------------------------------------------------------- ! impure elemental module subroutine channel_set_eq ( channel_out , channel_in ) !! Sets the channel left equal to the channel right use rotex__system , only : die implicit none class ( channel_type ), intent ( out ) :: channel_out class ( channel_type ), intent ( in ) :: channel_in ! -- start at base class channel_out % nelec = channel_in % nelec channel_out % E = channel_in % E select type ( left => channel_out ) ! -- return if this is just a base channel class default return ! -- electronic channels type is ( elec_channel_type ) select type ( right => channel_in ) type is ( elec_channel_type ) left % l = right % l left % ml = right % ml left % iq = right % iq class default call die ( \"Trying to assign a non-electronic channel to an electronic channel.\" ) end select ! -- rotational channels + l type is ( asymtop_rot_channel_l_type ) select type ( right => channel_in ) type is ( asymtop_rot_channel_l_type ) left % N = right % N left % Ka = right % Ka left % Kc = right % Kc left % l = right % l left % iq = right % iq left % sym = right % sym class default call die ( \"Trying to assign rotation+l channel to a different kind of channel.\" ) end select ! -- rotational channels (no l) type is ( asymtop_rot_channel_type ) select type ( right => channel_in ) type is ( asymtop_rot_channel_type ) left % N = right % N left % Ka = right % Ka left % Kc = right % Kc left % sym = right % sym class default call die ( \"Trying to assign rotational channel (no l) to a different kind of channel.\" ) end select end select end subroutine channel_set_eq ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module function channel_isin ( channel , channels ) result ( res ) !! Check if a channel is in the array channels implicit none class ( channel_type ), intent ( in ) :: channel , channels (:) logical :: res res = . true . if ( any ( channel . eq . channels )) return res = . false . end function channel_isin ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module function transition_isin ( transition , transitions ) result ( res ) !! Check if a transition is in the array transitions implicit none type ( asymtop_rot_transition_type ), intent ( in ) :: transition , transitions (:) logical :: res res = . true . if ( any ( transition . eq . transitions )) return res = . false . end function transition_isin ! ------------------------------------------------------------------------------------------------------------------------------- ! impure elemental module function trim_channel_l ( channel_with_l ) result ( channel_without_l ) !! Given a rotational channel with the l quantum number, return the equvalent channel without the l quantum number implicit none type ( asymtop_rot_channel_l_type ), intent ( in ) :: channel_with_l type ( asymtop_rot_channel_type ) :: channel_without_l integer :: nelec , N , Ka , Kc , sym real ( dp ) :: E nelec = channel_with_l % nelec N = channel_with_l % N Ka = channel_with_l % Ka Kc = channel_with_l % Kc sym = channel_with_l % sym E = channel_with_l % E channel_without_l = asymtop_rot_channel_type ( nelec = nelec , N = N , Ka = Ka , Kc = Kc , E = E , sym = sym ) end function trim_channel_l ! ------------------------------------------------------------------------------------------------------------------------------- ! pure elemental module function transition_iseq ( transition1 , transition2 ) result ( res ) !! Test if two transitions are equal implicit none type ( asymtop_rot_transition_type ), intent ( in ) :: transition1 , transition2 logical :: res res = . false . if ( transition1 % lo . ne . transition2 % lo ) return if ( transition1 % up . ne . transition2 % up ) return res = . true . end function transition_iseq ! ------------------------------------------------------------------------------------------------------------------------------- ! pure elemental module function channel_iseq ( channel1 , channel2 ) result ( res ) !! Test for channel equality on the basis of their quantum numbers only use rotex__system , only : die implicit none class ( channel_type ), intent ( in ) :: channel1 , channel2 logical :: res res = . false . if ( channel1 % nelec . ne . channel2 % nelec ) return select type ( channel1 ) ! -- electronic channel equality comparison type is ( elec_channel_type ) select type ( channel2 ) type is ( elec_channel_type ) if ( channel1 % l . ne . channel2 % l ) return if ( channel1 % ml . ne . channel2 % ml ) return class default call die ( \"Cannot compare an electronic channel to a different channel\" ) end select ! -- rotational channel equality comparison (with l) type is ( asymtop_rot_channel_l_type ) select type ( channel2 ) type is ( asymtop_rot_channel_l_type ) if ( channel1 % N . ne . channel2 % N ) return if ( channel1 % Ka . ne . channel2 % Ka ) return if ( channel1 % Kc . ne . channel2 % Kc ) return if ( channel1 % l . ne . channel2 % l ) return if ( channel1 % sym . ne . channel2 % sym ) return type is ( asymtop_rot_channel_type ) if ( channel1 % N . ne . channel2 % N ) return if ( channel1 % Ka . ne . channel2 % Ka ) return if ( channel1 % Kc . ne . channel2 % Kc ) return if ( channel1 % sym . ne . channel2 % sym ) return class default call die ( \"Cannot compare a rotational channel (with l) to a non-rotational channel\" ) end select ! -- rotational channel equality comparison (no l) type is ( asymtop_rot_channel_type ) select type ( channel2 ) class is ( asymtop_rot_channel_type ) if ( channel1 % N . ne . channel2 % N ) return if ( channel1 % Ka . ne . channel2 % Ka ) return if ( channel1 % Kc . ne . channel2 % Kc ) return if ( channel1 % sym . ne . channel2 % sym ) return class default call die ( \"Cannot compare a rotational channel (no l) to a non-rotational channel\" ) end select end select res = . true . end function channel_iseq ! ------------------------------------------------------------------------------------------------------------------------------- ! pure elemental module function channel_isne ( channel1 , channel2 ) result ( res ) implicit none class ( channel_type ), intent ( in ) :: channel1 , channel2 logical :: res res = . not . ( channel1 . eq . channel2 ) end function channel_isne ! ------------------------------------------------------------------------------------------------------------------------------- ! impure module subroutine permsort_elec_channels ( elec_channels , idx ) !! Sorts the inout array based on the quantum numbers of the channels, and returns !! the permutation array that would produce the same output implicit none type ( elec_channel_type ), intent ( inout ) :: elec_channels (:) integer , allocatable :: idx (:) integer :: ichan , jchan , nchan nchan = size ( elec_channels , 1 ) idx = [( ichan , ichan = 1 , nchan )] ! -- sort by nelec do ichan = 1 , nchan ; do jchan = ichan + 1 , nchan if ( elec_channels ( jchan ) % nelec . ge . elec_channels ( ichan ) % nelec ) cycle call swap_channels ( elec_channels , ichan , jchan ) call swap_ints ( idx , ichan , jchan ) enddo ; enddo ! -- sort by l do ichan = 1 , nchan ; do jchan = ichan + 1 , nchan if ( elec_channels ( jchan ) % nelec . ne . elec_channels ( ichan ) % nelec ) cycle if ( elec_channels ( jchan ) % l . ge . elec_channels ( ichan ) % l ) cycle call swap_channels ( elec_channels , ichan , jchan ) call swap_ints ( idx , ichan , jchan ) enddo ; enddo ! -- sort by λ (ml) do ichan = 1 , nchan ; do jchan = ichan + 1 , nchan if ( elec_channels ( jchan ) % nelec . ne . elec_channels ( ichan ) % nelec ) cycle if ( elec_channels ( jchan ) % l . ne . elec_channels ( ichan ) % l ) cycle if ( elec_channels ( jchan ) % ml . ge . elec_channels ( ichan ) % ml ) cycle call swap_channels ( elec_channels , ichan , jchan ) call swap_ints ( idx , ichan , jchan ) enddo ; enddo end subroutine permsort_elec_channels ! ------------------------------------------------------------------------------------------------------------------------------- ! impure module subroutine sort_elec_channels ( elec_channels ) !! Sorts the inout array based on the quantum numbers of the channels implicit none type ( elec_channel_type ), intent ( inout ) :: elec_channels (:) integer :: ichan , jchan , nchan nchan = size ( elec_channels , 1 ) ! -- sort by nelec do ichan = 1 , nchan ; do jchan = ichan + 1 , nchan if ( elec_channels ( jchan ) % nelec . ge . elec_channels ( ichan ) % nelec ) cycle call swap_channels ( elec_channels , ichan , jchan ) enddo ; enddo ! -- sort by l do ichan = 1 , nchan ; do jchan = ichan + 1 , nchan if ( elec_channels ( jchan ) % nelec . ne . elec_channels ( ichan ) % nelec ) cycle if ( elec_channels ( jchan ) % l . ge . elec_channels ( ichan ) % l ) cycle call swap_channels ( elec_channels , ichan , jchan ) enddo ; enddo ! -- sort by λ (ml) do ichan = 1 , nchan ; do jchan = ichan + 1 , nchan if ( elec_channels ( jchan ) % nelec . ne . elec_channels ( ichan ) % nelec ) cycle if ( elec_channels ( jchan ) % l . ne . elec_channels ( ichan ) % l ) cycle if ( elec_channels ( jchan ) % ml . ge . elec_channels ( ichan ) % ml ) cycle call swap_channels ( elec_channels , ichan , jchan ) enddo ; enddo end subroutine sort_elec_channels ! ------------------------------------------------------------------------------------------------------------------------------- ! impure module subroutine sort_channels_by_energy ( channels ) !! Bubble sort the array of channels such that the channel energies are in ascending order implicit none class ( channel_type ), intent ( inout ) :: channels (:) logical :: swapped integer :: nchans integer :: j , i nchans = size ( channels , 1 ) do j = nchans - 1 , 1 , - 1 swapped = . false . do i = 1 , j if ( channels ( i ) % E . le . channels ( i + 1 ) % E ) cycle call swap_channels ( channels , i , i + 1 ) swapped = . true . enddo if (. not . swapped ) exit enddo end subroutine sort_channels_by_energy ! ------------------------------------------------------------------------------------------------------------------------------- ! impure module subroutine swap_ints ( arr , ichan , jchan ) !! Swaps the array elements at arr(ichan) and arr(jchan) use rotex__system , only : die implicit none integer , intent ( inout ) :: arr (:) integer , intent ( in ) :: ichan , jchan integer :: tmp if ( ichan . lt . lbound ( arr , 1 ) . OR . ichan . gt . ubound ( arr , 1 )) call die ( \"Trying to swap ints,& & but one of the indices exceeds the bounds of the int array\" ) if ( jchan . lt . lbound ( arr , 1 ) . OR . jchan . gt . ubound ( arr , 1 )) call die ( \"Trying to swap ints,& & but one of the indices exceeds the bounds of the int array\" ) tmp = arr ( ichan ) arr ( ichan ) = arr ( jchan ) arr ( jchan ) = tmp end subroutine swap_ints ! ------------------------------------------------------------------------------------------------------------------------------- ! impure module subroutine swap_channels ( channels , ichan , jchan ) !! Swaps the channels at channels(ichan) and channels(jchan) use rotex__system , only : die implicit none class ( channel_type ), intent ( inout ) :: channels (:) integer , intent ( in ) :: ichan , jchan class ( channel_type ), allocatable :: tmp if ( ichan . lt . lbound ( channels , 1 ) . OR . ichan . gt . ubound ( channels , 1 )) call die ( \"Trying to swap channels,& & but one of the indices exceeds the bounds of the channel array\" ) if ( jchan . lt . lbound ( channels , 1 ) . OR . jchan . gt . ubound ( channels , 1 )) call die ( \"Trying to swap channels,& & but one of the indices exceeds the bounds of the channel array\" ) allocate ( tmp , source = channels ( ichan )) tmp = channels ( ichan ) channels ( ichan ) = channels ( jchan ) channels ( jchan ) = tmp deallocate ( tmp ) end subroutine swap_channels ! ------------------------------------------------------------------------------------------------------------------------------- ! pure module function findloc_transitions ( targs , search ) result ( idxtarg ) !! Find the indices for each element in targs that map to the elements in search. !! Return 0 if there is no such mapping. implicit none type ( asymtop_rot_transition_type ), intent ( in ) :: targs (:), search (:) integer , allocatable :: idxtarg (:) !! TARGS -> SEARCH mapping integer , parameter :: IDX_NOT_FOUND = 0 integer :: isearch , itarg , ntargs , nsearch integer , allocatable :: idxsearch (:) logical , allocatable :: mask (:) ntargs = size ( targs , 1 ) nsearch = size ( search , 1 ) allocate ( idxtarg ( ntargs ), source = IDX_NOT_FOUND ) do itarg = 1 , ntargs mask = search . eq . targs ( itarg ) if ( all ( mask . eqv . . false .)) cycle ! cycle if no match idxsearch = pack ([( isearch , isearch = 1 , nsearch )], mask ) idxtarg ( itarg ) = idxsearch ( 1 ) ! take first match enddo end function findloc_transitions ! ! ------------------------------------------------------------------------------------------------------------------------------- ! ! pure module subroutine swap_elec_channel_values(elec_channels, ichan, jchan) !   !! Swaps the channels at elec_channels(ichan) and elec_channels(jchan) !   use rotex__system, only: die !   implicit none !   type(elec_channel_type), intent(inout) :: elec_channels(:) !   integer, intent(in) :: ichan, jchan !   type(elec_channel_type) :: tmp !   if(ichan .lt. lbound(elec_channels, 1) .OR. ichan .gt. ubound(elec_channels, 1)) call die(\"Trying to swap channels,& !     & but one of the indices exceeds the bounds of the channel array\") !   if(jchan .lt. lbound(elec_channels, 1) .OR. jchan .gt. ubound(elec_channels, 1)) call die(\"Trying to swap channels,& !     & but one of the indices exceeds the bounds of the channel array\") !   tmp = elec_channels(ichan) !   elec_channels(ichan) = elec_channels(jchan) !   elec_channels(jchan) = tmp ! end subroutine swap_elec_channel_values ! ! ------------------------------------------------------------------------------------------------------------------------------- ! ! pure module subroutine swap_asymtop_rot_channel_values(asymtop_rot_channels, ichan, jchan) !   !! Swaps the channels at asymtop_rot_channels(ichan) and asymtop_rot_channels(jchan) !   use rotex__system, only: die !   implicit none !   type(asymtop_rot_channel_type), intent(inout) :: asymtop_rot_channels(:) !   integer, intent(in) :: ichan, jchan !   type(asymtop_rot_channel_type) :: tmp !   if(ichan .lt. lbound(asymtop_rot_channels, 1) .OR. ichan .gt. ubound(asymtop_rot_channels, 1)) & !     call die(\"Trying to swap channels, but one of the indices exceeds the bounds of the channel array\") !   if(jchan .lt. lbound(asymtop_rot_channels, 1) .OR. jchan .gt. ubound(asymtop_rot_channels, 1)) & !     call die(\"Trying to swap channels, but one of the indices exceeds the bounds of the channel array\") !   tmp = asymtop_rot_channels(ichan) !   asymtop_rot_channels(ichan) = asymtop_rot_channels(jchan) !   asymtop_rot_channels(jchan) = tmp ! end subroutine swap_asymtop_rot_channel_values ! ================================================================================================================================ ! end module rotex__types ! ================================================================================================================================ !","tags":"","url":"sourcefile/rotex__types.f.html"}]}